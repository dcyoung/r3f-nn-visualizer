var n6=Object.defineProperty;var s6=(n,e,t)=>e in n?n6(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var tu=(n,e,t)=>(s6(n,typeof e!="symbol"?e+"":e,t),t);import{TRAINING_DATA as Zp}from"https://storage.googleapis.com/jmstore/TensorFlowJS/EdX/TrainingData/mnist.js";function i6(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in n)){const r=Object.getOwnPropertyDescriptor(s,i);r&&Object.defineProperty(n,i,r.get?r:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerpolicy&&(r.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?r.credentials="include":i.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();var xh=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function mI(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function r6(n){var e=n.default;if(typeof e=="function"){var t=function(){return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var i=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:function(){return n[s]}})}),t}var qe={exports:{}},Zt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ag=Symbol.for("react.element"),o6=Symbol.for("react.portal"),a6=Symbol.for("react.fragment"),l6=Symbol.for("react.strict_mode"),c6=Symbol.for("react.profiler"),u6=Symbol.for("react.provider"),h6=Symbol.for("react.context"),d6=Symbol.for("react.forward_ref"),f6=Symbol.for("react.suspense"),p6=Symbol.for("react.memo"),m6=Symbol.for("react.lazy"),xR=Symbol.iterator;function g6(n){return n===null||typeof n!="object"?null:(n=xR&&n[xR]||n["@@iterator"],typeof n=="function"?n:null)}var YP={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},ZP=Object.assign,JP={};function Tf(n,e,t){this.props=n,this.context=e,this.refs=JP,this.updater=t||YP}Tf.prototype.isReactComponent={};Tf.prototype.setState=function(n,e){if(typeof n!="object"&&typeof n!="function"&&n!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,n,e,"setState")};Tf.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")};function QP(){}QP.prototype=Tf.prototype;function gI(n,e,t){this.props=n,this.context=e,this.refs=JP,this.updater=t||YP}var xI=gI.prototype=new QP;xI.constructor=gI;ZP(xI,Tf.prototype);xI.isPureReactComponent=!0;var yR=Array.isArray,e$=Object.prototype.hasOwnProperty,yI={current:null},t$={key:!0,ref:!0,__self:!0,__source:!0};function n$(n,e,t){var s,i={},r=null,o=null;if(e!=null)for(s in e.ref!==void 0&&(o=e.ref),e.key!==void 0&&(r=""+e.key),e)e$.call(e,s)&&!t$.hasOwnProperty(s)&&(i[s]=e[s]);var a=arguments.length-2;if(a===1)i.children=t;else if(1<a){for(var l=Array(a),c=0;c<a;c++)l[c]=arguments[c+2];i.children=l}if(n&&n.defaultProps)for(s in a=n.defaultProps,a)i[s]===void 0&&(i[s]=a[s]);return{$$typeof:ag,type:n,key:r,ref:o,props:i,_owner:yI.current}}function x6(n,e){return{$$typeof:ag,type:n.type,key:e,ref:n.ref,props:n.props,_owner:n._owner}}function vI(n){return typeof n=="object"&&n!==null&&n.$$typeof===ag}function y6(n){var e={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,function(t){return e[t]})}var vR=/\/+/g;function c_(n,e){return typeof n=="object"&&n!==null&&n.key!=null?y6(""+n.key):e.toString(36)}function xv(n,e,t,s,i){var r=typeof n;(r==="undefined"||r==="boolean")&&(n=null);var o=!1;if(n===null)o=!0;else switch(r){case"string":case"number":o=!0;break;case"object":switch(n.$$typeof){case ag:case o6:o=!0}}if(o)return o=n,i=i(o),n=s===""?"."+c_(o,0):s,yR(i)?(t="",n!=null&&(t=n.replace(vR,"$&/")+"/"),xv(i,e,t,"",function(c){return c})):i!=null&&(vI(i)&&(i=x6(i,t+(!i.key||o&&o.key===i.key?"":(""+i.key).replace(vR,"$&/")+"/")+n)),e.push(i)),1;if(o=0,s=s===""?".":s+":",yR(n))for(var a=0;a<n.length;a++){r=n[a];var l=s+c_(r,a);o+=xv(r,e,t,l,i)}else if(l=g6(n),typeof l=="function")for(n=l.call(n),a=0;!(r=n.next()).done;)r=r.value,l=s+c_(r,a++),o+=xv(r,e,t,l,i);else if(r==="object")throw e=String(n),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(n).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return o}function qx(n,e,t){if(n==null)return n;var s=[],i=0;return xv(n,s,"","",function(r){return e.call(t,r,i++)}),s}function v6(n){if(n._status===-1){var e=n._result;e=e(),e.then(function(t){(n._status===0||n._status===-1)&&(n._status=1,n._result=t)},function(t){(n._status===0||n._status===-1)&&(n._status=2,n._result=t)}),n._status===-1&&(n._status=0,n._result=e)}if(n._status===1)return n._result.default;throw n._result}var Wi={current:null},yv={transition:null},w6={ReactCurrentDispatcher:Wi,ReactCurrentBatchConfig:yv,ReactCurrentOwner:yI};Zt.Children={map:qx,forEach:function(n,e,t){qx(n,function(){e.apply(this,arguments)},t)},count:function(n){var e=0;return qx(n,function(){e++}),e},toArray:function(n){return qx(n,function(e){return e})||[]},only:function(n){if(!vI(n))throw Error("React.Children.only expected to receive a single React element child.");return n}};Zt.Component=Tf;Zt.Fragment=a6;Zt.Profiler=c6;Zt.PureComponent=gI;Zt.StrictMode=l6;Zt.Suspense=f6;Zt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=w6;Zt.cloneElement=function(n,e,t){if(n==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+n+".");var s=ZP({},n.props),i=n.key,r=n.ref,o=n._owner;if(e!=null){if(e.ref!==void 0&&(r=e.ref,o=yI.current),e.key!==void 0&&(i=""+e.key),n.type&&n.type.defaultProps)var a=n.type.defaultProps;for(l in e)e$.call(e,l)&&!t$.hasOwnProperty(l)&&(s[l]=e[l]===void 0&&a!==void 0?a[l]:e[l])}var l=arguments.length-2;if(l===1)s.children=t;else if(1<l){a=Array(l);for(var c=0;c<l;c++)a[c]=arguments[c+2];s.children=a}return{$$typeof:ag,type:n.type,key:i,ref:r,props:s,_owner:o}};Zt.createContext=function(n){return n={$$typeof:h6,_currentValue:n,_currentValue2:n,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},n.Provider={$$typeof:u6,_context:n},n.Consumer=n};Zt.createElement=n$;Zt.createFactory=function(n){var e=n$.bind(null,n);return e.type=n,e};Zt.createRef=function(){return{current:null}};Zt.forwardRef=function(n){return{$$typeof:d6,render:n}};Zt.isValidElement=vI;Zt.lazy=function(n){return{$$typeof:m6,_payload:{_status:-1,_result:n},_init:v6}};Zt.memo=function(n,e){return{$$typeof:p6,type:n,compare:e===void 0?null:e}};Zt.startTransition=function(n){var e=yv.transition;yv.transition={};try{n()}finally{yv.transition=e}};Zt.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};Zt.useCallback=function(n,e){return Wi.current.useCallback(n,e)};Zt.useContext=function(n){return Wi.current.useContext(n)};Zt.useDebugValue=function(){};Zt.useDeferredValue=function(n){return Wi.current.useDeferredValue(n)};Zt.useEffect=function(n,e){return Wi.current.useEffect(n,e)};Zt.useId=function(){return Wi.current.useId()};Zt.useImperativeHandle=function(n,e,t){return Wi.current.useImperativeHandle(n,e,t)};Zt.useInsertionEffect=function(n,e){return Wi.current.useInsertionEffect(n,e)};Zt.useLayoutEffect=function(n,e){return Wi.current.useLayoutEffect(n,e)};Zt.useMemo=function(n,e){return Wi.current.useMemo(n,e)};Zt.useReducer=function(n,e,t){return Wi.current.useReducer(n,e,t)};Zt.useRef=function(n){return Wi.current.useRef(n)};Zt.useState=function(n){return Wi.current.useState(n)};Zt.useSyncExternalStore=function(n,e,t){return Wi.current.useSyncExternalStore(n,e,t)};Zt.useTransition=function(){return Wi.current.useTransition()};Zt.version="18.2.0";(function(n){n.exports=Zt})(qe);const b6=mI(qe.exports);var XC={},s$={exports:{}},Rr={},i$={exports:{}},r$={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(n){function e(D,$){var U=D.length;D.push($);e:for(;0<U;){var B=U-1>>>1,X=D[B];if(0<i(X,$))D[B]=$,D[U]=X,U=B;else break e}}function t(D){return D.length===0?null:D[0]}function s(D){if(D.length===0)return null;var $=D[0],U=D.pop();if(U!==$){D[0]=U;e:for(var B=0,X=D.length,te=X>>>1;B<te;){var oe=2*(B+1)-1,ue=D[oe],Q=oe+1,ke=D[Q];if(0>i(ue,U))Q<X&&0>i(ke,ue)?(D[B]=ke,D[Q]=U,B=Q):(D[B]=ue,D[oe]=U,B=oe);else if(Q<X&&0>i(ke,U))D[B]=ke,D[Q]=U,B=Q;else break e}}return $}function i(D,$){var U=D.sortIndex-$.sortIndex;return U!==0?U:D.id-$.id}if(typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],c=[],u=1,h=null,d=3,f=!1,m=!1,x=!1,y=typeof setTimeout=="function"?setTimeout:null,v=typeof clearTimeout=="function"?clearTimeout:null,w=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function b(D){for(var $=t(c);$!==null;){if($.callback===null)s(c);else if($.startTime<=D)s(c),$.sortIndex=$.expirationTime,e(l,$);else break;$=t(c)}}function S(D){if(x=!1,b(D),!m)if(t(l)!==null)m=!0,H(C);else{var $=t(c);$!==null&&Y(S,$.startTime-D)}}function C(D,$){m=!1,x&&(x=!1,v(I),I=-1),f=!0;var U=d;try{for(b($),h=t(l);h!==null&&(!(h.expirationTime>$)||D&&!L());){var B=h.callback;if(typeof B=="function"){h.callback=null,d=h.priorityLevel;var X=B(h.expirationTime<=$);$=n.unstable_now(),typeof X=="function"?h.callback=X:h===t(l)&&s(l),b($)}else s(l);h=t(l)}if(h!==null)var te=!0;else{var oe=t(c);oe!==null&&Y(S,oe.startTime-$),te=!1}return te}finally{h=null,d=U,f=!1}}var E=!1,k=null,I=-1,A=5,N=-1;function L(){return!(n.unstable_now()-N<A)}function V(){if(k!==null){var D=n.unstable_now();N=D;var $=!0;try{$=k(!0,D)}finally{$?O():(E=!1,k=null)}}else E=!1}var O;if(typeof w=="function")O=function(){w(V)};else if(typeof MessageChannel<"u"){var P=new MessageChannel,W=P.port2;P.port1.onmessage=V,O=function(){W.postMessage(null)}}else O=function(){y(V,0)};function H(D){k=D,E||(E=!0,O())}function Y(D,$){I=y(function(){D(n.unstable_now())},$)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(D){D.callback=null},n.unstable_continueExecution=function(){m||f||(m=!0,H(C))},n.unstable_forceFrameRate=function(D){0>D||125<D?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):A=0<D?Math.floor(1e3/D):5},n.unstable_getCurrentPriorityLevel=function(){return d},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(D){switch(d){case 1:case 2:case 3:var $=3;break;default:$=d}var U=d;d=$;try{return D()}finally{d=U}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(D,$){switch(D){case 1:case 2:case 3:case 4:case 5:break;default:D=3}var U=d;d=D;try{return $()}finally{d=U}},n.unstable_scheduleCallback=function(D,$,U){var B=n.unstable_now();switch(typeof U=="object"&&U!==null?(U=U.delay,U=typeof U=="number"&&0<U?B+U:B):U=B,D){case 1:var X=-1;break;case 2:X=250;break;case 5:X=1073741823;break;case 4:X=1e4;break;default:X=5e3}return X=U+X,D={id:u++,callback:$,priorityLevel:D,startTime:U,expirationTime:X,sortIndex:-1},U>B?(D.sortIndex=U,e(c,D),t(l)===null&&D===t(c)&&(x?(v(I),I=-1):x=!0,Y(S,U-B))):(D.sortIndex=X,e(l,D),m||f||(m=!0,H(C))),D},n.unstable_shouldYield=L,n.unstable_wrapCallback=function(D){var $=d;return function(){var U=d;d=$;try{return D.apply(this,arguments)}finally{d=U}}}})(r$);(function(n){n.exports=r$})(i$);/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var o$=qe.exports,kr=i$.exports;function Ve(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a$=new Set,pm={};function yh(n,e){Yd(n,e),Yd(n+"Capture",e)}function Yd(n,e){for(pm[n]=e,n=0;n<e.length;n++)a$.add(e[n])}var cl=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),jC=Object.prototype.hasOwnProperty,S6=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wR={},bR={};function _6(n){return jC.call(bR,n)?!0:jC.call(wR,n)?!1:S6.test(n)?bR[n]=!0:(wR[n]=!0,!1)}function C6(n,e,t,s){if(t!==null&&t.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return s?!1:t!==null?!t.acceptsBooleans:(n=n.toLowerCase().slice(0,5),n!=="data-"&&n!=="aria-");default:return!1}}function T6(n,e,t,s){if(e===null||typeof e>"u"||C6(n,e,t,s))return!0;if(s)return!1;if(t!==null)switch(t.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function Gi(n,e,t,s,i,r,o){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=s,this.attributeNamespace=i,this.mustUseProperty=t,this.propertyName=n,this.type=e,this.sanitizeURL=r,this.removeEmptyString=o}var ri={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n){ri[n]=new Gi(n,0,!1,n,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(n){var e=n[0];ri[e]=new Gi(e,1,!1,n[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(n){ri[n]=new Gi(n,2,!1,n.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(n){ri[n]=new Gi(n,2,!1,n,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n){ri[n]=new Gi(n,3,!1,n.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(n){ri[n]=new Gi(n,3,!0,n,null,!1,!1)});["capture","download"].forEach(function(n){ri[n]=new Gi(n,4,!1,n,null,!1,!1)});["cols","rows","size","span"].forEach(function(n){ri[n]=new Gi(n,6,!1,n,null,!1,!1)});["rowSpan","start"].forEach(function(n){ri[n]=new Gi(n,5,!1,n.toLowerCase(),null,!1,!1)});var wI=/[\-:]([a-z])/g;function bI(n){return n[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n){var e=n.replace(wI,bI);ri[e]=new Gi(e,1,!1,n,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n){var e=n.replace(wI,bI);ri[e]=new Gi(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(n){var e=n.replace(wI,bI);ri[e]=new Gi(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(n){ri[n]=new Gi(n,1,!1,n.toLowerCase(),null,!1,!1)});ri.xlinkHref=new Gi("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(n){ri[n]=new Gi(n,1,!1,n.toLowerCase(),null,!0,!0)});function SI(n,e,t,s){var i=ri.hasOwnProperty(e)?ri[e]:null;(i!==null?i.type!==0:s||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(T6(e,t,i,s)&&(t=null),s||i===null?_6(e)&&(t===null?n.removeAttribute(e):n.setAttribute(e,""+t)):i.mustUseProperty?n[i.propertyName]=t===null?i.type===3?!1:"":t:(e=i.attributeName,s=i.attributeNamespace,t===null?n.removeAttribute(e):(i=i.type,t=i===3||i===4&&t===!0?"":""+t,s?n.setAttributeNS(s,e,t):n.setAttribute(e,t))))}var yl=o$.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Kx=Symbol.for("react.element"),wd=Symbol.for("react.portal"),bd=Symbol.for("react.fragment"),_I=Symbol.for("react.strict_mode"),qC=Symbol.for("react.profiler"),l$=Symbol.for("react.provider"),c$=Symbol.for("react.context"),CI=Symbol.for("react.forward_ref"),KC=Symbol.for("react.suspense"),YC=Symbol.for("react.suspense_list"),TI=Symbol.for("react.memo"),Hl=Symbol.for("react.lazy"),u$=Symbol.for("react.offscreen"),SR=Symbol.iterator;function xp(n){return n===null||typeof n!="object"?null:(n=SR&&n[SR]||n["@@iterator"],typeof n=="function"?n:null)}var qn=Object.assign,u_;function Bp(n){if(u_===void 0)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);u_=e&&e[1]||""}return`
`+u_+n}var h_=!1;function d_(n,e){if(!n||h_)return"";h_=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(c){var s=c}Reflect.construct(n,[],e)}else{try{e.call()}catch(c){s=c}n.call(e.prototype)}else{try{throw Error()}catch(c){s=c}n()}}catch(c){if(c&&s&&typeof c.stack=="string"){for(var i=c.stack.split(`
`),r=s.stack.split(`
`),o=i.length-1,a=r.length-1;1<=o&&0<=a&&i[o]!==r[a];)a--;for(;1<=o&&0<=a;o--,a--)if(i[o]!==r[a]){if(o!==1||a!==1)do if(o--,a--,0>a||i[o]!==r[a]){var l=`
`+i[o].replace(" at new "," at ");return n.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",n.displayName)),l}while(1<=o&&0<=a);break}}}finally{h_=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?Bp(n):""}function I6(n){switch(n.tag){case 5:return Bp(n.type);case 16:return Bp("Lazy");case 13:return Bp("Suspense");case 19:return Bp("SuspenseList");case 0:case 2:case 15:return n=d_(n.type,!1),n;case 11:return n=d_(n.type.render,!1),n;case 1:return n=d_(n.type,!0),n;default:return""}}function ZC(n){if(n==null)return null;if(typeof n=="function")return n.displayName||n.name||null;if(typeof n=="string")return n;switch(n){case bd:return"Fragment";case wd:return"Portal";case qC:return"Profiler";case _I:return"StrictMode";case KC:return"Suspense";case YC:return"SuspenseList"}if(typeof n=="object")switch(n.$$typeof){case c$:return(n.displayName||"Context")+".Consumer";case l$:return(n._context.displayName||"Context")+".Provider";case CI:var e=n.render;return n=n.displayName,n||(n=e.displayName||e.name||"",n=n!==""?"ForwardRef("+n+")":"ForwardRef"),n;case TI:return e=n.displayName||null,e!==null?e:ZC(n.type)||"Memo";case Hl:e=n._payload,n=n._init;try{return ZC(n(e))}catch{}}return null}function E6(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=e.render,n=n.displayName||n.name||"",e.displayName||(n!==""?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return ZC(e);case 8:return e===_I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function yc(n){switch(typeof n){case"boolean":case"number":case"string":case"undefined":return n;case"object":return n;default:return""}}function h$(n){var e=n.type;return(n=n.nodeName)&&n.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function M6(n){var e=h$(n)?"checked":"value",t=Object.getOwnPropertyDescriptor(n.constructor.prototype,e),s=""+n[e];if(!n.hasOwnProperty(e)&&typeof t<"u"&&typeof t.get=="function"&&typeof t.set=="function"){var i=t.get,r=t.set;return Object.defineProperty(n,e,{configurable:!0,get:function(){return i.call(this)},set:function(o){s=""+o,r.call(this,o)}}),Object.defineProperty(n,e,{enumerable:t.enumerable}),{getValue:function(){return s},setValue:function(o){s=""+o},stopTracking:function(){n._valueTracker=null,delete n[e]}}}}function Yx(n){n._valueTracker||(n._valueTracker=M6(n))}function d$(n){if(!n)return!1;var e=n._valueTracker;if(!e)return!0;var t=e.getValue(),s="";return n&&(s=h$(n)?n.checked?"true":"false":n.value),n=s,n!==t?(e.setValue(n),!0):!1}function zv(n){if(n=n||(typeof document<"u"?document:void 0),typeof n>"u")return null;try{return n.activeElement||n.body}catch{return n.body}}function JC(n,e){var t=e.checked;return qn({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:t!=null?t:n._wrapperState.initialChecked})}function _R(n,e){var t=e.defaultValue==null?"":e.defaultValue,s=e.checked!=null?e.checked:e.defaultChecked;t=yc(e.value!=null?e.value:t),n._wrapperState={initialChecked:s,initialValue:t,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function f$(n,e){e=e.checked,e!=null&&SI(n,"checked",e,!1)}function QC(n,e){f$(n,e);var t=yc(e.value),s=e.type;if(t!=null)s==="number"?(t===0&&n.value===""||n.value!=t)&&(n.value=""+t):n.value!==""+t&&(n.value=""+t);else if(s==="submit"||s==="reset"){n.removeAttribute("value");return}e.hasOwnProperty("value")?e2(n,e.type,t):e.hasOwnProperty("defaultValue")&&e2(n,e.type,yc(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(n.defaultChecked=!!e.defaultChecked)}function CR(n,e,t){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var s=e.type;if(!(s!=="submit"&&s!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+n._wrapperState.initialValue,t||e===n.value||(n.value=e),n.defaultValue=e}t=n.name,t!==""&&(n.name=""),n.defaultChecked=!!n._wrapperState.initialChecked,t!==""&&(n.name=t)}function e2(n,e,t){(e!=="number"||zv(n.ownerDocument)!==n)&&(t==null?n.defaultValue=""+n._wrapperState.initialValue:n.defaultValue!==""+t&&(n.defaultValue=""+t))}var Up=Array.isArray;function Od(n,e,t,s){if(n=n.options,e){e={};for(var i=0;i<t.length;i++)e["$"+t[i]]=!0;for(t=0;t<n.length;t++)i=e.hasOwnProperty("$"+n[t].value),n[t].selected!==i&&(n[t].selected=i),i&&s&&(n[t].defaultSelected=!0)}else{for(t=""+yc(t),e=null,i=0;i<n.length;i++){if(n[i].value===t){n[i].selected=!0,s&&(n[i].defaultSelected=!0);return}e!==null||n[i].disabled||(e=n[i])}e!==null&&(e.selected=!0)}}function t2(n,e){if(e.dangerouslySetInnerHTML!=null)throw Error(Ve(91));return qn({},e,{value:void 0,defaultValue:void 0,children:""+n._wrapperState.initialValue})}function TR(n,e){var t=e.value;if(t==null){if(t=e.children,e=e.defaultValue,t!=null){if(e!=null)throw Error(Ve(92));if(Up(t)){if(1<t.length)throw Error(Ve(93));t=t[0]}e=t}e==null&&(e=""),t=e}n._wrapperState={initialValue:yc(t)}}function p$(n,e){var t=yc(e.value),s=yc(e.defaultValue);t!=null&&(t=""+t,t!==n.value&&(n.value=t),e.defaultValue==null&&n.defaultValue!==t&&(n.defaultValue=t)),s!=null&&(n.defaultValue=""+s)}function IR(n){var e=n.textContent;e===n._wrapperState.initialValue&&e!==""&&e!==null&&(n.value=e)}function m$(n){switch(n){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function n2(n,e){return n==null||n==="http://www.w3.org/1999/xhtml"?m$(e):n==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":n}var Zx,g$=function(n){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,t,s,i){MSApp.execUnsafeLocalFunction(function(){return n(e,t,s,i)})}:n}(function(n,e){if(n.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in n)n.innerHTML=e;else{for(Zx=Zx||document.createElement("div"),Zx.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=Zx.firstChild;n.firstChild;)n.removeChild(n.firstChild);for(;e.firstChild;)n.appendChild(e.firstChild)}});function mm(n,e){if(e){var t=n.firstChild;if(t&&t===n.lastChild&&t.nodeType===3){t.nodeValue=e;return}}n.textContent=e}var Jp={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},k6=["Webkit","ms","Moz","O"];Object.keys(Jp).forEach(function(n){k6.forEach(function(e){e=e+n.charAt(0).toUpperCase()+n.substring(1),Jp[e]=Jp[n]})});function x$(n,e,t){return e==null||typeof e=="boolean"||e===""?"":t||typeof e!="number"||e===0||Jp.hasOwnProperty(n)&&Jp[n]?(""+e).trim():e+"px"}function y$(n,e){n=n.style;for(var t in e)if(e.hasOwnProperty(t)){var s=t.indexOf("--")===0,i=x$(t,e[t],s);t==="float"&&(t="cssFloat"),s?n.setProperty(t,i):n[t]=i}}var A6=qn({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function s2(n,e){if(e){if(A6[n]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(Ve(137,n));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(Ve(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(Ve(61))}if(e.style!=null&&typeof e.style!="object")throw Error(Ve(62))}}function i2(n,e){if(n.indexOf("-")===-1)return typeof e.is=="string";switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var r2=null;function II(n){return n=n.target||n.srcElement||window,n.correspondingUseElement&&(n=n.correspondingUseElement),n.nodeType===3?n.parentNode:n}var o2=null,zd=null,Bd=null;function ER(n){if(n=ug(n)){if(typeof o2!="function")throw Error(Ve(280));var e=n.stateNode;e&&(e=Y1(e),o2(n.stateNode,n.type,e))}}function v$(n){zd?Bd?Bd.push(n):Bd=[n]:zd=n}function w$(){if(zd){var n=zd,e=Bd;if(Bd=zd=null,ER(n),e)for(n=0;n<e.length;n++)ER(e[n])}}function b$(n,e){return n(e)}function S$(){}var f_=!1;function _$(n,e,t){if(f_)return n(e,t);f_=!0;try{return b$(n,e,t)}finally{f_=!1,(zd!==null||Bd!==null)&&(S$(),w$())}}function gm(n,e){var t=n.stateNode;if(t===null)return null;var s=Y1(t);if(s===null)return null;t=s[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(s=!s.disabled)||(n=n.type,s=!(n==="button"||n==="input"||n==="select"||n==="textarea")),n=!s;break e;default:n=!1}if(n)return null;if(t&&typeof t!="function")throw Error(Ve(231,e,typeof t));return t}var a2=!1;if(cl)try{var yp={};Object.defineProperty(yp,"passive",{get:function(){a2=!0}}),window.addEventListener("test",yp,yp),window.removeEventListener("test",yp,yp)}catch{a2=!1}function N6(n,e,t,s,i,r,o,a,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(t,c)}catch(u){this.onError(u)}}var Qp=!1,Bv=null,Uv=!1,l2=null,R6={onError:function(n){Qp=!0,Bv=n}};function D6(n,e,t,s,i,r,o,a,l){Qp=!1,Bv=null,N6.apply(R6,arguments)}function L6(n,e,t,s,i,r,o,a,l){if(D6.apply(this,arguments),Qp){if(Qp){var c=Bv;Qp=!1,Bv=null}else throw Error(Ve(198));Uv||(Uv=!0,l2=c)}}function vh(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do e=n,(e.flags&4098)!==0&&(t=e.return),n=e.return;while(n)}return e.tag===3?t:null}function C$(n){if(n.tag===13){var e=n.memoizedState;if(e===null&&(n=n.alternate,n!==null&&(e=n.memoizedState)),e!==null)return e.dehydrated}return null}function MR(n){if(vh(n)!==n)throw Error(Ve(188))}function P6(n){var e=n.alternate;if(!e){if(e=vh(n),e===null)throw Error(Ve(188));return e!==n?null:n}for(var t=n,s=e;;){var i=t.return;if(i===null)break;var r=i.alternate;if(r===null){if(s=i.return,s!==null){t=s;continue}break}if(i.child===r.child){for(r=i.child;r;){if(r===t)return MR(i),n;if(r===s)return MR(i),e;r=r.sibling}throw Error(Ve(188))}if(t.return!==s.return)t=i,s=r;else{for(var o=!1,a=i.child;a;){if(a===t){o=!0,t=i,s=r;break}if(a===s){o=!0,s=i,t=r;break}a=a.sibling}if(!o){for(a=r.child;a;){if(a===t){o=!0,t=r,s=i;break}if(a===s){o=!0,s=r,t=i;break}a=a.sibling}if(!o)throw Error(Ve(189))}}if(t.alternate!==s)throw Error(Ve(190))}if(t.tag!==3)throw Error(Ve(188));return t.stateNode.current===t?n:e}function T$(n){return n=P6(n),n!==null?I$(n):null}function I$(n){if(n.tag===5||n.tag===6)return n;for(n=n.child;n!==null;){var e=I$(n);if(e!==null)return e;n=n.sibling}return null}var E$=kr.unstable_scheduleCallback,kR=kr.unstable_cancelCallback,$6=kr.unstable_shouldYield,F6=kr.unstable_requestPaint,cs=kr.unstable_now,O6=kr.unstable_getCurrentPriorityLevel,EI=kr.unstable_ImmediatePriority,M$=kr.unstable_UserBlockingPriority,Vv=kr.unstable_NormalPriority,z6=kr.unstable_LowPriority,k$=kr.unstable_IdlePriority,X1=null,wa=null;function B6(n){if(wa&&typeof wa.onCommitFiberRoot=="function")try{wa.onCommitFiberRoot(X1,n,void 0,(n.current.flags&128)===128)}catch{}}var $o=Math.clz32?Math.clz32:W6,U6=Math.log,V6=Math.LN2;function W6(n){return n>>>=0,n===0?32:31-(U6(n)/V6|0)|0}var Jx=64,Qx=4194304;function Vp(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return n&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return n&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function Wv(n,e){var t=n.pendingLanes;if(t===0)return 0;var s=0,i=n.suspendedLanes,r=n.pingedLanes,o=t&268435455;if(o!==0){var a=o&~i;a!==0?s=Vp(a):(r&=o,r!==0&&(s=Vp(r)))}else o=t&~i,o!==0?s=Vp(o):r!==0&&(s=Vp(r));if(s===0)return 0;if(e!==0&&e!==s&&(e&i)===0&&(i=s&-s,r=e&-e,i>=r||i===16&&(r&4194240)!==0))return e;if((s&4)!==0&&(s|=t&16),e=n.entangledLanes,e!==0)for(n=n.entanglements,e&=s;0<e;)t=31-$o(e),i=1<<t,s|=n[t],e&=~i;return s}function G6(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function H6(n,e){for(var t=n.suspendedLanes,s=n.pingedLanes,i=n.expirationTimes,r=n.pendingLanes;0<r;){var o=31-$o(r),a=1<<o,l=i[o];l===-1?((a&t)===0||(a&s)!==0)&&(i[o]=G6(a,e)):l<=e&&(n.expiredLanes|=a),r&=~a}}function c2(n){return n=n.pendingLanes&-1073741825,n!==0?n:n&1073741824?1073741824:0}function A$(){var n=Jx;return Jx<<=1,(Jx&4194240)===0&&(Jx=64),n}function p_(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function lg(n,e,t){n.pendingLanes|=e,e!==536870912&&(n.suspendedLanes=0,n.pingedLanes=0),n=n.eventTimes,e=31-$o(e),n[e]=t}function X6(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var s=n.eventTimes;for(n=n.expirationTimes;0<t;){var i=31-$o(t),r=1<<i;e[i]=0,s[i]=-1,n[i]=-1,t&=~r}}function MI(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var s=31-$o(t),i=1<<s;i&e|n[s]&e&&(n[s]|=e),t&=~i}}var xn=0;function N$(n){return n&=-n,1<n?4<n?(n&268435455)!==0?16:536870912:4:1}var R$,kI,D$,L$,P$,u2=!1,ey=[],ic=null,rc=null,oc=null,xm=new Map,ym=new Map,Kl=[],j6="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function AR(n,e){switch(n){case"focusin":case"focusout":ic=null;break;case"dragenter":case"dragleave":rc=null;break;case"mouseover":case"mouseout":oc=null;break;case"pointerover":case"pointerout":xm.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":ym.delete(e.pointerId)}}function vp(n,e,t,s,i,r){return n===null||n.nativeEvent!==r?(n={blockedOn:e,domEventName:t,eventSystemFlags:s,nativeEvent:r,targetContainers:[i]},e!==null&&(e=ug(e),e!==null&&kI(e)),n):(n.eventSystemFlags|=s,e=n.targetContainers,i!==null&&e.indexOf(i)===-1&&e.push(i),n)}function q6(n,e,t,s,i){switch(e){case"focusin":return ic=vp(ic,n,e,t,s,i),!0;case"dragenter":return rc=vp(rc,n,e,t,s,i),!0;case"mouseover":return oc=vp(oc,n,e,t,s,i),!0;case"pointerover":var r=i.pointerId;return xm.set(r,vp(xm.get(r)||null,n,e,t,s,i)),!0;case"gotpointercapture":return r=i.pointerId,ym.set(r,vp(ym.get(r)||null,n,e,t,s,i)),!0}return!1}function $$(n){var e=Cu(n.target);if(e!==null){var t=vh(e);if(t!==null){if(e=t.tag,e===13){if(e=C$(t),e!==null){n.blockedOn=e,P$(n.priority,function(){D$(t)});return}}else if(e===3&&t.stateNode.current.memoizedState.isDehydrated){n.blockedOn=t.tag===3?t.stateNode.containerInfo:null;return}}}n.blockedOn=null}function vv(n){if(n.blockedOn!==null)return!1;for(var e=n.targetContainers;0<e.length;){var t=h2(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(t===null){t=n.nativeEvent;var s=new t.constructor(t.type,t);r2=s,t.target.dispatchEvent(s),r2=null}else return e=ug(t),e!==null&&kI(e),n.blockedOn=t,!1;e.shift()}return!0}function NR(n,e,t){vv(n)&&t.delete(e)}function K6(){u2=!1,ic!==null&&vv(ic)&&(ic=null),rc!==null&&vv(rc)&&(rc=null),oc!==null&&vv(oc)&&(oc=null),xm.forEach(NR),ym.forEach(NR)}function wp(n,e){n.blockedOn===e&&(n.blockedOn=null,u2||(u2=!0,kr.unstable_scheduleCallback(kr.unstable_NormalPriority,K6)))}function vm(n){function e(i){return wp(i,n)}if(0<ey.length){wp(ey[0],n);for(var t=1;t<ey.length;t++){var s=ey[t];s.blockedOn===n&&(s.blockedOn=null)}}for(ic!==null&&wp(ic,n),rc!==null&&wp(rc,n),oc!==null&&wp(oc,n),xm.forEach(e),ym.forEach(e),t=0;t<Kl.length;t++)s=Kl[t],s.blockedOn===n&&(s.blockedOn=null);for(;0<Kl.length&&(t=Kl[0],t.blockedOn===null);)$$(t),t.blockedOn===null&&Kl.shift()}var Ud=yl.ReactCurrentBatchConfig,Gv=!0;function Y6(n,e,t,s){var i=xn,r=Ud.transition;Ud.transition=null;try{xn=1,AI(n,e,t,s)}finally{xn=i,Ud.transition=r}}function Z6(n,e,t,s){var i=xn,r=Ud.transition;Ud.transition=null;try{xn=4,AI(n,e,t,s)}finally{xn=i,Ud.transition=r}}function AI(n,e,t,s){if(Gv){var i=h2(n,e,t,s);if(i===null)C_(n,e,s,Hv,t),AR(n,s);else if(q6(i,n,e,t,s))s.stopPropagation();else if(AR(n,s),e&4&&-1<j6.indexOf(n)){for(;i!==null;){var r=ug(i);if(r!==null&&R$(r),r=h2(n,e,t,s),r===null&&C_(n,e,s,Hv,t),r===i)break;i=r}i!==null&&s.stopPropagation()}else C_(n,e,s,null,t)}}var Hv=null;function h2(n,e,t,s){if(Hv=null,n=II(s),n=Cu(n),n!==null)if(e=vh(n),e===null)n=null;else if(t=e.tag,t===13){if(n=C$(e),n!==null)return n;n=null}else if(t===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;n=null}else e!==n&&(n=null);return Hv=n,null}function F$(n){switch(n){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(O6()){case EI:return 1;case M$:return 4;case Vv:case z6:return 16;case k$:return 536870912;default:return 16}default:return 16}}var Jl=null,NI=null,wv=null;function O$(){if(wv)return wv;var n,e=NI,t=e.length,s,i="value"in Jl?Jl.value:Jl.textContent,r=i.length;for(n=0;n<t&&e[n]===i[n];n++);var o=t-n;for(s=1;s<=o&&e[t-s]===i[r-s];s++);return wv=i.slice(n,1<s?1-s:void 0)}function bv(n){var e=n.keyCode;return"charCode"in n?(n=n.charCode,n===0&&e===13&&(n=13)):n=e,n===10&&(n=13),32<=n||n===13?n:0}function ty(){return!0}function RR(){return!1}function Dr(n){function e(t,s,i,r,o){this._reactName=t,this._targetInst=i,this.type=s,this.nativeEvent=r,this.target=o,this.currentTarget=null;for(var a in n)n.hasOwnProperty(a)&&(t=n[a],this[a]=t?t(r):r[a]);return this.isDefaultPrevented=(r.defaultPrevented!=null?r.defaultPrevented:r.returnValue===!1)?ty:RR,this.isPropagationStopped=RR,this}return qn(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var t=this.nativeEvent;t&&(t.preventDefault?t.preventDefault():typeof t.returnValue!="unknown"&&(t.returnValue=!1),this.isDefaultPrevented=ty)},stopPropagation:function(){var t=this.nativeEvent;t&&(t.stopPropagation?t.stopPropagation():typeof t.cancelBubble!="unknown"&&(t.cancelBubble=!0),this.isPropagationStopped=ty)},persist:function(){},isPersistent:ty}),e}var If={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},RI=Dr(If),cg=qn({},If,{view:0,detail:0}),J6=Dr(cg),m_,g_,bp,j1=qn({},cg,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:DI,button:0,buttons:0,relatedTarget:function(n){return n.relatedTarget===void 0?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==bp&&(bp&&n.type==="mousemove"?(m_=n.screenX-bp.screenX,g_=n.screenY-bp.screenY):g_=m_=0,bp=n),m_)},movementY:function(n){return"movementY"in n?n.movementY:g_}}),DR=Dr(j1),Q6=qn({},j1,{dataTransfer:0}),e8=Dr(Q6),t8=qn({},cg,{relatedTarget:0}),x_=Dr(t8),n8=qn({},If,{animationName:0,elapsedTime:0,pseudoElement:0}),s8=Dr(n8),i8=qn({},If,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}}),r8=Dr(i8),o8=qn({},If,{data:0}),LR=Dr(o8),a8={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},l8={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},c8={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function u8(n){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(n):(n=c8[n])?!!e[n]:!1}function DI(){return u8}var h8=qn({},cg,{key:function(n){if(n.key){var e=a8[n.key]||n.key;if(e!=="Unidentified")return e}return n.type==="keypress"?(n=bv(n),n===13?"Enter":String.fromCharCode(n)):n.type==="keydown"||n.type==="keyup"?l8[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:DI,charCode:function(n){return n.type==="keypress"?bv(n):0},keyCode:function(n){return n.type==="keydown"||n.type==="keyup"?n.keyCode:0},which:function(n){return n.type==="keypress"?bv(n):n.type==="keydown"||n.type==="keyup"?n.keyCode:0}}),d8=Dr(h8),f8=qn({},j1,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),PR=Dr(f8),p8=qn({},cg,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:DI}),m8=Dr(p8),g8=qn({},If,{propertyName:0,elapsedTime:0,pseudoElement:0}),x8=Dr(g8),y8=qn({},j1,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0}),v8=Dr(y8),w8=[9,13,27,32],LI=cl&&"CompositionEvent"in window,em=null;cl&&"documentMode"in document&&(em=document.documentMode);var b8=cl&&"TextEvent"in window&&!em,z$=cl&&(!LI||em&&8<em&&11>=em),$R=String.fromCharCode(32),FR=!1;function B$(n,e){switch(n){case"keyup":return w8.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function U$(n){return n=n.detail,typeof n=="object"&&"data"in n?n.data:null}var Sd=!1;function S8(n,e){switch(n){case"compositionend":return U$(e);case"keypress":return e.which!==32?null:(FR=!0,$R);case"textInput":return n=e.data,n===$R&&FR?null:n;default:return null}}function _8(n,e){if(Sd)return n==="compositionend"||!LI&&B$(n,e)?(n=O$(),wv=NI=Jl=null,Sd=!1,n):null;switch(n){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return z$&&e.locale!=="ko"?null:e.data;default:return null}}var C8={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function OR(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e==="input"?!!C8[n.type]:e==="textarea"}function V$(n,e,t,s){v$(s),e=Xv(e,"onChange"),0<e.length&&(t=new RI("onChange","change",null,t,s),n.push({event:t,listeners:e}))}var tm=null,wm=null;function T8(n){Q$(n,0)}function q1(n){var e=Td(n);if(d$(e))return n}function I8(n,e){if(n==="change")return e}var W$=!1;if(cl){var y_;if(cl){var v_="oninput"in document;if(!v_){var zR=document.createElement("div");zR.setAttribute("oninput","return;"),v_=typeof zR.oninput=="function"}y_=v_}else y_=!1;W$=y_&&(!document.documentMode||9<document.documentMode)}function BR(){tm&&(tm.detachEvent("onpropertychange",G$),wm=tm=null)}function G$(n){if(n.propertyName==="value"&&q1(wm)){var e=[];V$(e,wm,n,II(n)),_$(T8,e)}}function E8(n,e,t){n==="focusin"?(BR(),tm=e,wm=t,tm.attachEvent("onpropertychange",G$)):n==="focusout"&&BR()}function M8(n){if(n==="selectionchange"||n==="keyup"||n==="keydown")return q1(wm)}function k8(n,e){if(n==="click")return q1(e)}function A8(n,e){if(n==="input"||n==="change")return q1(e)}function N8(n,e){return n===e&&(n!==0||1/n===1/e)||n!==n&&e!==e}var Vo=typeof Object.is=="function"?Object.is:N8;function bm(n,e){if(Vo(n,e))return!0;if(typeof n!="object"||n===null||typeof e!="object"||e===null)return!1;var t=Object.keys(n),s=Object.keys(e);if(t.length!==s.length)return!1;for(s=0;s<t.length;s++){var i=t[s];if(!jC.call(e,i)||!Vo(n[i],e[i]))return!1}return!0}function UR(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function VR(n,e){var t=UR(n);n=0;for(var s;t;){if(t.nodeType===3){if(s=n+t.textContent.length,n<=e&&s>=e)return{node:t,offset:e-n};n=s}e:{for(;t;){if(t.nextSibling){t=t.nextSibling;break e}t=t.parentNode}t=void 0}t=UR(t)}}function H$(n,e){return n&&e?n===e?!0:n&&n.nodeType===3?!1:e&&e.nodeType===3?H$(n,e.parentNode):"contains"in n?n.contains(e):n.compareDocumentPosition?!!(n.compareDocumentPosition(e)&16):!1:!1}function X$(){for(var n=window,e=zv();e instanceof n.HTMLIFrameElement;){try{var t=typeof e.contentWindow.location.href=="string"}catch{t=!1}if(t)n=e.contentWindow;else break;e=zv(n.document)}return e}function PI(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e&&(e==="input"&&(n.type==="text"||n.type==="search"||n.type==="tel"||n.type==="url"||n.type==="password")||e==="textarea"||n.contentEditable==="true")}function R8(n){var e=X$(),t=n.focusedElem,s=n.selectionRange;if(e!==t&&t&&t.ownerDocument&&H$(t.ownerDocument.documentElement,t)){if(s!==null&&PI(t)){if(e=s.start,n=s.end,n===void 0&&(n=e),"selectionStart"in t)t.selectionStart=e,t.selectionEnd=Math.min(n,t.value.length);else if(n=(e=t.ownerDocument||document)&&e.defaultView||window,n.getSelection){n=n.getSelection();var i=t.textContent.length,r=Math.min(s.start,i);s=s.end===void 0?r:Math.min(s.end,i),!n.extend&&r>s&&(i=s,s=r,r=i),i=VR(t,r);var o=VR(t,s);i&&o&&(n.rangeCount!==1||n.anchorNode!==i.node||n.anchorOffset!==i.offset||n.focusNode!==o.node||n.focusOffset!==o.offset)&&(e=e.createRange(),e.setStart(i.node,i.offset),n.removeAllRanges(),r>s?(n.addRange(e),n.extend(o.node,o.offset)):(e.setEnd(o.node,o.offset),n.addRange(e)))}}for(e=[],n=t;n=n.parentNode;)n.nodeType===1&&e.push({element:n,left:n.scrollLeft,top:n.scrollTop});for(typeof t.focus=="function"&&t.focus(),t=0;t<e.length;t++)n=e[t],n.element.scrollLeft=n.left,n.element.scrollTop=n.top}}var D8=cl&&"documentMode"in document&&11>=document.documentMode,_d=null,d2=null,nm=null,f2=!1;function WR(n,e,t){var s=t.window===t?t.document:t.nodeType===9?t:t.ownerDocument;f2||_d==null||_d!==zv(s)||(s=_d,"selectionStart"in s&&PI(s)?s={start:s.selectionStart,end:s.selectionEnd}:(s=(s.ownerDocument&&s.ownerDocument.defaultView||window).getSelection(),s={anchorNode:s.anchorNode,anchorOffset:s.anchorOffset,focusNode:s.focusNode,focusOffset:s.focusOffset}),nm&&bm(nm,s)||(nm=s,s=Xv(d2,"onSelect"),0<s.length&&(e=new RI("onSelect","select",null,e,t),n.push({event:e,listeners:s}),e.target=_d)))}function ny(n,e){var t={};return t[n.toLowerCase()]=e.toLowerCase(),t["Webkit"+n]="webkit"+e,t["Moz"+n]="moz"+e,t}var Cd={animationend:ny("Animation","AnimationEnd"),animationiteration:ny("Animation","AnimationIteration"),animationstart:ny("Animation","AnimationStart"),transitionend:ny("Transition","TransitionEnd")},w_={},j$={};cl&&(j$=document.createElement("div").style,"AnimationEvent"in window||(delete Cd.animationend.animation,delete Cd.animationiteration.animation,delete Cd.animationstart.animation),"TransitionEvent"in window||delete Cd.transitionend.transition);function K1(n){if(w_[n])return w_[n];if(!Cd[n])return n;var e=Cd[n],t;for(t in e)if(e.hasOwnProperty(t)&&t in j$)return w_[n]=e[t];return n}var q$=K1("animationend"),K$=K1("animationiteration"),Y$=K1("animationstart"),Z$=K1("transitionend"),J$=new Map,GR="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Nc(n,e){J$.set(n,e),yh(e,[n])}for(var b_=0;b_<GR.length;b_++){var S_=GR[b_],L8=S_.toLowerCase(),P8=S_[0].toUpperCase()+S_.slice(1);Nc(L8,"on"+P8)}Nc(q$,"onAnimationEnd");Nc(K$,"onAnimationIteration");Nc(Y$,"onAnimationStart");Nc("dblclick","onDoubleClick");Nc("focusin","onFocus");Nc("focusout","onBlur");Nc(Z$,"onTransitionEnd");Yd("onMouseEnter",["mouseout","mouseover"]);Yd("onMouseLeave",["mouseout","mouseover"]);Yd("onPointerEnter",["pointerout","pointerover"]);Yd("onPointerLeave",["pointerout","pointerover"]);yh("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));yh("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));yh("onBeforeInput",["compositionend","keypress","textInput","paste"]);yh("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));yh("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));yh("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Wp="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),$8=new Set("cancel close invalid load scroll toggle".split(" ").concat(Wp));function HR(n,e,t){var s=n.type||"unknown-event";n.currentTarget=t,L6(s,e,void 0,n),n.currentTarget=null}function Q$(n,e){e=(e&4)!==0;for(var t=0;t<n.length;t++){var s=n[t],i=s.event;s=s.listeners;e:{var r=void 0;if(e)for(var o=s.length-1;0<=o;o--){var a=s[o],l=a.instance,c=a.currentTarget;if(a=a.listener,l!==r&&i.isPropagationStopped())break e;HR(i,a,c),r=l}else for(o=0;o<s.length;o++){if(a=s[o],l=a.instance,c=a.currentTarget,a=a.listener,l!==r&&i.isPropagationStopped())break e;HR(i,a,c),r=l}}}if(Uv)throw n=l2,Uv=!1,l2=null,n}function Ln(n,e){var t=e[y2];t===void 0&&(t=e[y2]=new Set);var s=n+"__bubble";t.has(s)||(eF(e,n,2,!1),t.add(s))}function __(n,e,t){var s=0;e&&(s|=4),eF(t,n,s,e)}var sy="_reactListening"+Math.random().toString(36).slice(2);function Sm(n){if(!n[sy]){n[sy]=!0,a$.forEach(function(t){t!=="selectionchange"&&($8.has(t)||__(t,!1,n),__(t,!0,n))});var e=n.nodeType===9?n:n.ownerDocument;e===null||e[sy]||(e[sy]=!0,__("selectionchange",!1,e))}}function eF(n,e,t,s){switch(F$(e)){case 1:var i=Y6;break;case 4:i=Z6;break;default:i=AI}t=i.bind(null,e,t,n),i=void 0,!a2||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(i=!0),s?i!==void 0?n.addEventListener(e,t,{capture:!0,passive:i}):n.addEventListener(e,t,!0):i!==void 0?n.addEventListener(e,t,{passive:i}):n.addEventListener(e,t,!1)}function C_(n,e,t,s,i){var r=s;if((e&1)===0&&(e&2)===0&&s!==null)e:for(;;){if(s===null)return;var o=s.tag;if(o===3||o===4){var a=s.stateNode.containerInfo;if(a===i||a.nodeType===8&&a.parentNode===i)break;if(o===4)for(o=s.return;o!==null;){var l=o.tag;if((l===3||l===4)&&(l=o.stateNode.containerInfo,l===i||l.nodeType===8&&l.parentNode===i))return;o=o.return}for(;a!==null;){if(o=Cu(a),o===null)return;if(l=o.tag,l===5||l===6){s=r=o;continue e}a=a.parentNode}}s=s.return}_$(function(){var c=r,u=II(t),h=[];e:{var d=J$.get(n);if(d!==void 0){var f=RI,m=n;switch(n){case"keypress":if(bv(t)===0)break e;case"keydown":case"keyup":f=d8;break;case"focusin":m="focus",f=x_;break;case"focusout":m="blur",f=x_;break;case"beforeblur":case"afterblur":f=x_;break;case"click":if(t.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":f=DR;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":f=e8;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":f=m8;break;case q$:case K$:case Y$:f=s8;break;case Z$:f=x8;break;case"scroll":f=J6;break;case"wheel":f=v8;break;case"copy":case"cut":case"paste":f=r8;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":f=PR}var x=(e&4)!==0,y=!x&&n==="scroll",v=x?d!==null?d+"Capture":null:d;x=[];for(var w=c,b;w!==null;){b=w;var S=b.stateNode;if(b.tag===5&&S!==null&&(b=S,v!==null&&(S=gm(w,v),S!=null&&x.push(_m(w,S,b)))),y)break;w=w.return}0<x.length&&(d=new f(d,m,null,t,u),h.push({event:d,listeners:x}))}}if((e&7)===0){e:{if(d=n==="mouseover"||n==="pointerover",f=n==="mouseout"||n==="pointerout",d&&t!==r2&&(m=t.relatedTarget||t.fromElement)&&(Cu(m)||m[ul]))break e;if((f||d)&&(d=u.window===u?u:(d=u.ownerDocument)?d.defaultView||d.parentWindow:window,f?(m=t.relatedTarget||t.toElement,f=c,m=m?Cu(m):null,m!==null&&(y=vh(m),m!==y||m.tag!==5&&m.tag!==6)&&(m=null)):(f=null,m=c),f!==m)){if(x=DR,S="onMouseLeave",v="onMouseEnter",w="mouse",(n==="pointerout"||n==="pointerover")&&(x=PR,S="onPointerLeave",v="onPointerEnter",w="pointer"),y=f==null?d:Td(f),b=m==null?d:Td(m),d=new x(S,w+"leave",f,t,u),d.target=y,d.relatedTarget=b,S=null,Cu(u)===c&&(x=new x(v,w+"enter",m,t,u),x.target=b,x.relatedTarget=y,S=x),y=S,f&&m)t:{for(x=f,v=m,w=0,b=x;b;b=Kh(b))w++;for(b=0,S=v;S;S=Kh(S))b++;for(;0<w-b;)x=Kh(x),w--;for(;0<b-w;)v=Kh(v),b--;for(;w--;){if(x===v||v!==null&&x===v.alternate)break t;x=Kh(x),v=Kh(v)}x=null}else x=null;f!==null&&XR(h,d,f,x,!1),m!==null&&y!==null&&XR(h,y,m,x,!0)}}e:{if(d=c?Td(c):window,f=d.nodeName&&d.nodeName.toLowerCase(),f==="select"||f==="input"&&d.type==="file")var C=I8;else if(OR(d))if(W$)C=A8;else{C=M8;var E=E8}else(f=d.nodeName)&&f.toLowerCase()==="input"&&(d.type==="checkbox"||d.type==="radio")&&(C=k8);if(C&&(C=C(n,c))){V$(h,C,t,u);break e}E&&E(n,d,c),n==="focusout"&&(E=d._wrapperState)&&E.controlled&&d.type==="number"&&e2(d,"number",d.value)}switch(E=c?Td(c):window,n){case"focusin":(OR(E)||E.contentEditable==="true")&&(_d=E,d2=c,nm=null);break;case"focusout":nm=d2=_d=null;break;case"mousedown":f2=!0;break;case"contextmenu":case"mouseup":case"dragend":f2=!1,WR(h,t,u);break;case"selectionchange":if(D8)break;case"keydown":case"keyup":WR(h,t,u)}var k;if(LI)e:{switch(n){case"compositionstart":var I="onCompositionStart";break e;case"compositionend":I="onCompositionEnd";break e;case"compositionupdate":I="onCompositionUpdate";break e}I=void 0}else Sd?B$(n,t)&&(I="onCompositionEnd"):n==="keydown"&&t.keyCode===229&&(I="onCompositionStart");I&&(z$&&t.locale!=="ko"&&(Sd||I!=="onCompositionStart"?I==="onCompositionEnd"&&Sd&&(k=O$()):(Jl=u,NI="value"in Jl?Jl.value:Jl.textContent,Sd=!0)),E=Xv(c,I),0<E.length&&(I=new LR(I,n,null,t,u),h.push({event:I,listeners:E}),k?I.data=k:(k=U$(t),k!==null&&(I.data=k)))),(k=b8?S8(n,t):_8(n,t))&&(c=Xv(c,"onBeforeInput"),0<c.length&&(u=new LR("onBeforeInput","beforeinput",null,t,u),h.push({event:u,listeners:c}),u.data=k))}Q$(h,e)})}function _m(n,e,t){return{instance:n,listener:e,currentTarget:t}}function Xv(n,e){for(var t=e+"Capture",s=[];n!==null;){var i=n,r=i.stateNode;i.tag===5&&r!==null&&(i=r,r=gm(n,t),r!=null&&s.unshift(_m(n,r,i)),r=gm(n,e),r!=null&&s.push(_m(n,r,i))),n=n.return}return s}function Kh(n){if(n===null)return null;do n=n.return;while(n&&n.tag!==5);return n||null}function XR(n,e,t,s,i){for(var r=e._reactName,o=[];t!==null&&t!==s;){var a=t,l=a.alternate,c=a.stateNode;if(l!==null&&l===s)break;a.tag===5&&c!==null&&(a=c,i?(l=gm(t,r),l!=null&&o.unshift(_m(t,l,a))):i||(l=gm(t,r),l!=null&&o.push(_m(t,l,a)))),t=t.return}o.length!==0&&n.push({event:e,listeners:o})}var F8=/\r\n?/g,O8=/\u0000|\uFFFD/g;function jR(n){return(typeof n=="string"?n:""+n).replace(F8,`
`).replace(O8,"")}function iy(n,e,t){if(e=jR(e),jR(n)!==e&&t)throw Error(Ve(425))}function jv(){}var p2=null,m2=null;function g2(n,e){return n==="textarea"||n==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var x2=typeof setTimeout=="function"?setTimeout:void 0,z8=typeof clearTimeout=="function"?clearTimeout:void 0,qR=typeof Promise=="function"?Promise:void 0,B8=typeof queueMicrotask=="function"?queueMicrotask:typeof qR<"u"?function(n){return qR.resolve(null).then(n).catch(U8)}:x2;function U8(n){setTimeout(function(){throw n})}function T_(n,e){var t=e,s=0;do{var i=t.nextSibling;if(n.removeChild(t),i&&i.nodeType===8)if(t=i.data,t==="/$"){if(s===0){n.removeChild(i),vm(e);return}s--}else t!=="$"&&t!=="$?"&&t!=="$!"||s++;t=i}while(t);vm(e)}function ac(n){for(;n!=null;n=n.nextSibling){var e=n.nodeType;if(e===1||e===3)break;if(e===8){if(e=n.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return n}function KR(n){n=n.previousSibling;for(var e=0;n;){if(n.nodeType===8){var t=n.data;if(t==="$"||t==="$!"||t==="$?"){if(e===0)return n;e--}else t==="/$"&&e++}n=n.previousSibling}return null}var Ef=Math.random().toString(36).slice(2),ma="__reactFiber$"+Ef,Cm="__reactProps$"+Ef,ul="__reactContainer$"+Ef,y2="__reactEvents$"+Ef,V8="__reactListeners$"+Ef,W8="__reactHandles$"+Ef;function Cu(n){var e=n[ma];if(e)return e;for(var t=n.parentNode;t;){if(e=t[ul]||t[ma]){if(t=e.alternate,e.child!==null||t!==null&&t.child!==null)for(n=KR(n);n!==null;){if(t=n[ma])return t;n=KR(n)}return e}n=t,t=n.parentNode}return null}function ug(n){return n=n[ma]||n[ul],!n||n.tag!==5&&n.tag!==6&&n.tag!==13&&n.tag!==3?null:n}function Td(n){if(n.tag===5||n.tag===6)return n.stateNode;throw Error(Ve(33))}function Y1(n){return n[Cm]||null}var v2=[],Id=-1;function Rc(n){return{current:n}}function Pn(n){0>Id||(n.current=v2[Id],v2[Id]=null,Id--)}function kn(n,e){Id++,v2[Id]=n.current,n.current=e}var vc={},Ci=Rc(vc),rr=Rc(!1),qu=vc;function Zd(n,e){var t=n.type.contextTypes;if(!t)return vc;var s=n.stateNode;if(s&&s.__reactInternalMemoizedUnmaskedChildContext===e)return s.__reactInternalMemoizedMaskedChildContext;var i={},r;for(r in t)i[r]=e[r];return s&&(n=n.stateNode,n.__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=i),i}function or(n){return n=n.childContextTypes,n!=null}function qv(){Pn(rr),Pn(Ci)}function YR(n,e,t){if(Ci.current!==vc)throw Error(Ve(168));kn(Ci,e),kn(rr,t)}function tF(n,e,t){var s=n.stateNode;if(e=e.childContextTypes,typeof s.getChildContext!="function")return t;s=s.getChildContext();for(var i in s)if(!(i in e))throw Error(Ve(108,E6(n)||"Unknown",i));return qn({},t,s)}function Kv(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||vc,qu=Ci.current,kn(Ci,n),kn(rr,rr.current),!0}function ZR(n,e,t){var s=n.stateNode;if(!s)throw Error(Ve(169));t?(n=tF(n,e,qu),s.__reactInternalMemoizedMergedChildContext=n,Pn(rr),Pn(Ci),kn(Ci,n)):Pn(rr),kn(rr,t)}var Za=null,Z1=!1,I_=!1;function nF(n){Za===null?Za=[n]:Za.push(n)}function G8(n){Z1=!0,nF(n)}function Dc(){if(!I_&&Za!==null){I_=!0;var n=0,e=xn;try{var t=Za;for(xn=1;n<t.length;n++){var s=t[n];do s=s(!0);while(s!==null)}Za=null,Z1=!1}catch(i){throw Za!==null&&(Za=Za.slice(n+1)),E$(EI,Dc),i}finally{xn=e,I_=!1}}return null}var Ed=[],Md=0,Yv=null,Zv=0,eo=[],to=0,Ku=null,tl=1,nl="";function du(n,e){Ed[Md++]=Zv,Ed[Md++]=Yv,Yv=n,Zv=e}function sF(n,e,t){eo[to++]=tl,eo[to++]=nl,eo[to++]=Ku,Ku=n;var s=tl;n=nl;var i=32-$o(s)-1;s&=~(1<<i),t+=1;var r=32-$o(e)+i;if(30<r){var o=i-i%5;r=(s&(1<<o)-1).toString(32),s>>=o,i-=o,tl=1<<32-$o(e)+i|t<<i|s,nl=r+n}else tl=1<<r|t<<i|s,nl=n}function $I(n){n.return!==null&&(du(n,1),sF(n,1,0))}function FI(n){for(;n===Yv;)Yv=Ed[--Md],Ed[Md]=null,Zv=Ed[--Md],Ed[Md]=null;for(;n===Ku;)Ku=eo[--to],eo[to]=null,nl=eo[--to],eo[to]=null,tl=eo[--to],eo[to]=null}var Tr=null,Sr=null,Bn=!1,Ro=null;function iF(n,e){var t=io(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,e=n.deletions,e===null?(n.deletions=[t],n.flags|=16):e.push(t)}function JR(n,e){switch(n.tag){case 5:var t=n.type;return e=e.nodeType!==1||t.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(n.stateNode=e,Tr=n,Sr=ac(e.firstChild),!0):!1;case 6:return e=n.pendingProps===""||e.nodeType!==3?null:e,e!==null?(n.stateNode=e,Tr=n,Sr=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(t=Ku!==null?{id:tl,overflow:nl}:null,n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},t=io(18,null,null,0),t.stateNode=e,t.return=n,n.child=t,Tr=n,Sr=null,!0):!1;default:return!1}}function w2(n){return(n.mode&1)!==0&&(n.flags&128)===0}function b2(n){if(Bn){var e=Sr;if(e){var t=e;if(!JR(n,e)){if(w2(n))throw Error(Ve(418));e=ac(t.nextSibling);var s=Tr;e&&JR(n,e)?iF(s,t):(n.flags=n.flags&-4097|2,Bn=!1,Tr=n)}}else{if(w2(n))throw Error(Ve(418));n.flags=n.flags&-4097|2,Bn=!1,Tr=n}}}function QR(n){for(n=n.return;n!==null&&n.tag!==5&&n.tag!==3&&n.tag!==13;)n=n.return;Tr=n}function ry(n){if(n!==Tr)return!1;if(!Bn)return QR(n),Bn=!0,!1;var e;if((e=n.tag!==3)&&!(e=n.tag!==5)&&(e=n.type,e=e!=="head"&&e!=="body"&&!g2(n.type,n.memoizedProps)),e&&(e=Sr)){if(w2(n))throw rF(),Error(Ve(418));for(;e;)iF(n,e),e=ac(e.nextSibling)}if(QR(n),n.tag===13){if(n=n.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(Ve(317));e:{for(n=n.nextSibling,e=0;n;){if(n.nodeType===8){var t=n.data;if(t==="/$"){if(e===0){Sr=ac(n.nextSibling);break e}e--}else t!=="$"&&t!=="$!"&&t!=="$?"||e++}n=n.nextSibling}Sr=null}}else Sr=Tr?ac(n.stateNode.nextSibling):null;return!0}function rF(){for(var n=Sr;n;)n=ac(n.nextSibling)}function Jd(){Sr=Tr=null,Bn=!1}function OI(n){Ro===null?Ro=[n]:Ro.push(n)}var H8=yl.ReactCurrentBatchConfig;function ko(n,e){if(n&&n.defaultProps){e=qn({},e),n=n.defaultProps;for(var t in n)e[t]===void 0&&(e[t]=n[t]);return e}return e}var Jv=Rc(null),Qv=null,kd=null,zI=null;function BI(){zI=kd=Qv=null}function UI(n){var e=Jv.current;Pn(Jv),n._currentValue=e}function S2(n,e,t){for(;n!==null;){var s=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,s!==null&&(s.childLanes|=e)):s!==null&&(s.childLanes&e)!==e&&(s.childLanes|=e),n===t)break;n=n.return}}function Vd(n,e){Qv=n,zI=kd=null,n=n.dependencies,n!==null&&n.firstContext!==null&&((n.lanes&e)!==0&&(sr=!0),n.firstContext=null)}function ho(n){var e=n._currentValue;if(zI!==n)if(n={context:n,memoizedValue:e,next:null},kd===null){if(Qv===null)throw Error(Ve(308));kd=n,Qv.dependencies={lanes:0,firstContext:n}}else kd=kd.next=n;return e}var Tu=null;function VI(n){Tu===null?Tu=[n]:Tu.push(n)}function oF(n,e,t,s){var i=e.interleaved;return i===null?(t.next=t,VI(e)):(t.next=i.next,i.next=t),e.interleaved=t,hl(n,s)}function hl(n,e){n.lanes|=e;var t=n.alternate;for(t!==null&&(t.lanes|=e),t=n,n=n.return;n!==null;)n.childLanes|=e,t=n.alternate,t!==null&&(t.childLanes|=e),t=n,n=n.return;return t.tag===3?t.stateNode:null}var Xl=!1;function WI(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function aF(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function ol(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function lc(n,e,t){var s=n.updateQueue;if(s===null)return null;if(s=s.shared,(on&2)!==0){var i=s.pending;return i===null?e.next=e:(e.next=i.next,i.next=e),s.pending=e,hl(n,t)}return i=s.interleaved,i===null?(e.next=e,VI(s)):(e.next=i.next,i.next=e),s.interleaved=e,hl(n,t)}function Sv(n,e,t){if(e=e.updateQueue,e!==null&&(e=e.shared,(t&4194240)!==0)){var s=e.lanes;s&=n.pendingLanes,t|=s,e.lanes=t,MI(n,t)}}function e3(n,e){var t=n.updateQueue,s=n.alternate;if(s!==null&&(s=s.updateQueue,t===s)){var i=null,r=null;if(t=t.firstBaseUpdate,t!==null){do{var o={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};r===null?i=r=o:r=r.next=o,t=t.next}while(t!==null);r===null?i=r=e:r=r.next=e}else i=r=e;t={baseState:s.baseState,firstBaseUpdate:i,lastBaseUpdate:r,shared:s.shared,effects:s.effects},n.updateQueue=t;return}n=t.lastBaseUpdate,n===null?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function e1(n,e,t,s){var i=n.updateQueue;Xl=!1;var r=i.firstBaseUpdate,o=i.lastBaseUpdate,a=i.shared.pending;if(a!==null){i.shared.pending=null;var l=a,c=l.next;l.next=null,o===null?r=c:o.next=c,o=l;var u=n.alternate;u!==null&&(u=u.updateQueue,a=u.lastBaseUpdate,a!==o&&(a===null?u.firstBaseUpdate=c:a.next=c,u.lastBaseUpdate=l))}if(r!==null){var h=i.baseState;o=0,u=c=l=null,a=r;do{var d=a.lane,f=a.eventTime;if((s&d)===d){u!==null&&(u=u.next={eventTime:f,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});e:{var m=n,x=a;switch(d=e,f=t,x.tag){case 1:if(m=x.payload,typeof m=="function"){h=m.call(f,h,d);break e}h=m;break e;case 3:m.flags=m.flags&-65537|128;case 0:if(m=x.payload,d=typeof m=="function"?m.call(f,h,d):m,d==null)break e;h=qn({},h,d);break e;case 2:Xl=!0}}a.callback!==null&&a.lane!==0&&(n.flags|=64,d=i.effects,d===null?i.effects=[a]:d.push(a))}else f={eventTime:f,lane:d,tag:a.tag,payload:a.payload,callback:a.callback,next:null},u===null?(c=u=f,l=h):u=u.next=f,o|=d;if(a=a.next,a===null){if(a=i.shared.pending,a===null)break;d=a,a=d.next,d.next=null,i.lastBaseUpdate=d,i.shared.pending=null}}while(1);if(u===null&&(l=h),i.baseState=l,i.firstBaseUpdate=c,i.lastBaseUpdate=u,e=i.shared.interleaved,e!==null){i=e;do o|=i.lane,i=i.next;while(i!==e)}else r===null&&(i.shared.lanes=0);Zu|=o,n.lanes=o,n.memoizedState=h}}function t3(n,e,t){if(n=e.effects,e.effects=null,n!==null)for(e=0;e<n.length;e++){var s=n[e],i=s.callback;if(i!==null){if(s.callback=null,s=t,typeof i!="function")throw Error(Ve(191,i));i.call(s)}}}var lF=new o$.Component().refs;function _2(n,e,t,s){e=n.memoizedState,t=t(s,e),t=t==null?e:qn({},e,t),n.memoizedState=t,n.lanes===0&&(n.updateQueue.baseState=t)}var J1={isMounted:function(n){return(n=n._reactInternals)?vh(n)===n:!1},enqueueSetState:function(n,e,t){n=n._reactInternals;var s=Bi(),i=uc(n),r=ol(s,i);r.payload=e,t!=null&&(r.callback=t),e=lc(n,r,i),e!==null&&(Fo(e,n,i,s),Sv(e,n,i))},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var s=Bi(),i=uc(n),r=ol(s,i);r.tag=1,r.payload=e,t!=null&&(r.callback=t),e=lc(n,r,i),e!==null&&(Fo(e,n,i,s),Sv(e,n,i))},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=Bi(),s=uc(n),i=ol(t,s);i.tag=2,e!=null&&(i.callback=e),e=lc(n,i,s),e!==null&&(Fo(e,n,s,t),Sv(e,n,s))}};function n3(n,e,t,s,i,r,o){return n=n.stateNode,typeof n.shouldComponentUpdate=="function"?n.shouldComponentUpdate(s,r,o):e.prototype&&e.prototype.isPureReactComponent?!bm(t,s)||!bm(i,r):!0}function cF(n,e,t){var s=!1,i=vc,r=e.contextType;return typeof r=="object"&&r!==null?r=ho(r):(i=or(e)?qu:Ci.current,s=e.contextTypes,r=(s=s!=null)?Zd(n,i):vc),e=new e(t,r),n.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=J1,n.stateNode=e,e._reactInternals=n,s&&(n=n.stateNode,n.__reactInternalMemoizedUnmaskedChildContext=i,n.__reactInternalMemoizedMaskedChildContext=r),e}function s3(n,e,t,s){n=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(t,s),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(t,s),e.state!==n&&J1.enqueueReplaceState(e,e.state,null)}function C2(n,e,t,s){var i=n.stateNode;i.props=t,i.state=n.memoizedState,i.refs=lF,WI(n);var r=e.contextType;typeof r=="object"&&r!==null?i.context=ho(r):(r=or(e)?qu:Ci.current,i.context=Zd(n,r)),i.state=n.memoizedState,r=e.getDerivedStateFromProps,typeof r=="function"&&(_2(n,e,r,t),i.state=n.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof i.getSnapshotBeforeUpdate=="function"||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(e=i.state,typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount(),e!==i.state&&J1.enqueueReplaceState(i,i.state,null),e1(n,t,i,s),i.state=n.memoizedState),typeof i.componentDidMount=="function"&&(n.flags|=4194308)}function Sp(n,e,t){if(n=t.ref,n!==null&&typeof n!="function"&&typeof n!="object"){if(t._owner){if(t=t._owner,t){if(t.tag!==1)throw Error(Ve(309));var s=t.stateNode}if(!s)throw Error(Ve(147,n));var i=s,r=""+n;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===r?e.ref:(e=function(o){var a=i.refs;a===lF&&(a=i.refs={}),o===null?delete a[r]:a[r]=o},e._stringRef=r,e)}if(typeof n!="string")throw Error(Ve(284));if(!t._owner)throw Error(Ve(290,n))}return n}function oy(n,e){throw n=Object.prototype.toString.call(e),Error(Ve(31,n==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function i3(n){var e=n._init;return e(n._payload)}function uF(n){function e(v,w){if(n){var b=v.deletions;b===null?(v.deletions=[w],v.flags|=16):b.push(w)}}function t(v,w){if(!n)return null;for(;w!==null;)e(v,w),w=w.sibling;return null}function s(v,w){for(v=new Map;w!==null;)w.key!==null?v.set(w.key,w):v.set(w.index,w),w=w.sibling;return v}function i(v,w){return v=hc(v,w),v.index=0,v.sibling=null,v}function r(v,w,b){return v.index=b,n?(b=v.alternate,b!==null?(b=b.index,b<w?(v.flags|=2,w):b):(v.flags|=2,w)):(v.flags|=1048576,w)}function o(v){return n&&v.alternate===null&&(v.flags|=2),v}function a(v,w,b,S){return w===null||w.tag!==6?(w=D_(b,v.mode,S),w.return=v,w):(w=i(w,b),w.return=v,w)}function l(v,w,b,S){var C=b.type;return C===bd?u(v,w,b.props.children,S,b.key):w!==null&&(w.elementType===C||typeof C=="object"&&C!==null&&C.$$typeof===Hl&&i3(C)===w.type)?(S=i(w,b.props),S.ref=Sp(v,w,b),S.return=v,S):(S=Mv(b.type,b.key,b.props,null,v.mode,S),S.ref=Sp(v,w,b),S.return=v,S)}function c(v,w,b,S){return w===null||w.tag!==4||w.stateNode.containerInfo!==b.containerInfo||w.stateNode.implementation!==b.implementation?(w=L_(b,v.mode,S),w.return=v,w):(w=i(w,b.children||[]),w.return=v,w)}function u(v,w,b,S,C){return w===null||w.tag!==7?(w=Fu(b,v.mode,S,C),w.return=v,w):(w=i(w,b),w.return=v,w)}function h(v,w,b){if(typeof w=="string"&&w!==""||typeof w=="number")return w=D_(""+w,v.mode,b),w.return=v,w;if(typeof w=="object"&&w!==null){switch(w.$$typeof){case Kx:return b=Mv(w.type,w.key,w.props,null,v.mode,b),b.ref=Sp(v,null,w),b.return=v,b;case wd:return w=L_(w,v.mode,b),w.return=v,w;case Hl:var S=w._init;return h(v,S(w._payload),b)}if(Up(w)||xp(w))return w=Fu(w,v.mode,b,null),w.return=v,w;oy(v,w)}return null}function d(v,w,b,S){var C=w!==null?w.key:null;if(typeof b=="string"&&b!==""||typeof b=="number")return C!==null?null:a(v,w,""+b,S);if(typeof b=="object"&&b!==null){switch(b.$$typeof){case Kx:return b.key===C?l(v,w,b,S):null;case wd:return b.key===C?c(v,w,b,S):null;case Hl:return C=b._init,d(v,w,C(b._payload),S)}if(Up(b)||xp(b))return C!==null?null:u(v,w,b,S,null);oy(v,b)}return null}function f(v,w,b,S,C){if(typeof S=="string"&&S!==""||typeof S=="number")return v=v.get(b)||null,a(w,v,""+S,C);if(typeof S=="object"&&S!==null){switch(S.$$typeof){case Kx:return v=v.get(S.key===null?b:S.key)||null,l(w,v,S,C);case wd:return v=v.get(S.key===null?b:S.key)||null,c(w,v,S,C);case Hl:var E=S._init;return f(v,w,b,E(S._payload),C)}if(Up(S)||xp(S))return v=v.get(b)||null,u(w,v,S,C,null);oy(w,S)}return null}function m(v,w,b,S){for(var C=null,E=null,k=w,I=w=0,A=null;k!==null&&I<b.length;I++){k.index>I?(A=k,k=null):A=k.sibling;var N=d(v,k,b[I],S);if(N===null){k===null&&(k=A);break}n&&k&&N.alternate===null&&e(v,k),w=r(N,w,I),E===null?C=N:E.sibling=N,E=N,k=A}if(I===b.length)return t(v,k),Bn&&du(v,I),C;if(k===null){for(;I<b.length;I++)k=h(v,b[I],S),k!==null&&(w=r(k,w,I),E===null?C=k:E.sibling=k,E=k);return Bn&&du(v,I),C}for(k=s(v,k);I<b.length;I++)A=f(k,v,I,b[I],S),A!==null&&(n&&A.alternate!==null&&k.delete(A.key===null?I:A.key),w=r(A,w,I),E===null?C=A:E.sibling=A,E=A);return n&&k.forEach(function(L){return e(v,L)}),Bn&&du(v,I),C}function x(v,w,b,S){var C=xp(b);if(typeof C!="function")throw Error(Ve(150));if(b=C.call(b),b==null)throw Error(Ve(151));for(var E=C=null,k=w,I=w=0,A=null,N=b.next();k!==null&&!N.done;I++,N=b.next()){k.index>I?(A=k,k=null):A=k.sibling;var L=d(v,k,N.value,S);if(L===null){k===null&&(k=A);break}n&&k&&L.alternate===null&&e(v,k),w=r(L,w,I),E===null?C=L:E.sibling=L,E=L,k=A}if(N.done)return t(v,k),Bn&&du(v,I),C;if(k===null){for(;!N.done;I++,N=b.next())N=h(v,N.value,S),N!==null&&(w=r(N,w,I),E===null?C=N:E.sibling=N,E=N);return Bn&&du(v,I),C}for(k=s(v,k);!N.done;I++,N=b.next())N=f(k,v,I,N.value,S),N!==null&&(n&&N.alternate!==null&&k.delete(N.key===null?I:N.key),w=r(N,w,I),E===null?C=N:E.sibling=N,E=N);return n&&k.forEach(function(V){return e(v,V)}),Bn&&du(v,I),C}function y(v,w,b,S){if(typeof b=="object"&&b!==null&&b.type===bd&&b.key===null&&(b=b.props.children),typeof b=="object"&&b!==null){switch(b.$$typeof){case Kx:e:{for(var C=b.key,E=w;E!==null;){if(E.key===C){if(C=b.type,C===bd){if(E.tag===7){t(v,E.sibling),w=i(E,b.props.children),w.return=v,v=w;break e}}else if(E.elementType===C||typeof C=="object"&&C!==null&&C.$$typeof===Hl&&i3(C)===E.type){t(v,E.sibling),w=i(E,b.props),w.ref=Sp(v,E,b),w.return=v,v=w;break e}t(v,E);break}else e(v,E);E=E.sibling}b.type===bd?(w=Fu(b.props.children,v.mode,S,b.key),w.return=v,v=w):(S=Mv(b.type,b.key,b.props,null,v.mode,S),S.ref=Sp(v,w,b),S.return=v,v=S)}return o(v);case wd:e:{for(E=b.key;w!==null;){if(w.key===E)if(w.tag===4&&w.stateNode.containerInfo===b.containerInfo&&w.stateNode.implementation===b.implementation){t(v,w.sibling),w=i(w,b.children||[]),w.return=v,v=w;break e}else{t(v,w);break}else e(v,w);w=w.sibling}w=L_(b,v.mode,S),w.return=v,v=w}return o(v);case Hl:return E=b._init,y(v,w,E(b._payload),S)}if(Up(b))return m(v,w,b,S);if(xp(b))return x(v,w,b,S);oy(v,b)}return typeof b=="string"&&b!==""||typeof b=="number"?(b=""+b,w!==null&&w.tag===6?(t(v,w.sibling),w=i(w,b),w.return=v,v=w):(t(v,w),w=D_(b,v.mode,S),w.return=v,v=w),o(v)):t(v,w)}return y}var Qd=uF(!0),hF=uF(!1),hg={},ba=Rc(hg),Tm=Rc(hg),Im=Rc(hg);function Iu(n){if(n===hg)throw Error(Ve(174));return n}function GI(n,e){switch(kn(Im,e),kn(Tm,n),kn(ba,hg),n=e.nodeType,n){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:n2(null,"");break;default:n=n===8?e.parentNode:e,e=n.namespaceURI||null,n=n.tagName,e=n2(e,n)}Pn(ba),kn(ba,e)}function ef(){Pn(ba),Pn(Tm),Pn(Im)}function dF(n){Iu(Im.current);var e=Iu(ba.current),t=n2(e,n.type);e!==t&&(kn(Tm,n),kn(ba,t))}function HI(n){Tm.current===n&&(Pn(ba),Pn(Tm))}var Hn=Rc(0);function t1(n){for(var e=n;e!==null;){if(e.tag===13){var t=e.memoizedState;if(t!==null&&(t=t.dehydrated,t===null||t.data==="$?"||t.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if((e.flags&128)!==0)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===n)break;for(;e.sibling===null;){if(e.return===null||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var E_=[];function XI(){for(var n=0;n<E_.length;n++)E_[n]._workInProgressVersionPrimary=null;E_.length=0}var _v=yl.ReactCurrentDispatcher,M_=yl.ReactCurrentBatchConfig,Yu=0,jn=null,As=null,Hs=null,n1=!1,sm=!1,Em=0,X8=0;function fi(){throw Error(Ve(321))}function jI(n,e){if(e===null)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!Vo(n[t],e[t]))return!1;return!0}function qI(n,e,t,s,i,r){if(Yu=r,jn=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,_v.current=n===null||n.memoizedState===null?Y8:Z8,n=t(s,i),sm){r=0;do{if(sm=!1,Em=0,25<=r)throw Error(Ve(301));r+=1,Hs=As=null,e.updateQueue=null,_v.current=J8,n=t(s,i)}while(sm)}if(_v.current=s1,e=As!==null&&As.next!==null,Yu=0,Hs=As=jn=null,n1=!1,e)throw Error(Ve(300));return n}function KI(){var n=Em!==0;return Em=0,n}function ca(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Hs===null?jn.memoizedState=Hs=n:Hs=Hs.next=n,Hs}function fo(){if(As===null){var n=jn.alternate;n=n!==null?n.memoizedState:null}else n=As.next;var e=Hs===null?jn.memoizedState:Hs.next;if(e!==null)Hs=e,As=n;else{if(n===null)throw Error(Ve(310));As=n,n={memoizedState:As.memoizedState,baseState:As.baseState,baseQueue:As.baseQueue,queue:As.queue,next:null},Hs===null?jn.memoizedState=Hs=n:Hs=Hs.next=n}return Hs}function Mm(n,e){return typeof e=="function"?e(n):e}function k_(n){var e=fo(),t=e.queue;if(t===null)throw Error(Ve(311));t.lastRenderedReducer=n;var s=As,i=s.baseQueue,r=t.pending;if(r!==null){if(i!==null){var o=i.next;i.next=r.next,r.next=o}s.baseQueue=i=r,t.pending=null}if(i!==null){r=i.next,s=s.baseState;var a=o=null,l=null,c=r;do{var u=c.lane;if((Yu&u)===u)l!==null&&(l=l.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),s=c.hasEagerState?c.eagerState:n(s,c.action);else{var h={lane:u,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};l===null?(a=l=h,o=s):l=l.next=h,jn.lanes|=u,Zu|=u}c=c.next}while(c!==null&&c!==r);l===null?o=s:l.next=a,Vo(s,e.memoizedState)||(sr=!0),e.memoizedState=s,e.baseState=o,e.baseQueue=l,t.lastRenderedState=s}if(n=t.interleaved,n!==null){i=n;do r=i.lane,jn.lanes|=r,Zu|=r,i=i.next;while(i!==n)}else i===null&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function A_(n){var e=fo(),t=e.queue;if(t===null)throw Error(Ve(311));t.lastRenderedReducer=n;var s=t.dispatch,i=t.pending,r=e.memoizedState;if(i!==null){t.pending=null;var o=i=i.next;do r=n(r,o.action),o=o.next;while(o!==i);Vo(r,e.memoizedState)||(sr=!0),e.memoizedState=r,e.baseQueue===null&&(e.baseState=r),t.lastRenderedState=r}return[r,s]}function fF(){}function pF(n,e){var t=jn,s=fo(),i=e(),r=!Vo(s.memoizedState,i);if(r&&(s.memoizedState=i,sr=!0),s=s.queue,YI(xF.bind(null,t,s,n),[n]),s.getSnapshot!==e||r||Hs!==null&&Hs.memoizedState.tag&1){if(t.flags|=2048,km(9,gF.bind(null,t,s,i,e),void 0,null),qs===null)throw Error(Ve(349));(Yu&30)!==0||mF(t,e,i)}return i}function mF(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},e=jn.updateQueue,e===null?(e={lastEffect:null,stores:null},jn.updateQueue=e,e.stores=[n]):(t=e.stores,t===null?e.stores=[n]:t.push(n))}function gF(n,e,t,s){e.value=t,e.getSnapshot=s,yF(e)&&vF(n)}function xF(n,e,t){return t(function(){yF(e)&&vF(n)})}function yF(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!Vo(n,t)}catch{return!0}}function vF(n){var e=hl(n,1);e!==null&&Fo(e,n,1,-1)}function r3(n){var e=ca();return typeof n=="function"&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Mm,lastRenderedState:n},e.queue=n,n=n.dispatch=K8.bind(null,jn,n),[e.memoizedState,n]}function km(n,e,t,s){return n={tag:n,create:e,destroy:t,deps:s,next:null},e=jn.updateQueue,e===null?(e={lastEffect:null,stores:null},jn.updateQueue=e,e.lastEffect=n.next=n):(t=e.lastEffect,t===null?e.lastEffect=n.next=n:(s=t.next,t.next=n,n.next=s,e.lastEffect=n)),n}function wF(){return fo().memoizedState}function Cv(n,e,t,s){var i=ca();jn.flags|=n,i.memoizedState=km(1|e,t,void 0,s===void 0?null:s)}function Q1(n,e,t,s){var i=fo();s=s===void 0?null:s;var r=void 0;if(As!==null){var o=As.memoizedState;if(r=o.destroy,s!==null&&jI(s,o.deps)){i.memoizedState=km(e,t,r,s);return}}jn.flags|=n,i.memoizedState=km(1|e,t,r,s)}function o3(n,e){return Cv(8390656,8,n,e)}function YI(n,e){return Q1(2048,8,n,e)}function bF(n,e){return Q1(4,2,n,e)}function SF(n,e){return Q1(4,4,n,e)}function _F(n,e){if(typeof e=="function")return n=n(),e(n),function(){e(null)};if(e!=null)return n=n(),e.current=n,function(){e.current=null}}function CF(n,e,t){return t=t!=null?t.concat([n]):null,Q1(4,4,_F.bind(null,e,n),t)}function ZI(){}function TF(n,e){var t=fo();e=e===void 0?null:e;var s=t.memoizedState;return s!==null&&e!==null&&jI(e,s[1])?s[0]:(t.memoizedState=[n,e],n)}function IF(n,e){var t=fo();e=e===void 0?null:e;var s=t.memoizedState;return s!==null&&e!==null&&jI(e,s[1])?s[0]:(n=n(),t.memoizedState=[n,e],n)}function EF(n,e,t){return(Yu&21)===0?(n.baseState&&(n.baseState=!1,sr=!0),n.memoizedState=t):(Vo(t,e)||(t=A$(),jn.lanes|=t,Zu|=t,n.baseState=!0),e)}function j8(n,e){var t=xn;xn=t!==0&&4>t?t:4,n(!0);var s=M_.transition;M_.transition={};try{n(!1),e()}finally{xn=t,M_.transition=s}}function MF(){return fo().memoizedState}function q8(n,e,t){var s=uc(n);if(t={lane:s,action:t,hasEagerState:!1,eagerState:null,next:null},kF(n))AF(e,t);else if(t=oF(n,e,t,s),t!==null){var i=Bi();Fo(t,n,s,i),NF(t,e,s)}}function K8(n,e,t){var s=uc(n),i={lane:s,action:t,hasEagerState:!1,eagerState:null,next:null};if(kF(n))AF(e,i);else{var r=n.alternate;if(n.lanes===0&&(r===null||r.lanes===0)&&(r=e.lastRenderedReducer,r!==null))try{var o=e.lastRenderedState,a=r(o,t);if(i.hasEagerState=!0,i.eagerState=a,Vo(a,o)){var l=e.interleaved;l===null?(i.next=i,VI(e)):(i.next=l.next,l.next=i),e.interleaved=i;return}}catch{}finally{}t=oF(n,e,i,s),t!==null&&(i=Bi(),Fo(t,n,s,i),NF(t,e,s))}}function kF(n){var e=n.alternate;return n===jn||e!==null&&e===jn}function AF(n,e){sm=n1=!0;var t=n.pending;t===null?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function NF(n,e,t){if((t&4194240)!==0){var s=e.lanes;s&=n.pendingLanes,t|=s,e.lanes=t,MI(n,t)}}var s1={readContext:ho,useCallback:fi,useContext:fi,useEffect:fi,useImperativeHandle:fi,useInsertionEffect:fi,useLayoutEffect:fi,useMemo:fi,useReducer:fi,useRef:fi,useState:fi,useDebugValue:fi,useDeferredValue:fi,useTransition:fi,useMutableSource:fi,useSyncExternalStore:fi,useId:fi,unstable_isNewReconciler:!1},Y8={readContext:ho,useCallback:function(n,e){return ca().memoizedState=[n,e===void 0?null:e],n},useContext:ho,useEffect:o3,useImperativeHandle:function(n,e,t){return t=t!=null?t.concat([n]):null,Cv(4194308,4,_F.bind(null,e,n),t)},useLayoutEffect:function(n,e){return Cv(4194308,4,n,e)},useInsertionEffect:function(n,e){return Cv(4,2,n,e)},useMemo:function(n,e){var t=ca();return e=e===void 0?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var s=ca();return e=t!==void 0?t(e):e,s.memoizedState=s.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},s.queue=n,n=n.dispatch=q8.bind(null,jn,n),[s.memoizedState,n]},useRef:function(n){var e=ca();return n={current:n},e.memoizedState=n},useState:r3,useDebugValue:ZI,useDeferredValue:function(n){return ca().memoizedState=n},useTransition:function(){var n=r3(!1),e=n[0];return n=j8.bind(null,n[1]),ca().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var s=jn,i=ca();if(Bn){if(t===void 0)throw Error(Ve(407));t=t()}else{if(t=e(),qs===null)throw Error(Ve(349));(Yu&30)!==0||mF(s,e,t)}i.memoizedState=t;var r={value:t,getSnapshot:e};return i.queue=r,o3(xF.bind(null,s,r,n),[n]),s.flags|=2048,km(9,gF.bind(null,s,r,t,e),void 0,null),t},useId:function(){var n=ca(),e=qs.identifierPrefix;if(Bn){var t=nl,s=tl;t=(s&~(1<<32-$o(s)-1)).toString(32)+t,e=":"+e+"R"+t,t=Em++,0<t&&(e+="H"+t.toString(32)),e+=":"}else t=X8++,e=":"+e+"r"+t.toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},Z8={readContext:ho,useCallback:TF,useContext:ho,useEffect:YI,useImperativeHandle:CF,useInsertionEffect:bF,useLayoutEffect:SF,useMemo:IF,useReducer:k_,useRef:wF,useState:function(){return k_(Mm)},useDebugValue:ZI,useDeferredValue:function(n){var e=fo();return EF(e,As.memoizedState,n)},useTransition:function(){var n=k_(Mm)[0],e=fo().memoizedState;return[n,e]},useMutableSource:fF,useSyncExternalStore:pF,useId:MF,unstable_isNewReconciler:!1},J8={readContext:ho,useCallback:TF,useContext:ho,useEffect:YI,useImperativeHandle:CF,useInsertionEffect:bF,useLayoutEffect:SF,useMemo:IF,useReducer:A_,useRef:wF,useState:function(){return A_(Mm)},useDebugValue:ZI,useDeferredValue:function(n){var e=fo();return As===null?e.memoizedState=n:EF(e,As.memoizedState,n)},useTransition:function(){var n=A_(Mm)[0],e=fo().memoizedState;return[n,e]},useMutableSource:fF,useSyncExternalStore:pF,useId:MF,unstable_isNewReconciler:!1};function tf(n,e){try{var t="",s=e;do t+=I6(s),s=s.return;while(s);var i=t}catch(r){i=`
Error generating stack: `+r.message+`
`+r.stack}return{value:n,source:e,stack:i,digest:null}}function N_(n,e,t){return{value:n,source:null,stack:t!=null?t:null,digest:e!=null?e:null}}function T2(n,e){try{console.error(e.value)}catch(t){setTimeout(function(){throw t})}}var Q8=typeof WeakMap=="function"?WeakMap:Map;function RF(n,e,t){t=ol(-1,t),t.tag=3,t.payload={element:null};var s=e.value;return t.callback=function(){r1||(r1=!0,P2=s),T2(n,e)},t}function DF(n,e,t){t=ol(-1,t),t.tag=3;var s=n.type.getDerivedStateFromError;if(typeof s=="function"){var i=e.value;t.payload=function(){return s(i)},t.callback=function(){T2(n,e)}}var r=n.stateNode;return r!==null&&typeof r.componentDidCatch=="function"&&(t.callback=function(){T2(n,e),typeof s!="function"&&(cc===null?cc=new Set([this]):cc.add(this));var o=e.stack;this.componentDidCatch(e.value,{componentStack:o!==null?o:""})}),t}function a3(n,e,t){var s=n.pingCache;if(s===null){s=n.pingCache=new Q8;var i=new Set;s.set(e,i)}else i=s.get(e),i===void 0&&(i=new Set,s.set(e,i));i.has(t)||(i.add(t),n=f7.bind(null,n,e,t),e.then(n,n))}function l3(n){do{var e;if((e=n.tag===13)&&(e=n.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return n;n=n.return}while(n!==null);return null}function c3(n,e,t,s,i){return(n.mode&1)===0?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,t.tag===1&&(t.alternate===null?t.tag=17:(e=ol(-1,1),e.tag=2,lc(t,e,1))),t.lanes|=1),n):(n.flags|=65536,n.lanes=i,n)}var e7=yl.ReactCurrentOwner,sr=!1;function Li(n,e,t,s){e.child=n===null?hF(e,null,t,s):Qd(e,n.child,t,s)}function u3(n,e,t,s,i){t=t.render;var r=e.ref;return Vd(e,i),s=qI(n,e,t,s,r,i),t=KI(),n!==null&&!sr?(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~i,dl(n,e,i)):(Bn&&t&&$I(e),e.flags|=1,Li(n,e,s,i),e.child)}function h3(n,e,t,s,i){if(n===null){var r=t.type;return typeof r=="function"&&!rE(r)&&r.defaultProps===void 0&&t.compare===null&&t.defaultProps===void 0?(e.tag=15,e.type=r,LF(n,e,r,s,i)):(n=Mv(t.type,null,s,e,e.mode,i),n.ref=e.ref,n.return=e,e.child=n)}if(r=n.child,(n.lanes&i)===0){var o=r.memoizedProps;if(t=t.compare,t=t!==null?t:bm,t(o,s)&&n.ref===e.ref)return dl(n,e,i)}return e.flags|=1,n=hc(r,s),n.ref=e.ref,n.return=e,e.child=n}function LF(n,e,t,s,i){if(n!==null){var r=n.memoizedProps;if(bm(r,s)&&n.ref===e.ref)if(sr=!1,e.pendingProps=s=r,(n.lanes&i)!==0)(n.flags&131072)!==0&&(sr=!0);else return e.lanes=n.lanes,dl(n,e,i)}return I2(n,e,t,s,i)}function PF(n,e,t){var s=e.pendingProps,i=s.children,r=n!==null?n.memoizedState:null;if(s.mode==="hidden")if((e.mode&1)===0)e.memoizedState={baseLanes:0,cachePool:null,transitions:null},kn(Nd,vr),vr|=t;else{if((t&1073741824)===0)return n=r!==null?r.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null,transitions:null},e.updateQueue=null,kn(Nd,vr),vr|=n,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},s=r!==null?r.baseLanes:t,kn(Nd,vr),vr|=s}else r!==null?(s=r.baseLanes|t,e.memoizedState=null):s=t,kn(Nd,vr),vr|=s;return Li(n,e,i,t),e.child}function $F(n,e){var t=e.ref;(n===null&&t!==null||n!==null&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function I2(n,e,t,s,i){var r=or(t)?qu:Ci.current;return r=Zd(e,r),Vd(e,i),t=qI(n,e,t,s,r,i),s=KI(),n!==null&&!sr?(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~i,dl(n,e,i)):(Bn&&s&&$I(e),e.flags|=1,Li(n,e,t,i),e.child)}function d3(n,e,t,s,i){if(or(t)){var r=!0;Kv(e)}else r=!1;if(Vd(e,i),e.stateNode===null)Tv(n,e),cF(e,t,s),C2(e,t,s,i),s=!0;else if(n===null){var o=e.stateNode,a=e.memoizedProps;o.props=a;var l=o.context,c=t.contextType;typeof c=="object"&&c!==null?c=ho(c):(c=or(t)?qu:Ci.current,c=Zd(e,c));var u=t.getDerivedStateFromProps,h=typeof u=="function"||typeof o.getSnapshotBeforeUpdate=="function";h||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==s||l!==c)&&s3(e,o,s,c),Xl=!1;var d=e.memoizedState;o.state=d,e1(e,s,o,i),l=e.memoizedState,a!==s||d!==l||rr.current||Xl?(typeof u=="function"&&(_2(e,t,u,s),l=e.memoizedState),(a=Xl||n3(e,t,a,s,d,l,c))?(h||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount()),typeof o.componentDidMount=="function"&&(e.flags|=4194308)):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=s,e.memoizedState=l),o.props=s,o.state=l,o.context=c,s=a):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),s=!1)}else{o=e.stateNode,aF(n,e),a=e.memoizedProps,c=e.type===e.elementType?a:ko(e.type,a),o.props=c,h=e.pendingProps,d=o.context,l=t.contextType,typeof l=="object"&&l!==null?l=ho(l):(l=or(t)?qu:Ci.current,l=Zd(e,l));var f=t.getDerivedStateFromProps;(u=typeof f=="function"||typeof o.getSnapshotBeforeUpdate=="function")||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==h||d!==l)&&s3(e,o,s,l),Xl=!1,d=e.memoizedState,o.state=d,e1(e,s,o,i);var m=e.memoizedState;a!==h||d!==m||rr.current||Xl?(typeof f=="function"&&(_2(e,t,f,s),m=e.memoizedState),(c=Xl||n3(e,t,c,s,d,m,l)||!1)?(u||typeof o.UNSAFE_componentWillUpdate!="function"&&typeof o.componentWillUpdate!="function"||(typeof o.componentWillUpdate=="function"&&o.componentWillUpdate(s,m,l),typeof o.UNSAFE_componentWillUpdate=="function"&&o.UNSAFE_componentWillUpdate(s,m,l)),typeof o.componentDidUpdate=="function"&&(e.flags|=4),typeof o.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof o.componentDidUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=1024),e.memoizedProps=s,e.memoizedState=m),o.props=s,o.state=m,o.context=l,s=c):(typeof o.componentDidUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=1024),s=!1)}return E2(n,e,t,s,r,i)}function E2(n,e,t,s,i,r){$F(n,e);var o=(e.flags&128)!==0;if(!s&&!o)return i&&ZR(e,t,!1),dl(n,e,r);s=e.stateNode,e7.current=e;var a=o&&typeof t.getDerivedStateFromError!="function"?null:s.render();return e.flags|=1,n!==null&&o?(e.child=Qd(e,n.child,null,r),e.child=Qd(e,null,a,r)):Li(n,e,a,r),e.memoizedState=s.state,i&&ZR(e,t,!0),e.child}function FF(n){var e=n.stateNode;e.pendingContext?YR(n,e.pendingContext,e.pendingContext!==e.context):e.context&&YR(n,e.context,!1),GI(n,e.containerInfo)}function f3(n,e,t,s,i){return Jd(),OI(i),e.flags|=256,Li(n,e,t,s),e.child}var M2={dehydrated:null,treeContext:null,retryLane:0};function k2(n){return{baseLanes:n,cachePool:null,transitions:null}}function OF(n,e,t){var s=e.pendingProps,i=Hn.current,r=!1,o=(e.flags&128)!==0,a;if((a=o)||(a=n!==null&&n.memoizedState===null?!1:(i&2)!==0),a?(r=!0,e.flags&=-129):(n===null||n.memoizedState!==null)&&(i|=1),kn(Hn,i&1),n===null)return b2(e),n=e.memoizedState,n!==null&&(n=n.dehydrated,n!==null)?((e.mode&1)===0?e.lanes=1:n.data==="$!"?e.lanes=8:e.lanes=1073741824,null):(o=s.children,n=s.fallback,r?(s=e.mode,r=e.child,o={mode:"hidden",children:o},(s&1)===0&&r!==null?(r.childLanes=0,r.pendingProps=o):r=nw(o,s,0,null),n=Fu(n,s,t,null),r.return=e,n.return=e,r.sibling=n,e.child=r,e.child.memoizedState=k2(t),e.memoizedState=M2,n):JI(e,o));if(i=n.memoizedState,i!==null&&(a=i.dehydrated,a!==null))return t7(n,e,o,s,a,i,t);if(r){r=s.fallback,o=e.mode,i=n.child,a=i.sibling;var l={mode:"hidden",children:s.children};return(o&1)===0&&e.child!==i?(s=e.child,s.childLanes=0,s.pendingProps=l,e.deletions=null):(s=hc(i,l),s.subtreeFlags=i.subtreeFlags&14680064),a!==null?r=hc(a,r):(r=Fu(r,o,t,null),r.flags|=2),r.return=e,s.return=e,s.sibling=r,e.child=s,s=r,r=e.child,o=n.child.memoizedState,o=o===null?k2(t):{baseLanes:o.baseLanes|t,cachePool:null,transitions:o.transitions},r.memoizedState=o,r.childLanes=n.childLanes&~t,e.memoizedState=M2,s}return r=n.child,n=r.sibling,s=hc(r,{mode:"visible",children:s.children}),(e.mode&1)===0&&(s.lanes=t),s.return=e,s.sibling=null,n!==null&&(t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)),e.child=s,e.memoizedState=null,s}function JI(n,e){return e=nw({mode:"visible",children:e},n.mode,0,null),e.return=n,n.child=e}function ay(n,e,t,s){return s!==null&&OI(s),Qd(e,n.child,null,t),n=JI(e,e.pendingProps.children),n.flags|=2,e.memoizedState=null,n}function t7(n,e,t,s,i,r,o){if(t)return e.flags&256?(e.flags&=-257,s=N_(Error(Ve(422))),ay(n,e,o,s)):e.memoizedState!==null?(e.child=n.child,e.flags|=128,null):(r=s.fallback,i=e.mode,s=nw({mode:"visible",children:s.children},i,0,null),r=Fu(r,i,o,null),r.flags|=2,s.return=e,r.return=e,s.sibling=r,e.child=s,(e.mode&1)!==0&&Qd(e,n.child,null,o),e.child.memoizedState=k2(o),e.memoizedState=M2,r);if((e.mode&1)===0)return ay(n,e,o,null);if(i.data==="$!"){if(s=i.nextSibling&&i.nextSibling.dataset,s)var a=s.dgst;return s=a,r=Error(Ve(419)),s=N_(r,s,void 0),ay(n,e,o,s)}if(a=(o&n.childLanes)!==0,sr||a){if(s=qs,s!==null){switch(o&-o){case 4:i=2;break;case 16:i=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:i=32;break;case 536870912:i=268435456;break;default:i=0}i=(i&(s.suspendedLanes|o))!==0?0:i,i!==0&&i!==r.retryLane&&(r.retryLane=i,hl(n,i),Fo(s,n,i,-1))}return iE(),s=N_(Error(Ve(421))),ay(n,e,o,s)}return i.data==="$?"?(e.flags|=128,e.child=n.child,e=p7.bind(null,n),i._reactRetry=e,null):(n=r.treeContext,Sr=ac(i.nextSibling),Tr=e,Bn=!0,Ro=null,n!==null&&(eo[to++]=tl,eo[to++]=nl,eo[to++]=Ku,tl=n.id,nl=n.overflow,Ku=e),e=JI(e,s.children),e.flags|=4096,e)}function p3(n,e,t){n.lanes|=e;var s=n.alternate;s!==null&&(s.lanes|=e),S2(n.return,e,t)}function R_(n,e,t,s,i){var r=n.memoizedState;r===null?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:s,tail:t,tailMode:i}:(r.isBackwards=e,r.rendering=null,r.renderingStartTime=0,r.last=s,r.tail=t,r.tailMode=i)}function zF(n,e,t){var s=e.pendingProps,i=s.revealOrder,r=s.tail;if(Li(n,e,s.children,t),s=Hn.current,(s&2)!==0)s=s&1|2,e.flags|=128;else{if(n!==null&&(n.flags&128)!==0)e:for(n=e.child;n!==null;){if(n.tag===13)n.memoizedState!==null&&p3(n,t,e);else if(n.tag===19)p3(n,t,e);else if(n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break e;for(;n.sibling===null;){if(n.return===null||n.return===e)break e;n=n.return}n.sibling.return=n.return,n=n.sibling}s&=1}if(kn(Hn,s),(e.mode&1)===0)e.memoizedState=null;else switch(i){case"forwards":for(t=e.child,i=null;t!==null;)n=t.alternate,n!==null&&t1(n)===null&&(i=t),t=t.sibling;t=i,t===null?(i=e.child,e.child=null):(i=t.sibling,t.sibling=null),R_(e,!1,i,t,r);break;case"backwards":for(t=null,i=e.child,e.child=null;i!==null;){if(n=i.alternate,n!==null&&t1(n)===null){e.child=i;break}n=i.sibling,i.sibling=t,t=i,i=n}R_(e,!0,t,null,r);break;case"together":R_(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function Tv(n,e){(e.mode&1)===0&&n!==null&&(n.alternate=null,e.alternate=null,e.flags|=2)}function dl(n,e,t){if(n!==null&&(e.dependencies=n.dependencies),Zu|=e.lanes,(t&e.childLanes)===0)return null;if(n!==null&&e.child!==n.child)throw Error(Ve(153));if(e.child!==null){for(n=e.child,t=hc(n,n.pendingProps),e.child=t,t.return=e;n.sibling!==null;)n=n.sibling,t=t.sibling=hc(n,n.pendingProps),t.return=e;t.sibling=null}return e.child}function n7(n,e,t){switch(e.tag){case 3:FF(e),Jd();break;case 5:dF(e);break;case 1:or(e.type)&&Kv(e);break;case 4:GI(e,e.stateNode.containerInfo);break;case 10:var s=e.type._context,i=e.memoizedProps.value;kn(Jv,s._currentValue),s._currentValue=i;break;case 13:if(s=e.memoizedState,s!==null)return s.dehydrated!==null?(kn(Hn,Hn.current&1),e.flags|=128,null):(t&e.child.childLanes)!==0?OF(n,e,t):(kn(Hn,Hn.current&1),n=dl(n,e,t),n!==null?n.sibling:null);kn(Hn,Hn.current&1);break;case 19:if(s=(t&e.childLanes)!==0,(n.flags&128)!==0){if(s)return zF(n,e,t);e.flags|=128}if(i=e.memoizedState,i!==null&&(i.rendering=null,i.tail=null,i.lastEffect=null),kn(Hn,Hn.current),s)break;return null;case 22:case 23:return e.lanes=0,PF(n,e,t)}return dl(n,e,t)}var BF,A2,UF,VF;BF=function(n,e){for(var t=e.child;t!==null;){if(t.tag===5||t.tag===6)n.appendChild(t.stateNode);else if(t.tag!==4&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}};A2=function(){};UF=function(n,e,t,s){var i=n.memoizedProps;if(i!==s){n=e.stateNode,Iu(ba.current);var r=null;switch(t){case"input":i=JC(n,i),s=JC(n,s),r=[];break;case"select":i=qn({},i,{value:void 0}),s=qn({},s,{value:void 0}),r=[];break;case"textarea":i=t2(n,i),s=t2(n,s),r=[];break;default:typeof i.onClick!="function"&&typeof s.onClick=="function"&&(n.onclick=jv)}s2(t,s);var o;t=null;for(c in i)if(!s.hasOwnProperty(c)&&i.hasOwnProperty(c)&&i[c]!=null)if(c==="style"){var a=i[c];for(o in a)a.hasOwnProperty(o)&&(t||(t={}),t[o]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(pm.hasOwnProperty(c)?r||(r=[]):(r=r||[]).push(c,null));for(c in s){var l=s[c];if(a=i!=null?i[c]:void 0,s.hasOwnProperty(c)&&l!==a&&(l!=null||a!=null))if(c==="style")if(a){for(o in a)!a.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(t||(t={}),t[o]="");for(o in l)l.hasOwnProperty(o)&&a[o]!==l[o]&&(t||(t={}),t[o]=l[o])}else t||(r||(r=[]),r.push(c,t)),t=l;else c==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,a=a?a.__html:void 0,l!=null&&a!==l&&(r=r||[]).push(c,l)):c==="children"?typeof l!="string"&&typeof l!="number"||(r=r||[]).push(c,""+l):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&(pm.hasOwnProperty(c)?(l!=null&&c==="onScroll"&&Ln("scroll",n),r||a===l||(r=[])):(r=r||[]).push(c,l))}t&&(r=r||[]).push("style",t);var c=r;(e.updateQueue=c)&&(e.flags|=4)}};VF=function(n,e,t,s){t!==s&&(e.flags|=4)};function _p(n,e){if(!Bn)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;e!==null;)e.alternate!==null&&(t=e),e=e.sibling;t===null?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var s=null;t!==null;)t.alternate!==null&&(s=t),t=t.sibling;s===null?e||n.tail===null?n.tail=null:n.tail.sibling=null:s.sibling=null}}function pi(n){var e=n.alternate!==null&&n.alternate.child===n.child,t=0,s=0;if(e)for(var i=n.child;i!==null;)t|=i.lanes|i.childLanes,s|=i.subtreeFlags&14680064,s|=i.flags&14680064,i.return=n,i=i.sibling;else for(i=n.child;i!==null;)t|=i.lanes|i.childLanes,s|=i.subtreeFlags,s|=i.flags,i.return=n,i=i.sibling;return n.subtreeFlags|=s,n.childLanes=t,e}function s7(n,e,t){var s=e.pendingProps;switch(FI(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return pi(e),null;case 1:return or(e.type)&&qv(),pi(e),null;case 3:return s=e.stateNode,ef(),Pn(rr),Pn(Ci),XI(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),(n===null||n.child===null)&&(ry(e)?e.flags|=4:n===null||n.memoizedState.isDehydrated&&(e.flags&256)===0||(e.flags|=1024,Ro!==null&&(O2(Ro),Ro=null))),A2(n,e),pi(e),null;case 5:HI(e);var i=Iu(Im.current);if(t=e.type,n!==null&&e.stateNode!=null)UF(n,e,t,s,i),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!s){if(e.stateNode===null)throw Error(Ve(166));return pi(e),null}if(n=Iu(ba.current),ry(e)){s=e.stateNode,t=e.type;var r=e.memoizedProps;switch(s[ma]=e,s[Cm]=r,n=(e.mode&1)!==0,t){case"dialog":Ln("cancel",s),Ln("close",s);break;case"iframe":case"object":case"embed":Ln("load",s);break;case"video":case"audio":for(i=0;i<Wp.length;i++)Ln(Wp[i],s);break;case"source":Ln("error",s);break;case"img":case"image":case"link":Ln("error",s),Ln("load",s);break;case"details":Ln("toggle",s);break;case"input":_R(s,r),Ln("invalid",s);break;case"select":s._wrapperState={wasMultiple:!!r.multiple},Ln("invalid",s);break;case"textarea":TR(s,r),Ln("invalid",s)}s2(t,r),i=null;for(var o in r)if(r.hasOwnProperty(o)){var a=r[o];o==="children"?typeof a=="string"?s.textContent!==a&&(r.suppressHydrationWarning!==!0&&iy(s.textContent,a,n),i=["children",a]):typeof a=="number"&&s.textContent!==""+a&&(r.suppressHydrationWarning!==!0&&iy(s.textContent,a,n),i=["children",""+a]):pm.hasOwnProperty(o)&&a!=null&&o==="onScroll"&&Ln("scroll",s)}switch(t){case"input":Yx(s),CR(s,r,!0);break;case"textarea":Yx(s),IR(s);break;case"select":case"option":break;default:typeof r.onClick=="function"&&(s.onclick=jv)}s=i,e.updateQueue=s,s!==null&&(e.flags|=4)}else{o=i.nodeType===9?i:i.ownerDocument,n==="http://www.w3.org/1999/xhtml"&&(n=m$(t)),n==="http://www.w3.org/1999/xhtml"?t==="script"?(n=o.createElement("div"),n.innerHTML="<script><\/script>",n=n.removeChild(n.firstChild)):typeof s.is=="string"?n=o.createElement(t,{is:s.is}):(n=o.createElement(t),t==="select"&&(o=n,s.multiple?o.multiple=!0:s.size&&(o.size=s.size))):n=o.createElementNS(n,t),n[ma]=e,n[Cm]=s,BF(n,e,!1,!1),e.stateNode=n;e:{switch(o=i2(t,s),t){case"dialog":Ln("cancel",n),Ln("close",n),i=s;break;case"iframe":case"object":case"embed":Ln("load",n),i=s;break;case"video":case"audio":for(i=0;i<Wp.length;i++)Ln(Wp[i],n);i=s;break;case"source":Ln("error",n),i=s;break;case"img":case"image":case"link":Ln("error",n),Ln("load",n),i=s;break;case"details":Ln("toggle",n),i=s;break;case"input":_R(n,s),i=JC(n,s),Ln("invalid",n);break;case"option":i=s;break;case"select":n._wrapperState={wasMultiple:!!s.multiple},i=qn({},s,{value:void 0}),Ln("invalid",n);break;case"textarea":TR(n,s),i=t2(n,s),Ln("invalid",n);break;default:i=s}s2(t,i),a=i;for(r in a)if(a.hasOwnProperty(r)){var l=a[r];r==="style"?y$(n,l):r==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&g$(n,l)):r==="children"?typeof l=="string"?(t!=="textarea"||l!=="")&&mm(n,l):typeof l=="number"&&mm(n,""+l):r!=="suppressContentEditableWarning"&&r!=="suppressHydrationWarning"&&r!=="autoFocus"&&(pm.hasOwnProperty(r)?l!=null&&r==="onScroll"&&Ln("scroll",n):l!=null&&SI(n,r,l,o))}switch(t){case"input":Yx(n),CR(n,s,!1);break;case"textarea":Yx(n),IR(n);break;case"option":s.value!=null&&n.setAttribute("value",""+yc(s.value));break;case"select":n.multiple=!!s.multiple,r=s.value,r!=null?Od(n,!!s.multiple,r,!1):s.defaultValue!=null&&Od(n,!!s.multiple,s.defaultValue,!0);break;default:typeof i.onClick=="function"&&(n.onclick=jv)}switch(t){case"button":case"input":case"select":case"textarea":s=!!s.autoFocus;break e;case"img":s=!0;break e;default:s=!1}}s&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return pi(e),null;case 6:if(n&&e.stateNode!=null)VF(n,e,n.memoizedProps,s);else{if(typeof s!="string"&&e.stateNode===null)throw Error(Ve(166));if(t=Iu(Im.current),Iu(ba.current),ry(e)){if(s=e.stateNode,t=e.memoizedProps,s[ma]=e,(r=s.nodeValue!==t)&&(n=Tr,n!==null))switch(n.tag){case 3:iy(s.nodeValue,t,(n.mode&1)!==0);break;case 5:n.memoizedProps.suppressHydrationWarning!==!0&&iy(s.nodeValue,t,(n.mode&1)!==0)}r&&(e.flags|=4)}else s=(t.nodeType===9?t:t.ownerDocument).createTextNode(s),s[ma]=e,e.stateNode=s}return pi(e),null;case 13:if(Pn(Hn),s=e.memoizedState,n===null||n.memoizedState!==null&&n.memoizedState.dehydrated!==null){if(Bn&&Sr!==null&&(e.mode&1)!==0&&(e.flags&128)===0)rF(),Jd(),e.flags|=98560,r=!1;else if(r=ry(e),s!==null&&s.dehydrated!==null){if(n===null){if(!r)throw Error(Ve(318));if(r=e.memoizedState,r=r!==null?r.dehydrated:null,!r)throw Error(Ve(317));r[ma]=e}else Jd(),(e.flags&128)===0&&(e.memoizedState=null),e.flags|=4;pi(e),r=!1}else Ro!==null&&(O2(Ro),Ro=null),r=!0;if(!r)return e.flags&65536?e:null}return(e.flags&128)!==0?(e.lanes=t,e):(s=s!==null,s!==(n!==null&&n.memoizedState!==null)&&s&&(e.child.flags|=8192,(e.mode&1)!==0&&(n===null||(Hn.current&1)!==0?Ds===0&&(Ds=3):iE())),e.updateQueue!==null&&(e.flags|=4),pi(e),null);case 4:return ef(),A2(n,e),n===null&&Sm(e.stateNode.containerInfo),pi(e),null;case 10:return UI(e.type._context),pi(e),null;case 17:return or(e.type)&&qv(),pi(e),null;case 19:if(Pn(Hn),r=e.memoizedState,r===null)return pi(e),null;if(s=(e.flags&128)!==0,o=r.rendering,o===null)if(s)_p(r,!1);else{if(Ds!==0||n!==null&&(n.flags&128)!==0)for(n=e.child;n!==null;){if(o=t1(n),o!==null){for(e.flags|=128,_p(r,!1),s=o.updateQueue,s!==null&&(e.updateQueue=s,e.flags|=4),e.subtreeFlags=0,s=t,t=e.child;t!==null;)r=t,n=s,r.flags&=14680066,o=r.alternate,o===null?(r.childLanes=0,r.lanes=n,r.child=null,r.subtreeFlags=0,r.memoizedProps=null,r.memoizedState=null,r.updateQueue=null,r.dependencies=null,r.stateNode=null):(r.childLanes=o.childLanes,r.lanes=o.lanes,r.child=o.child,r.subtreeFlags=0,r.deletions=null,r.memoizedProps=o.memoizedProps,r.memoizedState=o.memoizedState,r.updateQueue=o.updateQueue,r.type=o.type,n=o.dependencies,r.dependencies=n===null?null:{lanes:n.lanes,firstContext:n.firstContext}),t=t.sibling;return kn(Hn,Hn.current&1|2),e.child}n=n.sibling}r.tail!==null&&cs()>nf&&(e.flags|=128,s=!0,_p(r,!1),e.lanes=4194304)}else{if(!s)if(n=t1(o),n!==null){if(e.flags|=128,s=!0,t=n.updateQueue,t!==null&&(e.updateQueue=t,e.flags|=4),_p(r,!0),r.tail===null&&r.tailMode==="hidden"&&!o.alternate&&!Bn)return pi(e),null}else 2*cs()-r.renderingStartTime>nf&&t!==1073741824&&(e.flags|=128,s=!0,_p(r,!1),e.lanes=4194304);r.isBackwards?(o.sibling=e.child,e.child=o):(t=r.last,t!==null?t.sibling=o:e.child=o,r.last=o)}return r.tail!==null?(e=r.tail,r.rendering=e,r.tail=e.sibling,r.renderingStartTime=cs(),e.sibling=null,t=Hn.current,kn(Hn,s?t&1|2:t&1),e):(pi(e),null);case 22:case 23:return sE(),s=e.memoizedState!==null,n!==null&&n.memoizedState!==null!==s&&(e.flags|=8192),s&&(e.mode&1)!==0?(vr&1073741824)!==0&&(pi(e),e.subtreeFlags&6&&(e.flags|=8192)):pi(e),null;case 24:return null;case 25:return null}throw Error(Ve(156,e.tag))}function i7(n,e){switch(FI(e),e.tag){case 1:return or(e.type)&&qv(),n=e.flags,n&65536?(e.flags=n&-65537|128,e):null;case 3:return ef(),Pn(rr),Pn(Ci),XI(),n=e.flags,(n&65536)!==0&&(n&128)===0?(e.flags=n&-65537|128,e):null;case 5:return HI(e),null;case 13:if(Pn(Hn),n=e.memoizedState,n!==null&&n.dehydrated!==null){if(e.alternate===null)throw Error(Ve(340));Jd()}return n=e.flags,n&65536?(e.flags=n&-65537|128,e):null;case 19:return Pn(Hn),null;case 4:return ef(),null;case 10:return UI(e.type._context),null;case 22:case 23:return sE(),null;case 24:return null;default:return null}}var ly=!1,vi=!1,r7=typeof WeakSet=="function"?WeakSet:Set,at=null;function Ad(n,e){var t=n.ref;if(t!==null)if(typeof t=="function")try{t(null)}catch(s){Qn(n,e,s)}else t.current=null}function N2(n,e,t){try{t()}catch(s){Qn(n,e,s)}}var m3=!1;function o7(n,e){if(p2=Gv,n=X$(),PI(n)){if("selectionStart"in n)var t={start:n.selectionStart,end:n.selectionEnd};else e:{t=(t=n.ownerDocument)&&t.defaultView||window;var s=t.getSelection&&t.getSelection();if(s&&s.rangeCount!==0){t=s.anchorNode;var i=s.anchorOffset,r=s.focusNode;s=s.focusOffset;try{t.nodeType,r.nodeType}catch{t=null;break e}var o=0,a=-1,l=-1,c=0,u=0,h=n,d=null;t:for(;;){for(var f;h!==t||i!==0&&h.nodeType!==3||(a=o+i),h!==r||s!==0&&h.nodeType!==3||(l=o+s),h.nodeType===3&&(o+=h.nodeValue.length),(f=h.firstChild)!==null;)d=h,h=f;for(;;){if(h===n)break t;if(d===t&&++c===i&&(a=o),d===r&&++u===s&&(l=o),(f=h.nextSibling)!==null)break;h=d,d=h.parentNode}h=f}t=a===-1||l===-1?null:{start:a,end:l}}else t=null}t=t||{start:0,end:0}}else t=null;for(m2={focusedElem:n,selectionRange:t},Gv=!1,at=e;at!==null;)if(e=at,n=e.child,(e.subtreeFlags&1028)!==0&&n!==null)n.return=e,at=n;else for(;at!==null;){e=at;try{var m=e.alternate;if((e.flags&1024)!==0)switch(e.tag){case 0:case 11:case 15:break;case 1:if(m!==null){var x=m.memoizedProps,y=m.memoizedState,v=e.stateNode,w=v.getSnapshotBeforeUpdate(e.elementType===e.type?x:ko(e.type,x),y);v.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var b=e.stateNode.containerInfo;b.nodeType===1?b.textContent="":b.nodeType===9&&b.documentElement&&b.removeChild(b.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(Ve(163))}}catch(S){Qn(e,e.return,S)}if(n=e.sibling,n!==null){n.return=e.return,at=n;break}at=e.return}return m=m3,m3=!1,m}function im(n,e,t){var s=e.updateQueue;if(s=s!==null?s.lastEffect:null,s!==null){var i=s=s.next;do{if((i.tag&n)===n){var r=i.destroy;i.destroy=void 0,r!==void 0&&N2(e,t,r)}i=i.next}while(i!==s)}}function ew(n,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var t=e=e.next;do{if((t.tag&n)===n){var s=t.create;t.destroy=s()}t=t.next}while(t!==e)}}function R2(n){var e=n.ref;if(e!==null){var t=n.stateNode;switch(n.tag){case 5:n=t;break;default:n=t}typeof e=="function"?e(n):e.current=n}}function WF(n){var e=n.alternate;e!==null&&(n.alternate=null,WF(e)),n.child=null,n.deletions=null,n.sibling=null,n.tag===5&&(e=n.stateNode,e!==null&&(delete e[ma],delete e[Cm],delete e[y2],delete e[V8],delete e[W8])),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function GF(n){return n.tag===5||n.tag===3||n.tag===4}function g3(n){e:for(;;){for(;n.sibling===null;){if(n.return===null||GF(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;n.tag!==5&&n.tag!==6&&n.tag!==18;){if(n.flags&2||n.child===null||n.tag===4)continue e;n.child.return=n,n=n.child}if(!(n.flags&2))return n.stateNode}}function D2(n,e,t){var s=n.tag;if(s===5||s===6)n=n.stateNode,e?t.nodeType===8?t.parentNode.insertBefore(n,e):t.insertBefore(n,e):(t.nodeType===8?(e=t.parentNode,e.insertBefore(n,t)):(e=t,e.appendChild(n)),t=t._reactRootContainer,t!=null||e.onclick!==null||(e.onclick=jv));else if(s!==4&&(n=n.child,n!==null))for(D2(n,e,t),n=n.sibling;n!==null;)D2(n,e,t),n=n.sibling}function L2(n,e,t){var s=n.tag;if(s===5||s===6)n=n.stateNode,e?t.insertBefore(n,e):t.appendChild(n);else if(s!==4&&(n=n.child,n!==null))for(L2(n,e,t),n=n.sibling;n!==null;)L2(n,e,t),n=n.sibling}var ni=null,Ao=!1;function Pl(n,e,t){for(t=t.child;t!==null;)HF(n,e,t),t=t.sibling}function HF(n,e,t){if(wa&&typeof wa.onCommitFiberUnmount=="function")try{wa.onCommitFiberUnmount(X1,t)}catch{}switch(t.tag){case 5:vi||Ad(t,e);case 6:var s=ni,i=Ao;ni=null,Pl(n,e,t),ni=s,Ao=i,ni!==null&&(Ao?(n=ni,t=t.stateNode,n.nodeType===8?n.parentNode.removeChild(t):n.removeChild(t)):ni.removeChild(t.stateNode));break;case 18:ni!==null&&(Ao?(n=ni,t=t.stateNode,n.nodeType===8?T_(n.parentNode,t):n.nodeType===1&&T_(n,t),vm(n)):T_(ni,t.stateNode));break;case 4:s=ni,i=Ao,ni=t.stateNode.containerInfo,Ao=!0,Pl(n,e,t),ni=s,Ao=i;break;case 0:case 11:case 14:case 15:if(!vi&&(s=t.updateQueue,s!==null&&(s=s.lastEffect,s!==null))){i=s=s.next;do{var r=i,o=r.destroy;r=r.tag,o!==void 0&&((r&2)!==0||(r&4)!==0)&&N2(t,e,o),i=i.next}while(i!==s)}Pl(n,e,t);break;case 1:if(!vi&&(Ad(t,e),s=t.stateNode,typeof s.componentWillUnmount=="function"))try{s.props=t.memoizedProps,s.state=t.memoizedState,s.componentWillUnmount()}catch(a){Qn(t,e,a)}Pl(n,e,t);break;case 21:Pl(n,e,t);break;case 22:t.mode&1?(vi=(s=vi)||t.memoizedState!==null,Pl(n,e,t),vi=s):Pl(n,e,t);break;default:Pl(n,e,t)}}function x3(n){var e=n.updateQueue;if(e!==null){n.updateQueue=null;var t=n.stateNode;t===null&&(t=n.stateNode=new r7),e.forEach(function(s){var i=m7.bind(null,n,s);t.has(s)||(t.add(s),s.then(i,i))})}}function _o(n,e){var t=e.deletions;if(t!==null)for(var s=0;s<t.length;s++){var i=t[s];try{var r=n,o=e,a=o;e:for(;a!==null;){switch(a.tag){case 5:ni=a.stateNode,Ao=!1;break e;case 3:ni=a.stateNode.containerInfo,Ao=!0;break e;case 4:ni=a.stateNode.containerInfo,Ao=!0;break e}a=a.return}if(ni===null)throw Error(Ve(160));HF(r,o,i),ni=null,Ao=!1;var l=i.alternate;l!==null&&(l.return=null),i.return=null}catch(c){Qn(i,e,c)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)XF(e,n),e=e.sibling}function XF(n,e){var t=n.alternate,s=n.flags;switch(n.tag){case 0:case 11:case 14:case 15:if(_o(e,n),oa(n),s&4){try{im(3,n,n.return),ew(3,n)}catch(x){Qn(n,n.return,x)}try{im(5,n,n.return)}catch(x){Qn(n,n.return,x)}}break;case 1:_o(e,n),oa(n),s&512&&t!==null&&Ad(t,t.return);break;case 5:if(_o(e,n),oa(n),s&512&&t!==null&&Ad(t,t.return),n.flags&32){var i=n.stateNode;try{mm(i,"")}catch(x){Qn(n,n.return,x)}}if(s&4&&(i=n.stateNode,i!=null)){var r=n.memoizedProps,o=t!==null?t.memoizedProps:r,a=n.type,l=n.updateQueue;if(n.updateQueue=null,l!==null)try{a==="input"&&r.type==="radio"&&r.name!=null&&f$(i,r),i2(a,o);var c=i2(a,r);for(o=0;o<l.length;o+=2){var u=l[o],h=l[o+1];u==="style"?y$(i,h):u==="dangerouslySetInnerHTML"?g$(i,h):u==="children"?mm(i,h):SI(i,u,h,c)}switch(a){case"input":QC(i,r);break;case"textarea":p$(i,r);break;case"select":var d=i._wrapperState.wasMultiple;i._wrapperState.wasMultiple=!!r.multiple;var f=r.value;f!=null?Od(i,!!r.multiple,f,!1):d!==!!r.multiple&&(r.defaultValue!=null?Od(i,!!r.multiple,r.defaultValue,!0):Od(i,!!r.multiple,r.multiple?[]:"",!1))}i[Cm]=r}catch(x){Qn(n,n.return,x)}}break;case 6:if(_o(e,n),oa(n),s&4){if(n.stateNode===null)throw Error(Ve(162));i=n.stateNode,r=n.memoizedProps;try{i.nodeValue=r}catch(x){Qn(n,n.return,x)}}break;case 3:if(_o(e,n),oa(n),s&4&&t!==null&&t.memoizedState.isDehydrated)try{vm(e.containerInfo)}catch(x){Qn(n,n.return,x)}break;case 4:_o(e,n),oa(n);break;case 13:_o(e,n),oa(n),i=n.child,i.flags&8192&&(r=i.memoizedState!==null,i.stateNode.isHidden=r,!r||i.alternate!==null&&i.alternate.memoizedState!==null||(tE=cs())),s&4&&x3(n);break;case 22:if(u=t!==null&&t.memoizedState!==null,n.mode&1?(vi=(c=vi)||u,_o(e,n),vi=c):_o(e,n),oa(n),s&8192){if(c=n.memoizedState!==null,(n.stateNode.isHidden=c)&&!u&&(n.mode&1)!==0)for(at=n,u=n.child;u!==null;){for(h=at=u;at!==null;){switch(d=at,f=d.child,d.tag){case 0:case 11:case 14:case 15:im(4,d,d.return);break;case 1:Ad(d,d.return);var m=d.stateNode;if(typeof m.componentWillUnmount=="function"){s=d,t=d.return;try{e=s,m.props=e.memoizedProps,m.state=e.memoizedState,m.componentWillUnmount()}catch(x){Qn(s,t,x)}}break;case 5:Ad(d,d.return);break;case 22:if(d.memoizedState!==null){v3(h);continue}}f!==null?(f.return=d,at=f):v3(h)}u=u.sibling}e:for(u=null,h=n;;){if(h.tag===5){if(u===null){u=h;try{i=h.stateNode,c?(r=i.style,typeof r.setProperty=="function"?r.setProperty("display","none","important"):r.display="none"):(a=h.stateNode,l=h.memoizedProps.style,o=l!=null&&l.hasOwnProperty("display")?l.display:null,a.style.display=x$("display",o))}catch(x){Qn(n,n.return,x)}}}else if(h.tag===6){if(u===null)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(x){Qn(n,n.return,x)}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===n)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===n)break e;for(;h.sibling===null;){if(h.return===null||h.return===n)break e;u===h&&(u=null),h=h.return}u===h&&(u=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:_o(e,n),oa(n),s&4&&x3(n);break;case 21:break;default:_o(e,n),oa(n)}}function oa(n){var e=n.flags;if(e&2){try{e:{for(var t=n.return;t!==null;){if(GF(t)){var s=t;break e}t=t.return}throw Error(Ve(160))}switch(s.tag){case 5:var i=s.stateNode;s.flags&32&&(mm(i,""),s.flags&=-33);var r=g3(n);L2(n,r,i);break;case 3:case 4:var o=s.stateNode.containerInfo,a=g3(n);D2(n,a,o);break;default:throw Error(Ve(161))}}catch(l){Qn(n,n.return,l)}n.flags&=-3}e&4096&&(n.flags&=-4097)}function a7(n,e,t){at=n,jF(n)}function jF(n,e,t){for(var s=(n.mode&1)!==0;at!==null;){var i=at,r=i.child;if(i.tag===22&&s){var o=i.memoizedState!==null||ly;if(!o){var a=i.alternate,l=a!==null&&a.memoizedState!==null||vi;a=ly;var c=vi;if(ly=o,(vi=l)&&!c)for(at=i;at!==null;)o=at,l=o.child,o.tag===22&&o.memoizedState!==null?w3(i):l!==null?(l.return=o,at=l):w3(i);for(;r!==null;)at=r,jF(r),r=r.sibling;at=i,ly=a,vi=c}y3(n)}else(i.subtreeFlags&8772)!==0&&r!==null?(r.return=i,at=r):y3(n)}}function y3(n){for(;at!==null;){var e=at;if((e.flags&8772)!==0){var t=e.alternate;try{if((e.flags&8772)!==0)switch(e.tag){case 0:case 11:case 15:vi||ew(5,e);break;case 1:var s=e.stateNode;if(e.flags&4&&!vi)if(t===null)s.componentDidMount();else{var i=e.elementType===e.type?t.memoizedProps:ko(e.type,t.memoizedProps);s.componentDidUpdate(i,t.memoizedState,s.__reactInternalSnapshotBeforeUpdate)}var r=e.updateQueue;r!==null&&t3(e,r,s);break;case 3:var o=e.updateQueue;if(o!==null){if(t=null,e.child!==null)switch(e.child.tag){case 5:t=e.child.stateNode;break;case 1:t=e.child.stateNode}t3(e,o,t)}break;case 5:var a=e.stateNode;if(t===null&&e.flags&4){t=a;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&t.focus();break;case"img":l.src&&(t.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var c=e.alternate;if(c!==null){var u=c.memoizedState;if(u!==null){var h=u.dehydrated;h!==null&&vm(h)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(Ve(163))}vi||e.flags&512&&R2(e)}catch(d){Qn(e,e.return,d)}}if(e===n){at=null;break}if(t=e.sibling,t!==null){t.return=e.return,at=t;break}at=e.return}}function v3(n){for(;at!==null;){var e=at;if(e===n){at=null;break}var t=e.sibling;if(t!==null){t.return=e.return,at=t;break}at=e.return}}function w3(n){for(;at!==null;){var e=at;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{ew(4,e)}catch(l){Qn(e,t,l)}break;case 1:var s=e.stateNode;if(typeof s.componentDidMount=="function"){var i=e.return;try{s.componentDidMount()}catch(l){Qn(e,i,l)}}var r=e.return;try{R2(e)}catch(l){Qn(e,r,l)}break;case 5:var o=e.return;try{R2(e)}catch(l){Qn(e,o,l)}}}catch(l){Qn(e,e.return,l)}if(e===n){at=null;break}var a=e.sibling;if(a!==null){a.return=e.return,at=a;break}at=e.return}}var l7=Math.ceil,i1=yl.ReactCurrentDispatcher,QI=yl.ReactCurrentOwner,uo=yl.ReactCurrentBatchConfig,on=0,qs=null,bs=null,si=0,vr=0,Nd=Rc(0),Ds=0,Am=null,Zu=0,tw=0,eE=0,rm=null,er=null,tE=0,nf=1/0,Ya=null,r1=!1,P2=null,cc=null,cy=!1,Ql=null,o1=0,om=0,$2=null,Iv=-1,Ev=0;function Bi(){return(on&6)!==0?cs():Iv!==-1?Iv:Iv=cs()}function uc(n){return(n.mode&1)===0?1:(on&2)!==0&&si!==0?si&-si:H8.transition!==null?(Ev===0&&(Ev=A$()),Ev):(n=xn,n!==0||(n=window.event,n=n===void 0?16:F$(n.type)),n)}function Fo(n,e,t,s){if(50<om)throw om=0,$2=null,Error(Ve(185));lg(n,t,s),((on&2)===0||n!==qs)&&(n===qs&&((on&2)===0&&(tw|=t),Ds===4&&Yl(n,si)),ar(n,s),t===1&&on===0&&(e.mode&1)===0&&(nf=cs()+500,Z1&&Dc()))}function ar(n,e){var t=n.callbackNode;H6(n,e);var s=Wv(n,n===qs?si:0);if(s===0)t!==null&&kR(t),n.callbackNode=null,n.callbackPriority=0;else if(e=s&-s,n.callbackPriority!==e){if(t!=null&&kR(t),e===1)n.tag===0?G8(b3.bind(null,n)):nF(b3.bind(null,n)),B8(function(){(on&6)===0&&Dc()}),t=null;else{switch(N$(s)){case 1:t=EI;break;case 4:t=M$;break;case 16:t=Vv;break;case 536870912:t=k$;break;default:t=Vv}t=tO(t,qF.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function qF(n,e){if(Iv=-1,Ev=0,(on&6)!==0)throw Error(Ve(327));var t=n.callbackNode;if(Wd()&&n.callbackNode!==t)return null;var s=Wv(n,n===qs?si:0);if(s===0)return null;if((s&30)!==0||(s&n.expiredLanes)!==0||e)e=a1(n,s);else{e=s;var i=on;on|=2;var r=YF();(qs!==n||si!==e)&&(Ya=null,nf=cs()+500,$u(n,e));do try{h7();break}catch(a){KF(n,a)}while(1);BI(),i1.current=r,on=i,bs!==null?e=0:(qs=null,si=0,e=Ds)}if(e!==0){if(e===2&&(i=c2(n),i!==0&&(s=i,e=F2(n,i))),e===1)throw t=Am,$u(n,0),Yl(n,s),ar(n,cs()),t;if(e===6)Yl(n,s);else{if(i=n.current.alternate,(s&30)===0&&!c7(i)&&(e=a1(n,s),e===2&&(r=c2(n),r!==0&&(s=r,e=F2(n,r))),e===1))throw t=Am,$u(n,0),Yl(n,s),ar(n,cs()),t;switch(n.finishedWork=i,n.finishedLanes=s,e){case 0:case 1:throw Error(Ve(345));case 2:fu(n,er,Ya);break;case 3:if(Yl(n,s),(s&130023424)===s&&(e=tE+500-cs(),10<e)){if(Wv(n,0)!==0)break;if(i=n.suspendedLanes,(i&s)!==s){Bi(),n.pingedLanes|=n.suspendedLanes&i;break}n.timeoutHandle=x2(fu.bind(null,n,er,Ya),e);break}fu(n,er,Ya);break;case 4:if(Yl(n,s),(s&4194240)===s)break;for(e=n.eventTimes,i=-1;0<s;){var o=31-$o(s);r=1<<o,o=e[o],o>i&&(i=o),s&=~r}if(s=i,s=cs()-s,s=(120>s?120:480>s?480:1080>s?1080:1920>s?1920:3e3>s?3e3:4320>s?4320:1960*l7(s/1960))-s,10<s){n.timeoutHandle=x2(fu.bind(null,n,er,Ya),s);break}fu(n,er,Ya);break;case 5:fu(n,er,Ya);break;default:throw Error(Ve(329))}}}return ar(n,cs()),n.callbackNode===t?qF.bind(null,n):null}function F2(n,e){var t=rm;return n.current.memoizedState.isDehydrated&&($u(n,e).flags|=256),n=a1(n,e),n!==2&&(e=er,er=t,e!==null&&O2(e)),n}function O2(n){er===null?er=n:er.push.apply(er,n)}function c7(n){for(var e=n;;){if(e.flags&16384){var t=e.updateQueue;if(t!==null&&(t=t.stores,t!==null))for(var s=0;s<t.length;s++){var i=t[s],r=i.getSnapshot;i=i.value;try{if(!Vo(r(),i))return!1}catch{return!1}}}if(t=e.child,e.subtreeFlags&16384&&t!==null)t.return=e,e=t;else{if(e===n)break;for(;e.sibling===null;){if(e.return===null||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function Yl(n,e){for(e&=~eE,e&=~tw,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-$o(e),s=1<<t;n[t]=-1,e&=~s}}function b3(n){if((on&6)!==0)throw Error(Ve(327));Wd();var e=Wv(n,0);if((e&1)===0)return ar(n,cs()),null;var t=a1(n,e);if(n.tag!==0&&t===2){var s=c2(n);s!==0&&(e=s,t=F2(n,s))}if(t===1)throw t=Am,$u(n,0),Yl(n,e),ar(n,cs()),t;if(t===6)throw Error(Ve(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,fu(n,er,Ya),ar(n,cs()),null}function nE(n,e){var t=on;on|=1;try{return n(e)}finally{on=t,on===0&&(nf=cs()+500,Z1&&Dc())}}function Ju(n){Ql!==null&&Ql.tag===0&&(on&6)===0&&Wd();var e=on;on|=1;var t=uo.transition,s=xn;try{if(uo.transition=null,xn=1,n)return n()}finally{xn=s,uo.transition=t,on=e,(on&6)===0&&Dc()}}function sE(){vr=Nd.current,Pn(Nd)}function $u(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(t!==-1&&(n.timeoutHandle=-1,z8(t)),bs!==null)for(t=bs.return;t!==null;){var s=t;switch(FI(s),s.tag){case 1:s=s.type.childContextTypes,s!=null&&qv();break;case 3:ef(),Pn(rr),Pn(Ci),XI();break;case 5:HI(s);break;case 4:ef();break;case 13:Pn(Hn);break;case 19:Pn(Hn);break;case 10:UI(s.type._context);break;case 22:case 23:sE()}t=t.return}if(qs=n,bs=n=hc(n.current,null),si=vr=e,Ds=0,Am=null,eE=tw=Zu=0,er=rm=null,Tu!==null){for(e=0;e<Tu.length;e++)if(t=Tu[e],s=t.interleaved,s!==null){t.interleaved=null;var i=s.next,r=t.pending;if(r!==null){var o=r.next;r.next=i,s.next=o}t.pending=s}Tu=null}return n}function KF(n,e){do{var t=bs;try{if(BI(),_v.current=s1,n1){for(var s=jn.memoizedState;s!==null;){var i=s.queue;i!==null&&(i.pending=null),s=s.next}n1=!1}if(Yu=0,Hs=As=jn=null,sm=!1,Em=0,QI.current=null,t===null||t.return===null){Ds=1,Am=e,bs=null;break}e:{var r=n,o=t.return,a=t,l=e;if(e=si,a.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var c=l,u=a,h=u.tag;if((u.mode&1)===0&&(h===0||h===11||h===15)){var d=u.alternate;d?(u.updateQueue=d.updateQueue,u.memoizedState=d.memoizedState,u.lanes=d.lanes):(u.updateQueue=null,u.memoizedState=null)}var f=l3(o);if(f!==null){f.flags&=-257,c3(f,o,a,r,e),f.mode&1&&a3(r,c,e),e=f,l=c;var m=e.updateQueue;if(m===null){var x=new Set;x.add(l),e.updateQueue=x}else m.add(l);break e}else{if((e&1)===0){a3(r,c,e),iE();break e}l=Error(Ve(426))}}else if(Bn&&a.mode&1){var y=l3(o);if(y!==null){(y.flags&65536)===0&&(y.flags|=256),c3(y,o,a,r,e),OI(tf(l,a));break e}}r=l=tf(l,a),Ds!==4&&(Ds=2),rm===null?rm=[r]:rm.push(r),r=o;do{switch(r.tag){case 3:r.flags|=65536,e&=-e,r.lanes|=e;var v=RF(r,l,e);e3(r,v);break e;case 1:a=l;var w=r.type,b=r.stateNode;if((r.flags&128)===0&&(typeof w.getDerivedStateFromError=="function"||b!==null&&typeof b.componentDidCatch=="function"&&(cc===null||!cc.has(b)))){r.flags|=65536,e&=-e,r.lanes|=e;var S=DF(r,a,e);e3(r,S);break e}}r=r.return}while(r!==null)}JF(t)}catch(C){e=C,bs===t&&t!==null&&(bs=t=t.return);continue}break}while(1)}function YF(){var n=i1.current;return i1.current=s1,n===null?s1:n}function iE(){(Ds===0||Ds===3||Ds===2)&&(Ds=4),qs===null||(Zu&268435455)===0&&(tw&268435455)===0||Yl(qs,si)}function a1(n,e){var t=on;on|=2;var s=YF();(qs!==n||si!==e)&&(Ya=null,$u(n,e));do try{u7();break}catch(i){KF(n,i)}while(1);if(BI(),on=t,i1.current=s,bs!==null)throw Error(Ve(261));return qs=null,si=0,Ds}function u7(){for(;bs!==null;)ZF(bs)}function h7(){for(;bs!==null&&!$6();)ZF(bs)}function ZF(n){var e=eO(n.alternate,n,vr);n.memoizedProps=n.pendingProps,e===null?JF(n):bs=e,QI.current=null}function JF(n){var e=n;do{var t=e.alternate;if(n=e.return,(e.flags&32768)===0){if(t=s7(t,e,vr),t!==null){bs=t;return}}else{if(t=i7(t,e),t!==null){t.flags&=32767,bs=t;return}if(n!==null)n.flags|=32768,n.subtreeFlags=0,n.deletions=null;else{Ds=6,bs=null;return}}if(e=e.sibling,e!==null){bs=e;return}bs=e=n}while(e!==null);Ds===0&&(Ds=5)}function fu(n,e,t){var s=xn,i=uo.transition;try{uo.transition=null,xn=1,d7(n,e,t,s)}finally{uo.transition=i,xn=s}return null}function d7(n,e,t,s){do Wd();while(Ql!==null);if((on&6)!==0)throw Error(Ve(327));t=n.finishedWork;var i=n.finishedLanes;if(t===null)return null;if(n.finishedWork=null,n.finishedLanes=0,t===n.current)throw Error(Ve(177));n.callbackNode=null,n.callbackPriority=0;var r=t.lanes|t.childLanes;if(X6(n,r),n===qs&&(bs=qs=null,si=0),(t.subtreeFlags&2064)===0&&(t.flags&2064)===0||cy||(cy=!0,tO(Vv,function(){return Wd(),null})),r=(t.flags&15990)!==0,(t.subtreeFlags&15990)!==0||r){r=uo.transition,uo.transition=null;var o=xn;xn=1;var a=on;on|=4,QI.current=null,o7(n,t),XF(t,n),R8(m2),Gv=!!p2,m2=p2=null,n.current=t,a7(t),F6(),on=a,xn=o,uo.transition=r}else n.current=t;if(cy&&(cy=!1,Ql=n,o1=i),r=n.pendingLanes,r===0&&(cc=null),B6(t.stateNode),ar(n,cs()),e!==null)for(s=n.onRecoverableError,t=0;t<e.length;t++)i=e[t],s(i.value,{componentStack:i.stack,digest:i.digest});if(r1)throw r1=!1,n=P2,P2=null,n;return(o1&1)!==0&&n.tag!==0&&Wd(),r=n.pendingLanes,(r&1)!==0?n===$2?om++:(om=0,$2=n):om=0,Dc(),null}function Wd(){if(Ql!==null){var n=N$(o1),e=uo.transition,t=xn;try{if(uo.transition=null,xn=16>n?16:n,Ql===null)var s=!1;else{if(n=Ql,Ql=null,o1=0,(on&6)!==0)throw Error(Ve(331));var i=on;for(on|=4,at=n.current;at!==null;){var r=at,o=r.child;if((at.flags&16)!==0){var a=r.deletions;if(a!==null){for(var l=0;l<a.length;l++){var c=a[l];for(at=c;at!==null;){var u=at;switch(u.tag){case 0:case 11:case 15:im(8,u,r)}var h=u.child;if(h!==null)h.return=u,at=h;else for(;at!==null;){u=at;var d=u.sibling,f=u.return;if(WF(u),u===c){at=null;break}if(d!==null){d.return=f,at=d;break}at=f}}}var m=r.alternate;if(m!==null){var x=m.child;if(x!==null){m.child=null;do{var y=x.sibling;x.sibling=null,x=y}while(x!==null)}}at=r}}if((r.subtreeFlags&2064)!==0&&o!==null)o.return=r,at=o;else e:for(;at!==null;){if(r=at,(r.flags&2048)!==0)switch(r.tag){case 0:case 11:case 15:im(9,r,r.return)}var v=r.sibling;if(v!==null){v.return=r.return,at=v;break e}at=r.return}}var w=n.current;for(at=w;at!==null;){o=at;var b=o.child;if((o.subtreeFlags&2064)!==0&&b!==null)b.return=o,at=b;else e:for(o=w;at!==null;){if(a=at,(a.flags&2048)!==0)try{switch(a.tag){case 0:case 11:case 15:ew(9,a)}}catch(C){Qn(a,a.return,C)}if(a===o){at=null;break e}var S=a.sibling;if(S!==null){S.return=a.return,at=S;break e}at=a.return}}if(on=i,Dc(),wa&&typeof wa.onPostCommitFiberRoot=="function")try{wa.onPostCommitFiberRoot(X1,n)}catch{}s=!0}return s}finally{xn=t,uo.transition=e}}return!1}function S3(n,e,t){e=tf(t,e),e=RF(n,e,1),n=lc(n,e,1),e=Bi(),n!==null&&(lg(n,1,e),ar(n,e))}function Qn(n,e,t){if(n.tag===3)S3(n,n,t);else for(;e!==null;){if(e.tag===3){S3(e,n,t);break}else if(e.tag===1){var s=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof s.componentDidCatch=="function"&&(cc===null||!cc.has(s))){n=tf(t,n),n=DF(e,n,1),e=lc(e,n,1),n=Bi(),e!==null&&(lg(e,1,n),ar(e,n));break}}e=e.return}}function f7(n,e,t){var s=n.pingCache;s!==null&&s.delete(e),e=Bi(),n.pingedLanes|=n.suspendedLanes&t,qs===n&&(si&t)===t&&(Ds===4||Ds===3&&(si&130023424)===si&&500>cs()-tE?$u(n,0):eE|=t),ar(n,e)}function QF(n,e){e===0&&((n.mode&1)===0?e=1:(e=Qx,Qx<<=1,(Qx&130023424)===0&&(Qx=4194304)));var t=Bi();n=hl(n,e),n!==null&&(lg(n,e,t),ar(n,t))}function p7(n){var e=n.memoizedState,t=0;e!==null&&(t=e.retryLane),QF(n,t)}function m7(n,e){var t=0;switch(n.tag){case 13:var s=n.stateNode,i=n.memoizedState;i!==null&&(t=i.retryLane);break;case 19:s=n.stateNode;break;default:throw Error(Ve(314))}s!==null&&s.delete(e),QF(n,t)}var eO;eO=function(n,e,t){if(n!==null)if(n.memoizedProps!==e.pendingProps||rr.current)sr=!0;else{if((n.lanes&t)===0&&(e.flags&128)===0)return sr=!1,n7(n,e,t);sr=(n.flags&131072)!==0}else sr=!1,Bn&&(e.flags&1048576)!==0&&sF(e,Zv,e.index);switch(e.lanes=0,e.tag){case 2:var s=e.type;Tv(n,e),n=e.pendingProps;var i=Zd(e,Ci.current);Vd(e,t),i=qI(null,e,s,n,i,t);var r=KI();return e.flags|=1,typeof i=="object"&&i!==null&&typeof i.render=="function"&&i.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,or(s)?(r=!0,Kv(e)):r=!1,e.memoizedState=i.state!==null&&i.state!==void 0?i.state:null,WI(e),i.updater=J1,e.stateNode=i,i._reactInternals=e,C2(e,s,n,t),e=E2(null,e,s,!0,r,t)):(e.tag=0,Bn&&r&&$I(e),Li(null,e,i,t),e=e.child),e;case 16:s=e.elementType;e:{switch(Tv(n,e),n=e.pendingProps,i=s._init,s=i(s._payload),e.type=s,i=e.tag=x7(s),n=ko(s,n),i){case 0:e=I2(null,e,s,n,t);break e;case 1:e=d3(null,e,s,n,t);break e;case 11:e=u3(null,e,s,n,t);break e;case 14:e=h3(null,e,s,ko(s.type,n),t);break e}throw Error(Ve(306,s,""))}return e;case 0:return s=e.type,i=e.pendingProps,i=e.elementType===s?i:ko(s,i),I2(n,e,s,i,t);case 1:return s=e.type,i=e.pendingProps,i=e.elementType===s?i:ko(s,i),d3(n,e,s,i,t);case 3:e:{if(FF(e),n===null)throw Error(Ve(387));s=e.pendingProps,r=e.memoizedState,i=r.element,aF(n,e),e1(e,s,null,t);var o=e.memoizedState;if(s=o.element,r.isDehydrated)if(r={element:s,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},e.updateQueue.baseState=r,e.memoizedState=r,e.flags&256){i=tf(Error(Ve(423)),e),e=f3(n,e,s,t,i);break e}else if(s!==i){i=tf(Error(Ve(424)),e),e=f3(n,e,s,t,i);break e}else for(Sr=ac(e.stateNode.containerInfo.firstChild),Tr=e,Bn=!0,Ro=null,t=hF(e,null,s,t),e.child=t;t;)t.flags=t.flags&-3|4096,t=t.sibling;else{if(Jd(),s===i){e=dl(n,e,t);break e}Li(n,e,s,t)}e=e.child}return e;case 5:return dF(e),n===null&&b2(e),s=e.type,i=e.pendingProps,r=n!==null?n.memoizedProps:null,o=i.children,g2(s,i)?o=null:r!==null&&g2(s,r)&&(e.flags|=32),$F(n,e),Li(n,e,o,t),e.child;case 6:return n===null&&b2(e),null;case 13:return OF(n,e,t);case 4:return GI(e,e.stateNode.containerInfo),s=e.pendingProps,n===null?e.child=Qd(e,null,s,t):Li(n,e,s,t),e.child;case 11:return s=e.type,i=e.pendingProps,i=e.elementType===s?i:ko(s,i),u3(n,e,s,i,t);case 7:return Li(n,e,e.pendingProps,t),e.child;case 8:return Li(n,e,e.pendingProps.children,t),e.child;case 12:return Li(n,e,e.pendingProps.children,t),e.child;case 10:e:{if(s=e.type._context,i=e.pendingProps,r=e.memoizedProps,o=i.value,kn(Jv,s._currentValue),s._currentValue=o,r!==null)if(Vo(r.value,o)){if(r.children===i.children&&!rr.current){e=dl(n,e,t);break e}}else for(r=e.child,r!==null&&(r.return=e);r!==null;){var a=r.dependencies;if(a!==null){o=r.child;for(var l=a.firstContext;l!==null;){if(l.context===s){if(r.tag===1){l=ol(-1,t&-t),l.tag=2;var c=r.updateQueue;if(c!==null){c=c.shared;var u=c.pending;u===null?l.next=l:(l.next=u.next,u.next=l),c.pending=l}}r.lanes|=t,l=r.alternate,l!==null&&(l.lanes|=t),S2(r.return,t,e),a.lanes|=t;break}l=l.next}}else if(r.tag===10)o=r.type===e.type?null:r.child;else if(r.tag===18){if(o=r.return,o===null)throw Error(Ve(341));o.lanes|=t,a=o.alternate,a!==null&&(a.lanes|=t),S2(o,t,e),o=r.sibling}else o=r.child;if(o!==null)o.return=r;else for(o=r;o!==null;){if(o===e){o=null;break}if(r=o.sibling,r!==null){r.return=o.return,o=r;break}o=o.return}r=o}Li(n,e,i.children,t),e=e.child}return e;case 9:return i=e.type,s=e.pendingProps.children,Vd(e,t),i=ho(i),s=s(i),e.flags|=1,Li(n,e,s,t),e.child;case 14:return s=e.type,i=ko(s,e.pendingProps),i=ko(s.type,i),h3(n,e,s,i,t);case 15:return LF(n,e,e.type,e.pendingProps,t);case 17:return s=e.type,i=e.pendingProps,i=e.elementType===s?i:ko(s,i),Tv(n,e),e.tag=1,or(s)?(n=!0,Kv(e)):n=!1,Vd(e,t),cF(e,s,i),C2(e,s,i,t),E2(null,e,s,!0,n,t);case 19:return zF(n,e,t);case 22:return PF(n,e,t)}throw Error(Ve(156,e.tag))};function tO(n,e){return E$(n,e)}function g7(n,e,t,s){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=s,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function io(n,e,t,s){return new g7(n,e,t,s)}function rE(n){return n=n.prototype,!(!n||!n.isReactComponent)}function x7(n){if(typeof n=="function")return rE(n)?1:0;if(n!=null){if(n=n.$$typeof,n===CI)return 11;if(n===TI)return 14}return 2}function hc(n,e){var t=n.alternate;return t===null?(t=io(n.tag,e,n.key,n.mode),t.elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=n.flags&14680064,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function Mv(n,e,t,s,i,r){var o=2;if(s=n,typeof n=="function")rE(n)&&(o=1);else if(typeof n=="string")o=5;else e:switch(n){case bd:return Fu(t.children,i,r,e);case _I:o=8,i|=8;break;case qC:return n=io(12,t,e,i|2),n.elementType=qC,n.lanes=r,n;case KC:return n=io(13,t,e,i),n.elementType=KC,n.lanes=r,n;case YC:return n=io(19,t,e,i),n.elementType=YC,n.lanes=r,n;case u$:return nw(t,i,r,e);default:if(typeof n=="object"&&n!==null)switch(n.$$typeof){case l$:o=10;break e;case c$:o=9;break e;case CI:o=11;break e;case TI:o=14;break e;case Hl:o=16,s=null;break e}throw Error(Ve(130,n==null?n:typeof n,""))}return e=io(o,t,e,i),e.elementType=n,e.type=s,e.lanes=r,e}function Fu(n,e,t,s){return n=io(7,n,s,e),n.lanes=t,n}function nw(n,e,t,s){return n=io(22,n,s,e),n.elementType=u$,n.lanes=t,n.stateNode={isHidden:!1},n}function D_(n,e,t){return n=io(6,n,null,e),n.lanes=t,n}function L_(n,e,t){return e=io(4,n.children!==null?n.children:[],n.key,e),e.lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function y7(n,e,t,s,i){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=p_(0),this.expirationTimes=p_(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=p_(0),this.identifierPrefix=s,this.onRecoverableError=i,this.mutableSourceEagerHydrationData=null}function oE(n,e,t,s,i,r,o,a,l){return n=new y7(n,e,t,a,l),e===1?(e=1,r===!0&&(e|=8)):e=0,r=io(3,null,null,e),n.current=r,r.stateNode=n,r.memoizedState={element:s,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},WI(r),n}function v7(n,e,t){var s=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wd,key:s==null?null:""+s,children:n,containerInfo:e,implementation:t}}function nO(n){if(!n)return vc;n=n._reactInternals;e:{if(vh(n)!==n||n.tag!==1)throw Error(Ve(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(or(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(Ve(171))}if(n.tag===1){var t=n.type;if(or(t))return tF(n,t,e)}return e}function sO(n,e,t,s,i,r,o,a,l){return n=oE(t,s,!0,n,i,r,o,a,l),n.context=nO(null),t=n.current,s=Bi(),i=uc(t),r=ol(s,i),r.callback=e!=null?e:null,lc(t,r,i),n.current.lanes=i,lg(n,i,s),ar(n,s),n}function sw(n,e,t,s){var i=e.current,r=Bi(),o=uc(i);return t=nO(t),e.context===null?e.context=t:e.pendingContext=t,e=ol(r,o),e.payload={element:n},s=s===void 0?null:s,s!==null&&(e.callback=s),n=lc(i,e,o),n!==null&&(Fo(n,i,o,r),Sv(n,i,o)),o}function l1(n){if(n=n.current,!n.child)return null;switch(n.child.tag){case 5:return n.child.stateNode;default:return n.child.stateNode}}function _3(n,e){if(n=n.memoizedState,n!==null&&n.dehydrated!==null){var t=n.retryLane;n.retryLane=t!==0&&t<e?t:e}}function aE(n,e){_3(n,e),(n=n.alternate)&&_3(n,e)}function w7(){return null}var iO=typeof reportError=="function"?reportError:function(n){console.error(n)};function lE(n){this._internalRoot=n}iw.prototype.render=lE.prototype.render=function(n){var e=this._internalRoot;if(e===null)throw Error(Ve(409));sw(n,e,null,null)};iw.prototype.unmount=lE.prototype.unmount=function(){var n=this._internalRoot;if(n!==null){this._internalRoot=null;var e=n.containerInfo;Ju(function(){sw(null,n,null,null)}),e[ul]=null}};function iw(n){this._internalRoot=n}iw.prototype.unstable_scheduleHydration=function(n){if(n){var e=L$();n={blockedOn:null,target:n,priority:e};for(var t=0;t<Kl.length&&e!==0&&e<Kl[t].priority;t++);Kl.splice(t,0,n),t===0&&$$(n)}};function cE(n){return!(!n||n.nodeType!==1&&n.nodeType!==9&&n.nodeType!==11)}function rw(n){return!(!n||n.nodeType!==1&&n.nodeType!==9&&n.nodeType!==11&&(n.nodeType!==8||n.nodeValue!==" react-mount-point-unstable "))}function C3(){}function b7(n,e,t,s,i){if(i){if(typeof s=="function"){var r=s;s=function(){var c=l1(o);r.call(c)}}var o=sO(e,s,n,0,null,!1,!1,"",C3);return n._reactRootContainer=o,n[ul]=o.current,Sm(n.nodeType===8?n.parentNode:n),Ju(),o}for(;i=n.lastChild;)n.removeChild(i);if(typeof s=="function"){var a=s;s=function(){var c=l1(l);a.call(c)}}var l=oE(n,0,!1,null,null,!1,!1,"",C3);return n._reactRootContainer=l,n[ul]=l.current,Sm(n.nodeType===8?n.parentNode:n),Ju(function(){sw(e,l,t,s)}),l}function ow(n,e,t,s,i){var r=t._reactRootContainer;if(r){var o=r;if(typeof i=="function"){var a=i;i=function(){var l=l1(o);a.call(l)}}sw(e,o,n,i)}else o=b7(t,e,n,i,s);return l1(o)}R$=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=Vp(e.pendingLanes);t!==0&&(MI(e,t|1),ar(e,cs()),(on&6)===0&&(nf=cs()+500,Dc()))}break;case 13:Ju(function(){var s=hl(n,1);if(s!==null){var i=Bi();Fo(s,n,1,i)}}),aE(n,1)}};kI=function(n){if(n.tag===13){var e=hl(n,134217728);if(e!==null){var t=Bi();Fo(e,n,134217728,t)}aE(n,134217728)}};D$=function(n){if(n.tag===13){var e=uc(n),t=hl(n,e);if(t!==null){var s=Bi();Fo(t,n,e,s)}aE(n,e)}};L$=function(){return xn};P$=function(n,e){var t=xn;try{return xn=n,e()}finally{xn=t}};o2=function(n,e,t){switch(e){case"input":if(QC(n,t),e=t.name,t.type==="radio"&&e!=null){for(t=n;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<t.length;e++){var s=t[e];if(s!==n&&s.form===n.form){var i=Y1(s);if(!i)throw Error(Ve(90));d$(s),QC(s,i)}}}break;case"textarea":p$(n,t);break;case"select":e=t.value,e!=null&&Od(n,!!t.multiple,e,!1)}};b$=nE;S$=Ju;var S7={usingClientEntryPoint:!1,Events:[ug,Td,Y1,v$,w$,nE]},Cp={findFiberByHostInstance:Cu,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},_7={bundleType:Cp.bundleType,version:Cp.version,rendererPackageName:Cp.rendererPackageName,rendererConfig:Cp.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:yl.ReactCurrentDispatcher,findHostInstanceByFiber:function(n){return n=T$(n),n===null?null:n.stateNode},findFiberByHostInstance:Cp.findFiberByHostInstance||w7,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var uy=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!uy.isDisabled&&uy.supportsFiber)try{X1=uy.inject(_7),wa=uy}catch{}}Rr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=S7;Rr.createPortal=function(n,e){var t=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!cE(e))throw Error(Ve(200));return v7(n,e,null,t)};Rr.createRoot=function(n,e){if(!cE(n))throw Error(Ve(299));var t=!1,s="",i=iO;return e!=null&&(e.unstable_strictMode===!0&&(t=!0),e.identifierPrefix!==void 0&&(s=e.identifierPrefix),e.onRecoverableError!==void 0&&(i=e.onRecoverableError)),e=oE(n,1,!1,null,null,t,!1,s,i),n[ul]=e.current,Sm(n.nodeType===8?n.parentNode:n),new lE(e)};Rr.findDOMNode=function(n){if(n==null)return null;if(n.nodeType===1)return n;var e=n._reactInternals;if(e===void 0)throw typeof n.render=="function"?Error(Ve(188)):(n=Object.keys(n).join(","),Error(Ve(268,n)));return n=T$(e),n=n===null?null:n.stateNode,n};Rr.flushSync=function(n){return Ju(n)};Rr.hydrate=function(n,e,t){if(!rw(e))throw Error(Ve(200));return ow(null,n,e,!0,t)};Rr.hydrateRoot=function(n,e,t){if(!cE(n))throw Error(Ve(405));var s=t!=null&&t.hydratedSources||null,i=!1,r="",o=iO;if(t!=null&&(t.unstable_strictMode===!0&&(i=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(o=t.onRecoverableError)),e=sO(e,null,n,1,t!=null?t:null,i,!1,r,o),n[ul]=e.current,Sm(n),s)for(n=0;n<s.length;n++)t=s[n],i=t._getVersion,i=i(t._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[t,i]:e.mutableSourceEagerHydrationData.push(t,i);return new iw(e)};Rr.render=function(n,e,t){if(!rw(e))throw Error(Ve(200));return ow(null,n,e,!1,t)};Rr.unmountComponentAtNode=function(n){if(!rw(n))throw Error(Ve(40));return n._reactRootContainer?(Ju(function(){ow(null,null,n,!1,function(){n._reactRootContainer=null,n[ul]=null})}),!0):!1};Rr.unstable_batchedUpdates=nE;Rr.unstable_renderSubtreeIntoContainer=function(n,e,t,s){if(!rw(t))throw Error(Ve(200));if(n==null||n._reactInternals===void 0)throw Error(Ve(38));return ow(n,e,t,!1,s)};Rr.version="18.2.0-next-9e3b772b8-20220608";(function(n){function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}e(),n.exports=Rr})(s$);var T3=s$.exports;XC.createRoot=T3.createRoot,XC.hydrateRoot=T3.hydrateRoot;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C7=1e-7,T7=1e-4;class rO{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class uE{refCount(e){return Qi("refCount")}incRef(e){return Qi("incRef")}timerAvailable(){return!0}time(e){return Qi("time")}read(e){return Qi("read")}readSync(e){return Qi("readSync")}readToGPU(e,t){return Qi("readToGPU")}numDataIds(){return Qi("numDataIds")}disposeData(e,t){return Qi("disposeData")}write(e,t,s){return Qi("write")}move(e,t,s,i,r){return Qi("move")}createTensorFromGPUData(e,t,s){return Qi("createTensorFromGPUData")}memory(){return Qi("memory")}floatPrecision(){return Qi("floatPrecision")}epsilon(){return this.floatPrecision()===32?C7:T7}dispose(){return Qi("dispose")}}function Qi(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I7(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Zl(n,e,t)}function E7(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,Zl(n,t,s),Zl(e,t,s)}function Qu(n,e,t){return Math.max(n,Math.min(e,t))}function hE(n){return n%2===0?n:n+1}function Zl(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function M7(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function F(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function dE(n,e,t=""){F(pn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function oO(n){F(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Se(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function pn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function sf(n){return n%1===0}function z2(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function Gd(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function I3(n,e=i=>0,t,s){return new Promise((i,r)=>{let o=0;const a=()=>{if(n()){i();return}o++;const l=e(o);if(t!=null&&o>=t){r();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function aO(n,e){let t=1,s=-1;for(let r=0;r<n.length;++r)if(n[r]>=0)t*=n[r];else if(n[r]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);s=r}else if(n[r]<0)throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=n.slice();return i[s]=e/t,i}function Ut(n,e){const t=e.length;return n=n==null?e.map((s,i)=>i):[].concat(n),F(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),F(n.every(s=>sf(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Lc(n,e){const t=[],s=[],i=e!=null&&Array.isArray(e)&&e.length===0,r=e==null||i?null:Ut(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(r!=null){if(r[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(r[o]==null||r[o]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),r[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Ks(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function fs(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function k7(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function A7(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function lO(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function c1(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function N7(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function dg(n){return typeof n=="string"||n instanceof String}function R7(n){return typeof n=="boolean"}function B2(n){return typeof n=="number"}function fg(n){return Array.isArray(n)?fg(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":B2(n)?"float32":dg(n)?"string":R7(n)?"bool":"float32"}function U2(n){return!!(n&&n.constructor&&n.call&&n.apply)}function V2(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function mt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function cO(n,e,t,s=!1){const i=new Array;if(e.length===1){const r=e[0]*(s?2:1);for(let o=0;o<r;o++)i[o]=t[n+o]}else{const r=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<r;l++)i[l]=cO(n+l*a,o,t,s)}return i}function Oo(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((i,r)=>i*r)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return cO(0,n,e,t)}function D7(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function fE(n,e){const t=oi(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function oi(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function uO(n,e){const t=n.reduce((s,i)=>s*i,1);if(e==null||e==="float32")return Oo(n,new Float32Array(t));if(e==="int32")return Oo(n,new Int32Array(t));if(e==="bool")return Oo(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function vl(n){n.forEach(e=>{F(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Sa(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let i=0;i<n.length-1;++i)s+=t[i]*n[i];return s}function Mf(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(n/t[i]),n-=s[i]*t[i];return s[s.length-1]=n,s}function pE(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E3="tfjsflags";class L7{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=P7,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const i=this.urlFlags[e];xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(pE(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);E3 in e&&e[E3].split(",").forEach(s=>{const[i,r]=s.split(":");this.urlFlags[i]=F7(i,r)})}}function P7(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>($7(e,s[0],s[1]),s.join("="))),e}function $7(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function F7(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function xe(){return hO}let hO=null;function O7(n){hO=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let P_;function dO(){if(P_==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");P_=n}return P_}function z7(){const n=dO();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function mE(n,e){const t=z7();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const aw="Abs",pg="Acos",mg="Acosh",kf="Add",gE="AddN",xE="All",yE="Any",lw="ArgMax",cw="ArgMin",gg="Asin",xg="Asinh",yg="Atan",vg="Atanh",wg="Atan2",uw="AvgPool",vE="AvgPoolGrad",hw="AvgPool3D",wE="AvgPool3DGrad",dw="BatchMatMul",fw="BatchToSpaceND",bE="Bincount",B7="BroadcastTo",fO="BroadcastArgs",bg="Cast",Sg="Ceil",_g="ClipByValue",SE="Complex",pw="ComplexAbs",mw="Concat",gw="Conv2D",_E="Conv2DBackpropFilter",xw="Conv2DBackpropInput",yw="Conv3D",CE="Conv3DBackpropFilterV2",TE="Conv3DBackpropInputV2",Cg="Cos",Tg="Cosh",IE="Cumprod",vw="Cumsum",EE="CropAndResize",ME="DenseBincount",kE="DepthToSpace",ww="DepthwiseConv2dNative",AE="DepthwiseConv2dNativeBackpropFilter",NE="DepthwiseConv2dNativeBackpropInput",pO="Diag",bw="Dilation2D",W2="Dilation2DBackpropInput",G2="Dilation2DBackpropFilter",Ig="RealDiv",mO="Einsum",Eg="Elu",RE="EluGrad",Mg="Erf",Sw="Equal",kg="Exp",_w="ExpandDims",Ag="Expm1",DE="FFT",LE="Fill",PE="FlipLeftRight",Ng="Floor",Rg="FloorDiv",Cw="FusedBatchNorm",Tw="GatherV2",gO="GatherNd",Iw="Greater",Dg="GreaterEqual",Lg="Identity",$E="IFFT",FE="Imag",Pg="IsFinite",$g="IsInf",Fg="IsNan",Ew="LeakyRelu",Mw="Less",kw="LessEqual",xO="LinSpace",Og="Log",zg="Log1p",Aw="LogicalAnd",Nw="LogicalNot",Rw="LogicalOr",U7="LogSoftmax",Dw="LRN",OE="LRNGrad",Lw="Max",Bg="Maximum",Pw="MaxPool",zE="MaxPoolGrad",$w="MaxPool3D",BE="MaxPool3DGrad",yO="MaxPoolWithArgmax",Fw="Mean",Ow="Min",Ug="Minimum",zw="MirrorPad",Vg="Mod",vO="Multinomial",Wg="Multiply",Bw="Neg",Uw="NotEqual",UE="NonMaxSuppressionV3",VE="NonMaxSuppressionV4",WE="NonMaxSuppressionV5",Vw="OnesLike",Ww="OneHot",Gw="Pack",Hw="PadV2",Gg="Pow",Xw="Prelu",jw="Prod",wO="RaggedGather",bO="RaggedRange",SO="RaggedTensorToTensor",GE="Range",HE="Real",Hg="Reciprocal",Xg="Relu",qw="Reshape",Kw="ResizeNearestNeighbor",XE="ResizeNearestNeighborGrad",Yw="ResizeBilinear",jE="ResizeBilinearGrad",jg="Relu6",Zw="Reverse",qg="Round",Kg="Rsqrt",_O="ScatterNd",CO="SearchSorted",Jw="Select",Yg="Selu",Qw="Slice",Zg="Sin",Jg="Sinh",Qg="Sign",e0="Sigmoid",t0="Softplus",n0="Sqrt",eb="Sum",tb="SpaceToBatchND",nb="SplitV",sb="Softmax",TO="SparseFillEmptyRows",IO="SparseReshape",EO="SparseSegmentMean",MO="SparseSegmentSum",kO="SparseToDense",s0="SquaredDifference",qE="Square",KE="StridedSlice",AO="StringNGrams",NO="StringSplit",RO="StringToHashBucketFast",i0="Sub",r0="Tan",o0="Tanh",a0="Tile",YE="TopK",ZE="Transform",Hd="Transpose",JE="Unique",ib="Unpack",rb="UnsortedSegmentSum",ob="ZerosLike",l0="Step",V7="FromPixels",QE="RotateWithOffset",u1="_FusedMatMul",h1="FusedConv2D",DO="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(...n){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(...n)}function W7(...n){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d1=mE("kernelRegistry",()=>new Map),H2=mE("gradRegistry",()=>new Map);function M3(n,e){const t=PO(n,e);return d1.get(t)}function k3(n){return H2.get(n)}function A3(n){const e=d1.entries(),t=[];for(;;){const{done:s,value:i}=e.next();if(s)break;const[r,o]=i,[a]=r.split("_");a===n&&t.push(o)}return t}function LO(n){const{kernelName:e,backendName:t}=n,s=PO(e,t);d1.has(s)&&wr(`The kernel '${e}' for backend '${t}' is already registered`),d1.set(s,n)}function G7(n){const{kernelName:e}=n;H2.has(e)&&xe().getBool("DEBUG")&&wr(`Overriding the gradient for '${e}'`),H2.set(e,n)}function PO(n,e){return`${e}_${n}`}var X2=Nn,ro=null;try{ro=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Nn(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}Nn.prototype.__isLong__;Object.defineProperty(Nn.prototype,"__isLong__",{value:!0});function dr(n){return(n&&n.__isLong__)===!0}Nn.isLong=dr;var N3={},R3={};function wh(n,e){var t,s,i;return e?(n>>>=0,(i=0<=n&&n<256)&&(s=R3[n],s)?s:(t=Rn(n,(n|0)<0?-1:0,!0),i&&(R3[n]=t),t)):(n|=0,(i=-128<=n&&n<128)&&(s=N3[n],s)?s:(t=Rn(n,n<0?-1:0,!1),i&&(N3[n]=t),t))}Nn.fromInt=wh;function oo(n,e){if(isNaN(n))return e?Eu:ao;if(e){if(n<0)return Eu;if(n>=$O)return zO}else{if(n<=-L3)return ir;if(n+1>=L3)return OO}return n<0?oo(-n,e).neg():Rn(n%rf|0,n/rf|0,e)}Nn.fromNumber=oo;function Rn(n,e,t){return new Nn(n,e,t)}Nn.fromBits=Rn;var f1=Math.pow;function eM(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return ao;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var s;if((s=n.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return eM(n.substring(1),e,t).neg();for(var i=oo(f1(t,8)),r=ao,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var c=oo(f1(t,a));r=r.mul(c).add(oo(l))}else r=r.mul(i),r=r.add(oo(l))}return r.unsigned=e,r}Nn.fromString=eM;function qo(n,e){return typeof n=="number"?oo(n,e):typeof n=="string"?eM(n,e):Rn(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}Nn.fromValue=qo;var D3=1<<16,H7=1<<24,rf=D3*D3,$O=rf*rf,L3=$O/2,P3=wh(H7),ao=wh(0);Nn.ZERO=ao;var Eu=wh(0,!0);Nn.UZERO=Eu;var Rd=wh(1);Nn.ONE=Rd;var FO=wh(1,!0);Nn.UONE=FO;var j2=wh(-1);Nn.NEG_ONE=j2;var OO=Rn(-1,2147483647,!1);Nn.MAX_VALUE=OO;var zO=Rn(-1,-1,!0);Nn.MAX_UNSIGNED_VALUE=zO;var ir=Rn(0,-2147483648,!1);Nn.MIN_VALUE=ir;var Ze=Nn.prototype;Ze.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ze.toNumber=function(){return this.unsigned?(this.high>>>0)*rf+(this.low>>>0):this.high*rf+(this.low>>>0)};Ze.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ir)){var t=oo(e),s=this.div(t),i=s.mul(t).sub(this);return s.toString(e)+i.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var r=oo(f1(e,6),this.unsigned),o=this,a="";;){var l=o.div(r),c=o.sub(l.mul(r)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};Ze.getHighBits=function(){return this.high};Ze.getHighBitsUnsigned=function(){return this.high>>>0};Ze.getLowBits=function(){return this.low};Ze.getLowBitsUnsigned=function(){return this.low>>>0};Ze.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ir)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};Ze.isZero=function(){return this.high===0&&this.low===0};Ze.eqz=Ze.isZero;Ze.isNegative=function(){return!this.unsigned&&this.high<0};Ze.isPositive=function(){return this.unsigned||this.high>=0};Ze.isOdd=function(){return(this.low&1)===1};Ze.isEven=function(){return(this.low&1)===0};Ze.equals=function(e){return dr(e)||(e=qo(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Ze.eq=Ze.equals;Ze.notEquals=function(e){return!this.eq(e)};Ze.neq=Ze.notEquals;Ze.ne=Ze.notEquals;Ze.lessThan=function(e){return this.comp(e)<0};Ze.lt=Ze.lessThan;Ze.lessThanOrEqual=function(e){return this.comp(e)<=0};Ze.lte=Ze.lessThanOrEqual;Ze.le=Ze.lessThanOrEqual;Ze.greaterThan=function(e){return this.comp(e)>0};Ze.gt=Ze.greaterThan;Ze.greaterThanOrEqual=function(e){return this.comp(e)>=0};Ze.gte=Ze.greaterThanOrEqual;Ze.ge=Ze.greaterThanOrEqual;Ze.compare=function(e){if(dr(e)||(e=qo(e)),this.eq(e))return 0;var t=this.isNegative(),s=e.isNegative();return t&&!s?-1:!t&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Ze.comp=Ze.compare;Ze.negate=function(){return!this.unsigned&&this.eq(ir)?ir:this.not().add(Rd)};Ze.neg=Ze.negate;Ze.add=function(e){dr(e)||(e=qo(e));var t=this.high>>>16,s=this.high&65535,i=this.low>>>16,r=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,h=0,d=0,f=0;return f+=r+c,d+=f>>>16,f&=65535,d+=i+l,h+=d>>>16,d&=65535,h+=s+a,u+=h>>>16,h&=65535,u+=t+o,u&=65535,Rn(d<<16|f,u<<16|h,this.unsigned)};Ze.subtract=function(e){return dr(e)||(e=qo(e)),this.add(e.neg())};Ze.sub=Ze.subtract;Ze.multiply=function(e){if(this.isZero())return ao;if(dr(e)||(e=qo(e)),ro){var t=ro.mul(this.low,this.high,e.low,e.high);return Rn(t,ro.get_high(),this.unsigned)}if(e.isZero())return ao;if(this.eq(ir))return e.isOdd()?ir:ao;if(e.eq(ir))return this.isOdd()?ir:ao;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(P3)&&e.lt(P3))return oo(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,i=this.high&65535,r=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,h=0,d=0,f=0,m=0;return m+=o*u,f+=m>>>16,m&=65535,f+=r*u,d+=f>>>16,f&=65535,f+=o*c,d+=f>>>16,f&=65535,d+=i*u,h+=d>>>16,d&=65535,d+=r*c,h+=d>>>16,d&=65535,d+=o*l,h+=d>>>16,d&=65535,h+=s*u+i*c+r*l+o*a,h&=65535,Rn(f<<16|m,h<<16|d,this.unsigned)};Ze.mul=Ze.multiply;Ze.divide=function(e){if(dr(e)||(e=qo(e)),e.isZero())throw Error("division by zero");if(ro){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?ro.div_u:ro.div_s)(this.low,this.high,e.low,e.high);return Rn(t,ro.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Eu:ao;var s,i,r;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Eu;if(e.gt(this.shru(1)))return FO;r=Eu}else{if(this.eq(ir)){if(e.eq(Rd)||e.eq(j2))return ir;if(e.eq(ir))return Rd;var o=this.shr(1);return s=o.div(e).shl(1),s.eq(ao)?e.isNegative()?Rd:j2:(i=this.sub(e.mul(s)),r=s.add(i.div(e)),r)}else if(e.eq(ir))return this.unsigned?Eu:ao;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();r=ao}for(i=this;i.gte(e);){s=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(s)/Math.LN2),l=a<=48?1:f1(2,a-48),c=oo(s),u=c.mul(e);u.isNegative()||u.gt(i);)s-=l,c=oo(s,this.unsigned),u=c.mul(e);c.isZero()&&(c=Rd),r=r.add(c),i=i.sub(u)}return r};Ze.div=Ze.divide;Ze.modulo=function(e){if(dr(e)||(e=qo(e)),ro){var t=(this.unsigned?ro.rem_u:ro.rem_s)(this.low,this.high,e.low,e.high);return Rn(t,ro.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Ze.mod=Ze.modulo;Ze.rem=Ze.modulo;Ze.not=function(){return Rn(~this.low,~this.high,this.unsigned)};Ze.and=function(e){return dr(e)||(e=qo(e)),Rn(this.low&e.low,this.high&e.high,this.unsigned)};Ze.or=function(e){return dr(e)||(e=qo(e)),Rn(this.low|e.low,this.high|e.high,this.unsigned)};Ze.xor=function(e){return dr(e)||(e=qo(e)),Rn(this.low^e.low,this.high^e.high,this.unsigned)};Ze.shiftLeft=function(e){return dr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Rn(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Rn(0,this.low<<e-32,this.unsigned)};Ze.shl=Ze.shiftLeft;Ze.shiftRight=function(e){return dr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Rn(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Rn(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Ze.shr=Ze.shiftRight;Ze.shiftRightUnsigned=function(e){if(dr(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var s=this.low;return Rn(s>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Rn(t,0,this.unsigned):Rn(t>>>e-32,0,this.unsigned)};Ze.shru=Ze.shiftRightUnsigned;Ze.shr_u=Ze.shiftRightUnsigned;Ze.toSigned=function(){return this.unsigned?Rn(this.low,this.high,!1):this};Ze.toUnsigned=function(){return this.unsigned?this:Rn(this.low,this.high,!0)};Ze.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Ze.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Ze.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Nn.fromBytes=function(e,t,s){return s?Nn.fromBytesLE(e,t):Nn.fromBytesBE(e,t)};Nn.fromBytesLE=function(e,t){return new Nn(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Nn.fromBytesBE=function(e,t){return new Nn(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const X7=i6({__proto__:null,default:X2},[X2]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vu=X2||X7;function ab(n){return vu.fromString(n,!0,16)}const BO=ab("c3a5c85c97cb3127"),pu=ab("b492b66fbe98f273"),wi=ab("9ae16a3b2f90404f");function q2(n){return n.xor(n.shru(47))}function UO(n,e,t){const s=n.slice(e,e+t);return vu.fromBytes(Array.from(s),!0,!0)}function Sn(n,e){return UO(n,e,8)}function $3(n,e){return UO(n,e,4)}function Ns(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function dc(n,e,t=ab("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let i=e.xor(s).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function j7(n,e,t,s,i,r){i=i.add(n),r=Ns(r.add(i).add(s),21);const o=i;return i=i.add(e),i=i.add(t),r=r.add(Ns(i,44)),[i.add(s),r.add(o)]}function hy(n,e,t,s){return j7(Sn(n,e),Sn(n,e+8),Sn(n,e+16),Sn(n,e+24),t,s)}function q7(n,e=n.length){if(e>=8){const t=wi.add(e*2),s=Sn(n,0).add(wi),i=Sn(n,e-8),r=Ns(i,37).mul(t).add(s),o=Ns(s,25).add(i).mul(t);return dc(r,o,t)}if(e>=4){const t=wi.add(e*2),s=$3(n,0);return dc(s.shl(3).add(e),$3(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],i=n[e-1],r=t+(s<<8),o=e+(i<<2);return q2(wi.mul(r).xor(BO.mul(o))).mul(wi)}return wi}function K7(n,e=n.length){const t=wi.add(e*2),s=Sn(n,0).mul(pu),i=Sn(n,8),r=Sn(n,e-8).mul(t),o=Sn(n,e-16).mul(wi);return dc(Ns(s.add(i),43).add(Ns(r,30)).add(o),s.add(Ns(i.add(wi),18)).add(r),t)}function Y7(n,e=n.length){const t=wi.add(e*2),s=Sn(n,0).mul(wi),i=Sn(n,8),r=Sn(n,e-8).mul(t),o=Sn(n,e-16).mul(wi),a=Ns(s.add(i),43).add(Ns(r,30)).add(o),l=dc(a,s.add(Ns(i.add(wi),18)).add(r),t),c=Sn(n,16).mul(t),u=Sn(n,24),h=a.add(Sn(n,e-32)).mul(t),d=l.add(Sn(n,e-24)).mul(t);return dc(Ns(c.add(u),43).add(Ns(h,30)).add(d),c.add(Ns(u.add(s),18)).add(h),t)}function Z7(n,e=n.length){const t=vu.fromNumber(81,!0);if(e<=32)return e<=16?q7(n,e):K7(n,e);if(e<=64)return Y7(n,e);let s=t,i=t.mul(pu).add(113),r=q2(i.mul(wi).add(113)).mul(wi),o=[vu.UZERO,vu.UZERO],a=[vu.UZERO,vu.UZERO];s=s.mul(wi).add(Sn(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do s=Ns(s.add(i).add(o[0]).add(Sn(n,l+8)),37).mul(pu),i=Ns(i.add(o[1]).add(Sn(n,l+48)),42).mul(pu),s=s.xor(a[1]),i=i.add(o[0]).add(Sn(n,l+40)),r=Ns(r.add(a[0]),33).mul(pu),o=hy(n,l,o[1].mul(pu),s.add(a[0])),a=hy(n,l+32,r.add(a[1]),i.add(Sn(n,l+16))),[r,s]=[s,r],l+=64;while(l!==c);const h=pu.add(r.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=Ns(s.add(i).add(o[0]).add(Sn(n,l+8)),37).mul(h),i=Ns(i.add(o[1]).add(Sn(n,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),i=i.add(o[0].mul(9).add(Sn(n,l+40))),r=Ns(r.add(a[0]),33).mul(h),o=hy(n,l,o[1].mul(h),s.add(a[0])),a=hy(n,l+32,r.add(a[1]),i.add(Sn(n,l+16))),[r,s]=[s,r],dc(dc(o[0],a[0],h).add(q2(i).mul(BO)).add(r),dc(o[1],a[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pc(n,e){return e==="string"?fc(n):bh([n],e)}function J7(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function bh(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=eh(n)),xe().getBool("DEBUG")&&k7(n,e),J7(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Pi(){return xe().platform.now()}function fc(n,e="utf-8"){return e=e||"utf-8",xe().platform.encode(n,e)}function wc(n,e="utf-8"){return e=e||"utf-8",xe().platform.decode(n,e)}function Wo(n){return xe().platform.isTypedArray(n)}function eh(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||pE(n)||n==null||Wo(n)&&t)e.push(n);else if(Array.isArray(n)||Wo(n))for(let s=0;s<n.length;++s)eh(n[s],e,t);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)eh(n[i],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q7{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new t9)}profileKernel(e,t,s){let i;const r=()=>{i=s()};let o;const a=Pi();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const c of i)c.dataSync();o=Promise.resolve({kernelMs:Pi()-a})}if(xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const u=i[c];u.data().then(h=>{e9(h,u.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:i,inputs:r,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),i,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],r,l[2])})})}}function e9(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class t9{logKernelProfile(e,t,s,i,r,o){const a=typeof i=="number"?Gd(`${i}ms`,9):i.error,l=Gd(e,25),c=t.rank,u=t.size,h=Gd(t.shape.toString(),14);let d="";for(const f in r){const m=r[f];if(m!=null){const x=m.shape||t.shape,y=x.length;d+=`${f}: ${y}D ${y>0?x:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n9(n,e,t){const s={},i={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const d=u[h];let f=!1;for(let m=0;m<e.length;m++)if(s[d.id]){c.outputs.forEach(x=>s[x.id]=!0),f=!0,i[c.id]=!0;break}if(f)break}}const r={};r[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(r[c.outputs[h].id]){for(const d in u)r[u[d].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&o[c.id]){const u={};for(const d in c.inputs){const f=c.inputs[d];s[f.id]&&(u[d]=f)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function s9(n,e,t,s){for(let i=e.length-1;i>=0;i--){const r=e[i],o=[];if(r.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const a=r.gradient(o);for(const l in r.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=r.inputs[l];if(!pn(c.shape,u.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=s(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F3=20,Tp=3,$_=7;function i9(n,e,t,s){const i=mt(e),r=r9(n,e,t,i),o=e.length,a=kv(n,e,t,i,r),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function r9(n,e,t,s){const i=Se(e),r=s[s.length-1],o=new Array(r).fill(0),a=e.length,l=t==="complex64"?Hp(n):n;if(a>1)for(let c=0;c<i/r;c++){const u=c*r;for(let h=0;h<r;h++)o[h]=Math.max(o[h],Gp(l[u+h],0,t).length)}return o}function Gp(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed($_))} + ${parseFloat(n[1].toFixed($_))}j`:dg(n)?s=`'${n}'`:t==="bool"?s=VO(n):s=parseFloat(n.toFixed($_)).toString(),Gd(s,e)}function VO(n){return n===0?"false":"true"}function kv(n,e,t,s,i,r=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const x=Hp(n);return[Gp(x[0],0,t)]}return t==="bool"?[VO(n[0])]:[n[0].toString()]}if(l===1){if(a>F3){const y=Tp*o;let v=Array.from(n.slice(0,y)),w=Array.from(n.slice((a-Tp)*o,a*o));return t==="complex64"&&(v=Hp(v),w=Hp(w)),["["+v.map((b,S)=>Gp(b,i[S],t)).join(", ")+", ..., "+w.map((b,S)=>Gp(b,i[a-Tp+S],t)).join(", ")+"]"]}return["["+(t==="complex64"?Hp(n):Array.from(n)).map((y,v)=>Gp(y,i[v],t)).join(", ")+"]"]}const c=e.slice(1),u=s.slice(1),h=s[0]*o,d=[];if(a>F3){for(let x=0;x<Tp;x++){const y=x*h,v=y+h;d.push(...kv(n.slice(y,v),c,t,u,i,!1))}d.push("...");for(let x=a-Tp;x<a;x++){const y=x*h,v=y+h;d.push(...kv(n.slice(y,v),c,t,u,i,x===a-1))}}else for(let x=0;x<a;x++){const y=x*h,v=y+h;d.push(...kv(n.slice(y,v),c,t,u,i,x===a-1))}const f=l===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let x=1;x<d.length-1;x++)d[x]=" "+d[x]+f;let m=`,
`;for(let x=2;x<l;x++)m+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(r?"":m),d}function Hp(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ii{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=Se(e),s!=null){const i=s.length;F(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||fs(t,this.size),this.strides=mt(e)}set(e,...t){t.length===0&&(t=[0]),F(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let s=e[e.length-1];for(let i=0;i<e.length-1;++i)s+=this.strides[i]*e[i];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Do().makeTensor(this.values,this.shape,this.dtype)}}let Do=null,gd=null;function o9(n){Do=n}function a9(n){gd=n}class ts{constructor(e,t,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Se(e),this.strides=mt(e),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return gd.buffer(this.shape,this.dtype,e)}bufferSync(){return gd.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Oo(this.shape,e,this.dtype==="complex64")}arraySync(){return Oo(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Do().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>wc(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Do().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Do().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>wc(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Do().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Do().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return gd.print(this,e)}clone(){return this.throwIfDisposed(),gd.clone(this)}toString(e=!1){const t=this.dataSync();return i9(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),gd.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Do().makeVariable(this,e,t,s)}}Object.defineProperty(ts,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function we(){return mE("Tensor",()=>ts)}we();class p1 extends ts{constructor(e,t,s,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!pn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Do().disposeTensor(this),this.dataId=e.dataId,Do().incRef(this,null)}dispose(){Do().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(p1,Symbol.hasInstance,{value:n=>n instanceof ts&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var O3;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(O3||(O3={}));var K2;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(K2||(K2={}));var Y2;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Y2||(Y2={}));var Z2;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Z2||(Z2={}));var J2;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(J2||(J2={}));const l9={float32:Z2,int32:K2,bool:Y2,complex64:J2};function lr(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return l9[n][e]}function tM(n){return lr(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ss(n,e){if(n.dtype===e.dtype)return[n,e];const t=lr(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function WO(n){const e=[];return GO(n,e,new Set),e}function GO(n,e,t){if(n==null)return;if(n instanceof ts){e.push(n);return}if(!c9(n))return;const s=n;for(const i in s){const r=s[i];t.has(r)||(t.add(r),GO(r,e,t))}}function c9(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(n){return n.kernelName!=null}class z3{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class of{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new z3}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(wr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Q7(this.backendInstance),!0}setupRegisteredKernels(){A3(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){A3(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof uE)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,r=s.then(o=>i<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,wr(`Initialization of backend ${e} failed`),wr(o.stack||o.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return wr(`Initialization of backend ${e} failed`),wr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:i,asyncInit:r}=this.initializeBackend(s);if(r||i)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),i=s.backend,r=this.readSync(t),o=i.refCount(t);i.disposeData(t,!0),s.backend=e,e.move(t,r,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,s){e();try{const i=s();return t(),i}catch(i){throw t(),i}}nextTensorId(){return of.nextTensorId++}nextVariableId(){return of.nextVariableId++}clone(e){const t=se.runKernel(Lg,{x:e}),s={x:e},i=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return se.runKernel(bg,l,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[t],i,r,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(M3(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const i=this.backend.numDataIds();let r=0;s.forEach(l=>{r+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=i-t-r-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const i=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=F_(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(F_(e)){const{kernelName:m,inputs:x,attrs:y}=e;this.backendName==null&&this.backend;const v=M3(m,this.backendName);F(v!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),a=()=>{const w=this.backend.numDataIds();l=v.kernelFunc({inputs:x,attrs:y,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,w,b);const S=b.map(C=>C.rank!=null?C:this.makeTensorFromTensorInfo(C));if(i){const C=this.getTensorsForGradient(m,x,S);s=this.saveTensorsForBackwardMode(C)}return S}}else{const{forwardFunc:m}=e,x=y=>{!i||(s=y.map(v=>this.keep(this.clone(v))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,x));const v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,v),v}}const{inputs:u,attrs:h}=e,d=F_(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(f=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),i&&this.addTapeNode(c,u,t,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(m=>u[m]!=null?u[m].shape:null),outputShapes:t.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const i=k3(e);if(i!=null){const r=i.inputsToSave||[],o=i.outputsToSave||[];let a;i.saveAllInputs?(F(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=r.map(c=>t[c]);const l=s.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,s,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let r=e;s==="string"&&dg(e[0])&&(r=e.map(l=>fc(l)));const o=i.write(r,t,s),a=new ts(t,s,o,this.nextTensorId());if(this.trackTensor(a,i),s==="string"){const l=this.state.tensorInfo.get(o),c=N7(r);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,s,i){s=s||"float32";const r={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:i,dtype:r}=e,o=new ts(i,r,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const r=new p1(e,t,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*c1(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof p1||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*c1(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,i,r,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:r},l=k3(e);l!=null&&(i=l.gradFunc),i!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const d=s[h],f=oi(d.size,d.dtype);return this.makeTensor(f,d.shape,d.dtype)}return u}),i(c.length>1?c:c[0],r,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=WO(e),s=new Set(t.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const o=this.state.activeScope.track[r];!o.kept&&!s.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(e,t,s,i=!1){if(F(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));F(r instanceof ts,()=>"The result y returned by f() must be a tensor.");const o=n9(this.state.activeTape,t,r);if(!i&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[r.id]=s==null?u9(r.shape):s,s9(a,o,c=>this.tidy(c),h9);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(e){return F(U2(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{F(t.every(a=>a instanceof ts),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};t.forEach((a,l)=>{i[l]=a});const r=(a,l)=>(s=e(...t,l),F(s.value instanceof ts,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),F(U2(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),u=Array.isArray(c)?c:[c];F(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),F(u.every(d=>d instanceof ts),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((d,f)=>{h[f]=()=>d}),h};return this.runKernelFunc({forwardFunc:r,backwardsFunc:o,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Pi(),s=await this.backend.time(e);return s.wallMs=Pi()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new z3;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}of.nextTensorId=0;of.nextVariableId=0;function u9(n){const e=fE(Se(n),"float32");return se.makeTensor(e,n,"float32")}function HO(){const n=dO();if(n._tfengine==null){const e=new L7(n);n._tfengine=new of(e)}return O7(n._tfengine.ENV),o9(()=>n._tfengine),n._tfengine}const se=HO();function h9(n,e){const t={a:n,b:e};return se.runKernel(kf,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d9(){return typeof navigator<"u"&&navigator!=null}function XO(n){if(n||d9()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function jO(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ar=xe();Ar.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ar.registerFlag("IS_BROWSER",()=>jO());Ar.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Ar.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ar.registerFlag("PROD",()=>!1);Ar.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ar.getBool("DEBUG"));Ar.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ar.registerFlag("IS_TEST",()=>!1);Ar.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Ar.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Ar.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Ar.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lb(n,e){let t=n;if(Wo(n))return e==="string"?[]:[n.length];if(typeof n=="object"){if("texture"in n){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if("buffer"in n&&!(n.buffer instanceof ArrayBuffer))return[n.buffer.size/(e==null?4:c1(e))]}if(!Array.isArray(n))return[];const i=[];for(;Array.isArray(t)||Wo(t)&&e!=="string";)i.push(t.length),t=t[0];return Array.isArray(n)&&xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&qO(n,i,[]),i}function qO(n,e,t){if(t=t||[],!Array.isArray(n)&&!Wo(n)){F(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}F(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),F(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let i=0;i<n.length;++i)qO(n[i],s,t.concat(i))}function B3(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function Z(n,e,t,s="numeric"){if(n instanceof ts)return B3(s,n.dtype,e,t),n;let i=fg(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),B3(s,i,e,t),n==null||!Wo(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const r=lb(n,i);!Wo(n)&&!Array.isArray(n)&&(n=[n]);const a=i!=="string"?bh(n,i):eh(n,[],!0);return se.makeTensor(a,r,i)}function KO(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((r,o)=>Z(r,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f9="__op";function ce(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+f9;const i=(...r)=>{se.startScope(t);try{const o=s(...r);return pE(o)&&console.error("Cannot return a Promise inside of tidy."),se.endScope(o),o}catch(o){throw se.endScope(null),o}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p9(n,e){const t=Z(n,"real","complex"),s=Z(e,"imag","complex");dE(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:t,imag:s};return se.runKernel(SE,i)}const af=ce({complex_:p9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n,e,t,s){if(s==null)s=fg(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof n=="object"&&("texture"in n||"buffer"in n&&!(n.buffer instanceof ArrayBuffer))){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return se.backend.createTensorFromGPUData(n,e||t,s)}if(!Wo(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){vl(e);const i=Se(e),r=Se(t);F(i===r,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${r}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Se(e.slice(o)):!0;F(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Wo(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?bh(n,s):eh(n,[],!0),se.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YO(n,e,t){const s=lb(n,t);return cb(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3=4;async function V3(n,e){const t=[],s=[],i=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<i.length;++o){const a=i[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const d=await l.bytes(),f=d.reduce((y,v)=>y+v.length,0)+U3*d.length,m=new Uint8Array(f);let x=0;for(let y=0;y<d.length;y++){const v=d[y],w=new Uint8Array(new Uint32Array([v.length]).buffer);m.set(w,x),x+=U3,m.set(v,x),x+=v.length}h(m)});s.push(u)}else s.push(l.data());e!=null&&(c.group=e),t.push(c)}const r=await Promise.all(s);return{data:m9(r),specs:t}}function m9(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(r=>{if(e+=r.byteLength,t.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const s=new Uint8Array(e);let i=0;return t.forEach(r=>{s.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),s.buffer}const nM=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function W3(n){return nM?Buffer.byteLength(n):new Blob([n]).size}function g9(n){if(nM)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function x9(n){if(nM){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function ZO(n){if(n.length===1)return n[0];let e=0;n.forEach(i=>{e+=i.byteLength});const t=new Uint8Array(e);let s=0;return n.forEach(i=>{t.set(new Uint8Array(i),s),s+=i.byteLength}),t.buffer}function JO(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function y9(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function v9(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),y9(n,t,s)}function ub(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:W3(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:W3(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function w9(n){const e=[];for(const t of n)e.push(...t.weights);return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ks{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ks.instance==null&&(ks.instance=new ks),ks.instance}static registerSaveRouter(e){ks.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ks.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ks.getHandlers(e,"save")}static getLoadHandlers(e,t){return ks.getHandlers(e,"load",t)}static getHandlers(e,t,s){const i=[];return(t==="load"?ks.getInstance().loadRouters:ks.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&i.push(a)}),i}}const b9=n=>ks.getSaveHandlers(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q2="tensorflowjs",eT=1,Mu="models_store",ec="model_info_store";function QO(){if(!xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function tT(n){const e=n.result;e.createObjectStore(Mu,{keyPath:"modelPath"}),e.createObjectStore(ec,{keyPath:"modelPath"})}class th{constructor(e){if(this.indexedDB=QO(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,i)=>{const r=this.indexedDB.open(Q2,eT);r.onupgradeneeded=()=>tT(r),r.onsuccess=()=>{const o=r.result;if(t==null){const a=o.transaction(Mu,"readonly"),c=a.objectStore(Mu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=u=>(o.close(),i(c.error)),a.oncomplete=()=>o.close()}else{const a=ub(t),l=o.transaction(ec,"readwrite");let c=l.objectStore(ec);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let h;u.onsuccess=()=>{h=o.transaction(Mu,"readwrite");const f=h.objectStore(Mu).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});f.onsuccess=()=>s({modelArtifactsInfo:a}),f.onerror=m=>{c=l.objectStore(ec);const x=c.delete(this.modelPath);x.onsuccess=()=>(o.close(),i(f.error)),x.onerror=y=>(o.close(),i(f.error))}},u.onerror=d=>(o.close(),i(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},r.onerror=o=>i(r.error)})}}th.URL_SCHEME="indexeddb://";const ez=n=>xe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(th.URL_SCHEME)?S9(n.slice(th.URL_SCHEME.length)):null;ks.registerSaveRouter(ez);ks.registerLoadRouter(ez);function S9(n){return new th(n)}function _9(n){return n.startsWith(th.URL_SCHEME)?n.slice(th.URL_SCHEME.length):n}class C9{constructor(){this.indexedDB=QO()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(Q2,eT);s.onupgradeneeded=()=>tT(s),s.onsuccess=()=>{const i=s.result,r=i.transaction(ec,"readonly"),a=r.objectStore(ec).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(i.close(),t(a.error)),r.oncomplete=()=>i.close()},s.onerror=i=>t(s.error)})}async removeModel(e){return e=_9(e),new Promise((t,s)=>{const i=this.indexedDB.open(Q2,eT);i.onupgradeneeded=()=>tT(i),i.onsuccess=()=>{const r=i.result,o=r.transaction(ec,"readwrite"),a=o.objectStore(ec),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return r.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=r.transaction(Mu,"readwrite");const f=c.objectStore(Mu).delete(e);f.onsuccess=()=>t(l.result.modelArtifactsInfo),f.onerror=m=>s(l.error)};u.onsuccess=h,u.onerror=d=>(h(),r.close(),s(l.error))}},l.onerror=u=>(r.close(),s(l.error)),o.oncomplete=()=>{c==null?r.close():c.oncomplete=()=>r.close()}},i.onerror=r=>s(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qa="/",xd="tensorflowjs_models",tz="info",T9="model_topology",I9="weight_specs",E9="weight_data",M9="model_metadata";function nz(n){return{info:[xd,n,tz].join(Qa),topology:[xd,n,T9].join(Qa),weightSpecs:[xd,n,I9].join(Qa),weightData:[xd,n,E9].join(Qa),modelMetadata:[xd,n,M9].join(Qa)}}function sz(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function k9(n){const e=n.split(Qa);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Qa)}function A9(n){return n.startsWith(nh.URL_SCHEME)?n.slice(nh.URL_SCHEME.length):n}class nh{constructor(e){if(!xe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=nz(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),i=ub(e);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,g9(e.weightData));const r={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r)),{modelArtifactsInfo:i}}catch{throw sz(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const a=JSON.parse(r);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=x9(o),t}}nh.URL_SCHEME="localstorage://";const iz=n=>xe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(nh.URL_SCHEME)?N9(n.slice(nh.URL_SCHEME.length)):null;ks.registerSaveRouter(iz);ks.registerLoadRouter(iz);function N9(n){return new nh(n)}class R9{constructor(){F(xe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),F(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=xd+Qa,s=Qa+tz;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(s)){const o=k9(r);e[o]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=A9(e);const t=nz(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return sz(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G3="://";class ha{constructor(){this.managers={}}static getInstance(){return ha.instance==null&&(ha.instance=new ha),ha.instance}static registerManager(e,t){F(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(G3)&&(e=e.slice(0,e.indexOf(G3))),F(e.length>0,()=>"scheme must not be an empty string.");const s=ha.getInstance();F(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=ha.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ha.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D9{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!xe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}}if(xe().get("IS_BROWSER")){xe().setPlatform("browser",new D9);try{ha.registerManager(nh.URL_SCHEME,new R9)}catch{}try{ha.registerManager(th.URL_SCHEME,new C9)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L9={importFetch:()=>require("node-fetch")};let O_;class P9{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return xe().global.fetch!=null?xe().global.fetch(e,t):(O_==null&&(O_=L9.importFetch()),O_(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}xe().get("IS_NODE")&&!xe().get("IS_BROWSER")&&xe().setPlatform("node",new P9);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zt(n,e="float32",t){return e=e||"float32",vl(n),new ii(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $9(n,e){const t=Z(n,"x","cast");if(!A7(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},i={dtype:e};return se.runKernel(bg,s,i)}const it=ce({cast_:$9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F9(n){const t={x:Z(n,"x","clone","string_or_numeric")};return se.runKernel(Lg,t)}const Ou=ce({clone_:F9});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O9(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */HO();const z9={buffer:zt,cast:it,clone:Ou,print:O9};a9(z9);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua(){return se}function nT(){return se.memory()}function de(n,e){return se.tidy(n,e)}function Gt(n){WO(n).forEach(t=>t.dispose())}function _a(n){return se.keep(n)}function rz(n,e,t=1){return se.registerBackend(n,e,t)}function B9(){return se.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U9(n,e){let t=Z(n,"a","add"),s=Z(e,"b","add");[t,s]=ss(t,s);const i={a:t,b:s};return se.runKernel(kf,i)}const Ue=ce({add_:U9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V9(n,e){let t=Z(n,"a","floorDiv"),s=Z(e,"b","floorDiv");[t,s]=ss(t,s);const i={a:t,b:s};return se.runKernel(Rg,i)}const oz=ce({floorDiv_:V9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W9(n,e){let t=Z(n,"a","div"),s=Z(e,"b","div");if([t,s]=ss(t,s),t.dtype==="int32"&&s.dtype==="int32")return oz(t,s);const i={a:t,b:s},r={};return se.runKernel(Ig,i,r)}const bt=ce({div_:W9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G9(n,e){let t=Z(n,"a","mul"),s=Z(e,"b","mul");[t,s]=ss(t,s);const i={a:t,b:s};return se.runKernel(Wg,i)}const ne=ce({mul_:G9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H9(n){const e=Z(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return se.runKernel(pw,t)}else{const t={x:e};return se.runKernel(aw,t)}}const yi=ce({abs_:H9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X9(n){const t={x:Z(n,"x","acos")};return se.runKernel(pg,t)}const j9=ce({acos_:X9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q9(n){const t={x:Z(n,"x","acosh")};return se.runKernel(mg,t)}const K9=ce({acosh_:q9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y9(n,e=null,t=!1){const i={x:Z(n,"x","all","bool")},r={axis:e,keepDims:t};return se.runKernel(xE,i,r)}const az=ce({all_:Y9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z9(n,e=null,t=!1){const i={x:Z(n,"x","any","bool")},r={axis:e,keepDims:t};return se.runKernel(yE,i,r)}const sT=ce({any_:Z9});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J9(n,e=0){const s={x:Z(n,"x","argMax")},i={axis:e};return se.runKernel(lw,s,i)}const Nm=ce({argMax_:J9});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q9(n,e=0){const s={x:Z(n,"x","argMin")},i={axis:e};return se.runKernel(cw,s,i)}const eX=ce({argMin_:Q9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tX(n){const t={x:Z(n,"x","asin")};return se.runKernel(gg,t)}const nX=ce({asin_:tX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sX(n){const t={x:Z(n,"x","asinh")};return se.runKernel(xg,t)}const iX=ce({asinh_:sX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rX(n){const t={x:Z(n,"x","atan")};return se.runKernel(yg,t)}const oX=ce({atan_:rX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aX(n,e){let t=Z(n,"a","atan2"),s=Z(e,"b","atan2");[t,s]=ss(t,s);const i={a:t,b:s};return se.runKernel(wg,i)}const lX=ce({atan2_:aX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cX(n){const t={x:Z(n,"x","atanh")};return se.runKernel(vg,t)}const uX=ce({atanh_:cX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0(n,e,t,s,i="NHWC",r){const o=n[3],a=[...e,o],l=bl(i);return Ys(n,a,t,r,s,null,null,l)}function go(n,e,t,s,i,r,o="channelsLast"){const[a,l]=Rm(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ys(n,c,t,s,i,r,!1,o)}function wl(n,e,t,s,i,r,o="NDHWC"){const[a,l,c]=iT(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return $c(n,u,t,s,i,!1,h,r)}function Ys(n,e,t,s,i,r,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,f,,m]=e,[x,y]=Rm(t),[v,w]=Rm(s),b=Xd(d,v),S=Xd(f,w),{padInfo:C,outHeight:E,outWidth:k}=fX(i,c,u,x,y,b,S,r,a),I=o?m*h:m;let A;return a==="channelsFirst"?A=[l,I,E,k]:a==="channelsLast"&&(A=[l,E,k,I]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:E,outWidth:k,outChannels:I,padInfo:C,strideHeight:x,strideWidth:y,filterHeight:d,filterWidth:f,effectiveFilterHeight:b,effectiveFilterWidth:S,dilationHeight:v,dilationWidth:w,inShape:n,outShape:A,filterShape:e}}function $c(n,e,t,s,i,r=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,d]=n;else if(o==="channelsFirst")[l,d,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[f,m,x,,y]=e,[v,w,b]=iT(t),[S,C,E]=iT(s),k=Xd(f,S),I=Xd(m,C),A=Xd(x,E),{padInfo:N,outDepth:L,outHeight:V,outWidth:O}=pX(i,c,u,h,v,w,b,k,I,A,a),P=r?y*d:y;let W;return o==="channelsFirst"?W=[l,P,L,V,O]:o==="channelsLast"&&(W=[l,L,V,O,P]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:L,outHeight:V,outWidth:O,outChannels:P,padInfo:N,strideDepth:v,strideHeight:w,strideWidth:b,filterDepth:f,filterHeight:m,filterWidth:x,effectiveFilterDepth:k,effectiveFilterHeight:I,effectiveFilterWidth:A,dilationDepth:S,dilationHeight:C,dilationWidth:E,inShape:n,outShape:W,filterShape:e}}function hX(n,e,t,s,i){s==null&&(s=sM(n,e,t));const r=n[0],o=n[1],a=Dm((r-e+2*s)/t+1,i),l=Dm((o-e+2*s)/t+1,i);return[a,l]}function dX(n,e,t,s,i,r){i==null&&(i=sM(n,e[0],s[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*i>=e[a]&&(o[a]=Dm((n[a]-e[a]+2*i)/s[a]+1,r));return o}function sM(n,e,t,s=1){const i=Xd(e,s);return Math.floor((n[0]*(t-1)-t+i)/2)}function Rm(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function iT(n){return typeof n=="number"?[n,n,n]:n}function Xd(n,e){return e<=1?n:n+(n-1)*(e-1)}function fX(n,e,t,s,i,r,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const f=hX([e,t],r,s,n,a);u=f[0],h=f[1]}else if(n==="same"){u=Math.ceil(e/s),h=Math.ceil(t/i);const d=Math.max(0,(u-1)*s+r-e),f=Math.max(0,(h-1)*i+o-t),m=Math.floor(d/2),x=d-m,y=Math.floor(f/2),v=f-y;c={top:m,bottom:x,left:y,right:v,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-r+1)/s),h=Math.ceil((t-o+1)/i);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],f=l==="channelsLast"?n[1][1]:n[2][1],m=l==="channelsLast"?n[2][0]:n[3][0],x=l==="channelsLast"?n[2][1]:n[3][1];c={top:d,bottom:f,left:m,right:x,type:d===0&&f===0&&m===0&&x===0?"VALID":"EXPLICIT"},u=Dm((e-r+d+f)/s+1,a),h=Dm((t-o+m+x)/i+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function pX(n,e,t,s,i,r,o,a,l,c,u){let h,d,f,m;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=dX([e,t,s,1],[a,l,c],1,[i,r,o],n,u);d=y[0],f=y[1],m=y[2]}else if(n==="same"){d=Math.ceil(e/i),f=Math.ceil(t/r),m=Math.ceil(s/o);const x=(d-1)*i+a-e,y=(f-1)*r+l-t,v=(m-1)*o+c-s,w=Math.floor(x/2),b=x-w,S=Math.floor(y/2),C=y-S,E=Math.floor(v/2),k=v-E;h={top:S,bottom:C,left:E,right:k,front:w,back:b,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:f,outWidth:m}}function Dm(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function sh(n){const[e,t,s]=Rm(n);return e===1&&t===1&&s===1}function ai(n,e){return sh(n)||sh(e)}function ih(n){return Rm(n).every(e=>e>0)}function bl(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Hi(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")F(sf(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(i=>{F(sf(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mX(n,e){const s={x:Z(n,"x","reshape","string_or_numeric")},i={shape:e};return se.runKernel(qw,s,i)}const ae=ce({reshape_:mX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(n,e,t,s,i){const r=Z(n,"x","avgPool","float32"),o=1;F(ai(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=r,l=!1;r.rank===3&&(l=!0,a=ae(r,[1,r.shape[0],r.shape[1],r.shape[2]])),F(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Hi("avgPool",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i};let h=se.runKernel(uw,c,u);return h=it(h,r.dtype),l?ae(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const iM=ce({avgPool_:gX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xX(n,e,t,s,i,r="NDHWC"){const o=Z(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),F(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),F(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),F(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Hi("avgPool3d",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r};let h=se.runKernel(hw,c,u);return h=it(h,a.dtype),l?ae(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const yX=ce({avgPool3d_:xX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vX(n,e=0){F(n.length>=1,()=>"Pass at least one tensor to concat");const t=KO(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),t.length===1)return Ou(t[0]);const s=t,i={axis:e};return se.runKernel(mw,s,i)}const Ui=ce({concat_:vX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(n,e,t=!1,s=!1){let i=Z(n,"a","matMul"),r=Z(e,"b","matMul");[i,r]=ss(i,r);const o={a:i,b:r},a={transposeA:t,transposeB:s};return se.runKernel(dw,o,a)}const hn=ce({matMul_:wX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bX(n){const t={x:Z(n,"x","sigmoid","float32")};return se.runKernel(e0,t)}const Af=ce({sigmoid_:bX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SX(n,e,t){const s=Z(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},r={begin:e,size:t};return se.runKernel(Qw,i,r)}const _n=ce({slice_:SX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _X(n){const t={x:Z(n,"x","tanh","float32")};return se.runKernel(o0,t)}const rM=ce({tanh_:_X});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CX(n,e,t){const s=Z(n,"x","batchToSpaceND"),i=e.reduce((a,l)=>a*l);F(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),F(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),F(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const r={x:s},o={blockShape:e,crops:t};return se.runKernel(fw,r,o)}const oM=ce({batchToSpaceND_:CX});function TX(n){let e;return n.rank===0||n.rank===1?e=ae(n,[1,1,1,n.size]):n.rank===2?e=ae(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ae(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IX(n,e,t,s,i,r){r==null&&(r=.001);const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let c;i!=null&&(c=Z(i,"scale","batchNorm"));let u;s!=null&&(u=Z(s,"offset","batchNorm")),F(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:TX(o),scale:c,offset:u,mean:a,variance:l},f={varianceEpsilon:r},m=se.runKernel(Cw,d,f);return ae(m,o.shape)}const hb=ce({batchNorm_:IX});function EX(n,e,t,s,i,r){const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let c;i!=null&&(c=Z(i,"scale","batchNorm"));let u;return s!=null&&(u=Z(s,"offset","batchNorm")),F(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),F(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),F(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&F(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&F(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),hb(o,a,l,u,c,r)}const MX=ce({batchNorm2d_:EX});function kX(n,e,t,s,i,r){const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let c;i!=null&&(c=Z(i,"scale","batchNorm"));let u;return s!=null&&(u=Z(s,"offset","batchNorm")),F(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),F(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),F(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&F(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&F(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),hb(o,a,l,u,c,r)}const AX=ce({batchNorm3d_:kX});function NX(n,e,t,s,i,r){const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let c;i!=null&&(c=Z(i,"scale","batchNorm"));let u;return s!=null&&(u=Z(s,"offset","batchNorm")),F(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),F(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),F(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&F(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&F(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),hb(o,a,l,u,c,r)}const RX=ce({batchNorm4d_:NX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DX(n,e,t){const s=Z(n,"x","bincount"),i=Z(e,"weights","bincount");F(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),F(t>=0,()=>`size must be non-negative, but got ${t}.`),F(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const r={x:s,weights:i},o={size:t};return se.runKernel(bE,r,o)}const LX=ce({bincount_:DX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(n,e){let t=Z(n,"broadcastTo","x");const s=t.shape;if(vl(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ae(t,c)}const i=t.shape,r=Array.from(e);for(let c=e.length-1;c>=0;c--)if(i[c]===e[c])r[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(r.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return Ou(t);const a={x:t},l={reps:r};return se.runKernel(a0,a,l)}const am=ce({broadcastTo_:PX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $X(n){const t={x:Z(n,"x","ceil","float32")};return se.runKernel(Sg,t)}const FX=ce({ceil_:$X});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function db(n,e,t){vl(n);const s={shape:n,value:e,dtype:t};return se.runKernel(LE,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(n,e,t){const s=Z(n,"x","clipByValue");if(F(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return db(s.shape,e,s.dtype);const i={x:s},r={clipValueMin:e,clipValueMax:t};return se.runKernel(_g,i,r)}const Nr=ce({clipByValue_:OX});function zX(n){return Ui(n,0)}const BX=ce({concat1d_:zX});function UX(n,e){return Ui(n,e)}const VX=ce({concat2d_:UX});function WX(n,e){return Ui(n,e)}const GX=ce({concat3d_:WX});function HX(n,e){return Ui(n,e)}const XX=ce({concat4d_:HX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jX(n,e,t,s,i="NHWC",r=[1,1],o){const a=Z(n,"x","conv2d","float32"),l=Z(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]])),F(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),F(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Hi("conv2d",s,o);const h=i==="NHWC"?c.shape[3]:c.shape[1];F(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),F(ai(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),F(ih(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),F(ih(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:c,filter:l},f={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},m=se.runKernel(gw,d,f);return u?ae(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const rh=ce({conv2d_:jX});function qX(n,e,t,s,i="NWC",r=1,o){const a=Z(n,"x","conv1d"),l=Z(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=ae(a,[1,a.shape[0],a.shape[1]])),F(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),F(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Hi("conv1d",s,o),F(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),F(ai(t,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${r}'`),F(ih(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),F(ih(t),()=>"Error in conv1D: Stride should be larger than 0."),F(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const h=ae(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=ae(c,[c.shape[0],1,c.shape[1],c.shape[2]]),y=rh(d,h,[1,t],s,"NHWC",[1,r],o);return u?ae(y,[y.shape[2],y.shape[3]]):ae(y,[y.shape[0],y.shape[2],y.shape[3]])}const lz=ce({conv1d_:qX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KX(n,e,t,s,i,r="NHWC",o){F(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),F(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),F(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),F(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=r==="NHWC"?a[3]:a[1],h=r==="NHWC"?l.shape[3]:l.shape[1];F(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),F(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Hi("conv2dDerInput",i,o);const d={dy:l,filter:t},f={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,inputShape:a},m=se.runKernel(xw,d,f);return c?ae(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const aM=ce({conv2DBackpropInput_:KX});function YX(n,e,t,s,i,r){const o=Z(n,"x","conv2dTranspose"),a=Z(e,"filter","conv2dTranspose");return aM(t,o,a,s,i,"NHWC",r)}const cz=ce({conv2dTranspose_:YX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZX(n,e,t,s,i="NDHWC",r=[1,1,1]){const o=Z(n,"x","conv3d"),a=Z(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),F(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),F(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),F(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),F(ai(t,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),F(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),F(ih(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),F(ih(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},h={strides:t,pad:s,dataFormat:i,dilations:r},d=se.runKernel(yw,u,h);return c?ae(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const JX=ce({conv3d_:ZX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QX(n,e,t,s,i){F(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let r=n,o=e,a=!1;e.rank===4&&(a=!0,o=ae(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),r=[1,n[0],n[1],n[2],n[3]]);const l=r[4],c=o.shape[4];F(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),F(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),F(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),F(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),F(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},h={pad:i,strides:s,inputShape:r},d=se.runKernel(TE,u,h);return a?ae(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const uz=ce({conv3DBackpropInput_:QX});function ej(n,e,t,s,i){const r=Z(n,"x","conv3dTranspose"),o=Z(e,"filter","conv3dTranspose");return uz(t,r,o,s,i)}const tj=ce({conv3dTranspose_:ej});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nj(n){const t={x:Z(n,"x","cos","float32")};return se.runKernel(Cg,t)}const lM=ce({cos_:nj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sj(n){const t={x:Z(n,"x","cosh","float32")};return se.runKernel(Tg,t)}const hz=ce({cosh_:sj});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ij(n,e=0,t=!1,s=!1){const r={x:Z(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return se.runKernel(IE,r,o)}const rT=ce({cumprod_:ij});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rj(n,e=0,t=!1,s=!1){const r={x:Z(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return se.runKernel(vw,r,o)}const dz=ce({cumsum_:rj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oj(n,e,t,s=!1){const i=Z(n,"x","denseBincount"),r=Z(e,"weights","denseBincount");F(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),F(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),F(t>=0,()=>`size must be non-negative, but got ${t}.`),F(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const o={x:i,weights:r},a={size:t,binaryOutput:s};return se.runKernel(ME,o,a)}const H3=ce({denseBincount_:oj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aj(n,e,t="NHWC"){const s=Z(n,"x","depthToSpace","float32"),i=t==="NHWC"?s.shape[1]:s.shape[2],r=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];F(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),F(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${s.shape}`),F(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e} for depthToSpace with input shape
        ${s.shape}`),F(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return se.runKernel(kE,a,l)}const lj=ce({depthToSpace_:aj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cj(n,e,t,s,i="NHWC",r=[1,1],o){const a=Z(n,"x","depthwiseConv2d","float32"),l=Z(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]])),F(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),F(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=i==="NHWC"?c.shape[3]:c.shape[1];F(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Hi("depthwiseConv2d",s,o);const d={x:c,filter:l},f={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},m=se.runKernel(ww,d,f);return u?ae(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const cM=ce({depthwiseConv2d_:cj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uj(n,e,t,s,i=[1,1],r="NHWC"){const o=Z(n,"x","dilation2d"),a=Z(e,"filter","dilation2d");F(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),F(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),F(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let l=o,c=!1;o.rank===3&&(l=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),F(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},h={strides:t,pad:s,dilations:i},d=se.runKernel(bw,u,h);return c?ae(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const hj=ce({dilation2d_:uj});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lf(n,e){const t=n.length,s=[];for(let i=0;i<t;i++){const r=t-1-i,o=n[r]||1;(e[e.length-1-i]||1)>1&&o===1&&s.unshift(r)}return s}function Is(n,e){const t=[];for(let s=0;s<e.length;s++){const i=n[n.length-s-1],r=e.length-s-1,o=e[r];(i==null||i===1&&o>1)&&t.unshift(r)}return t}function Mt(n,e){const t=[],s=Math.max(n.length,e.length);for(let i=0;i<s;i++){let r=n[n.length-i-1];r==null&&(r=1);let o=e[e.length-i-1];if(o==null&&(o=1),r===1)t.unshift(o);else if(o===1)t.unshift(r);else if(r!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else t.unshift(r)}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dj(n,e){let t=Z(n,"a","equal","string_or_numeric"),s=Z(e,"b","equal","string_or_numeric");[t,s]=ss(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Sw,i)}const Ma=ce({equal_:dj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(n,e,t){const s=Z(e,"a","where"),i=Z(t,"b","where"),r=Z(n,"condition","where","bool"),o=Mt(Mt(r.shape,s.shape),i.shape),a=am(r,o),l=am(s,o),c=am(i,o),u={condition:a,t:l,e:c};return se.runKernel(Jw,u)}const cr=ce({where_:fj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pj(n){const t={x:Z(n,"x","zerosLike")};return se.runKernel(ob,t)}const Qt=ce({zerosLike_:pj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mj(n,e){let t=Z(n,"a","div"),s=Z(e,"b","div");[t,s]=ss(t,s);const i=bt(t,s),r=Qt(i),o=Ma(s,r);return cr(o,r,i)}const gj=ce({divNoNan_:mj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xj(n,e){const t=Z(n,"t1","dot"),s=Z(e,"t2","dot");F((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const i=t.rank===1?t.size:t.shape[1],r=s.rank===1?s.size:s.shape[0];if(F(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),t.rank===1&&s.rank===1){const o=ae(t,[1,-1]),a=ae(s,[-1,1]),l=hn(o,a);return ae(l,[])}else if(t.rank===1&&s.rank===2){const o=ae(t,[1,-1]),a=ae(s,[s.shape[0],s.shape[1]]),l=hn(o,a);return ae(l,[l.size])}else if(t.rank===2&&s.rank===1){const o=ae(s,[-1,1]),a=hn(t,o);return ae(a,[a.size])}else{const o=ae(s,[s.shape[0],s.shape[1]]);return hn(t,o)}}const yj=ce({dot_:xj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vj(n){const t={x:Z(n,"x","elu","float32")};return se.runKernel(Eg,t)}const fb=ce({elu_:vj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wj(n){let e=Z(n,"x","erf");F(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=it(e,"float32"));const t={x:e};return se.runKernel(Mg,t)}const bj=ce({erf_:wj});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function fz(n,e,t){const s=n.length+e.length,i=[];let r=0,o=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?i.push(n[r++]):i.push(e[o++]);return i}function Fs(n,e){const t=[],s=n.length;for(let r=0;r<s;r++)e.indexOf(r)===-1&&t.push(n[r]);const i=e.map(r=>n[r]);return[t,i]}function ms(n,e){const t=e.map(s=>1);return fz(n,t,e)}function Zs(n,e,t){F(uM(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Wn(n,e){if(uM(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Fc(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function is(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(n,e=null,t=!1){const i={x:Z(n,"x","max")},r={reductionIndices:e,keepDims:t};return se.runKernel(Lw,i,r)}const zo=ce({max_:Sj});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _j(n,e=null,t=!1){const i={x:Z(n,"x","min")},r={axis:e,keepDims:t};return se.runKernel(Ow,i,r)}const m1=ce({min_:_j});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cj(n,e){let t=Z(n,"base","pow"),s=Z(e,"exp","pow");[t,s]=ss(t,s);const i={a:t,b:s};return se.runKernel(Gg,i)}const cf=ce({pow_:Cj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dn(n,e){if((Wo(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Wo(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return cb(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(n){const t={x:Z(n,"x","sqrt","float32")};return se.runKernel(n0,t)}const Ti=ce({sqrt_:Tj});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ij(n){const e=Z(n,"x","square"),t={};return se.runKernel("Square",{x:e},t)}const An=ce({square_:Ij});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ej(n,e=null,t=!1){let s=Z(n,"x","sum");s.dtype==="bool"&&(s=it(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return se.runKernel(eb,i,r)}const yt=ce({sum_:Ej});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mj(n,e="euclidean",t=null,s=!1){n=Z(n,"x","norm");const i=pz(n,e,t);let r=i.shape;if(s){const o=Ut(t,n.shape);r=ms(i.shape,o)}return ae(i,r)}function pz(n,e,t=null){if(n.rank===0)return yi(n);if(n.rank!==1&&t===null)return pz(ae(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return yt(yi(n),t);if(e===1/0)return zo(yi(n),t);if(e===-1/0)return m1(yi(n),t);if(e==="euclidean"||e===2)return Ti(yt(cf(yi(n),dn(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return zo(yt(yi(n),t[0]),t[1]-1);if(e===1/0)return zo(yt(yi(n),t[1]),t[0]);if(e===-1/0)return m1(yt(yi(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ti(yt(An(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const pb=ce({norm_:Mj});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(n,e=null,t=!1){return pb(n,"euclidean",e,t)}const Aj=ce({euclideanNorm_:kj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(n){const t={x:Z(n,"x","exp")};return se.runKernel(kg,t)}const fl=ce({exp_:Nj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rj(n,e=0){const t=Z(n,"x","expandDims","string_or_numeric");F(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},i={dim:e};return se.runKernel(_w,s,i)}const tr=ce({expandDims_:Rj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dj(n){const t={x:Z(n,"x","expm1")};return se.runKernel(Ag,t)}const Lj=ce({expm1_:Dj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(n,e){const t=Z(n,"x","tile","string_or_numeric");F(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},i={reps:e};return se.runKernel(a0,s,i)}const Po=ce({tile_:Pj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $j(n,e,t,s="float32"){e==null&&(e=n);const i=zt([n,e],s),r=n<=e?n:e;for(let a=0;a<r;++a)i.set(1,a,a);const o=ae(i.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Po(tr(o,0),[t[0],1,1]);if(t.length===2)return Po(tr(tr(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Po(tr(tr(tr(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const mz=ce({eye_:$j});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fj(n){const t={x:Z(n,"x","floor","float32")};return se.runKernel(Ng,t)}const mb=ce({floor_:Fj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oj(n,e,t=0,s=0){const i=Z(n,"x","gather"),r=Z(e,"indices","gather","int32"),o={x:i,indices:r},a={axis:t,batchDims:s};return se.runKernel(Tw,o,a)}const hM=ce({gather_:Oj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zj(n,e){let t=Z(n,"a","greater","string_or_numeric"),s=Z(e,"b","greater","string_or_numeric");[t,s]=ss(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Iw,i)}const Lr=ce({greater_:zj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(n,e){let t=Z(n,"a","greaterEqual","string_or_numeric"),s=Z(e,"b","greaterEqual","string_or_numeric");[t,s]=ss(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Dg,i)}const Sh=ce({greaterEqual_:Bj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uj(n){const t={input:Z(n,"input","imag")};return se.runKernel(FE,t)}const dM=ce({imag_:Uj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vj(n){const t={x:Z(n,"x","isFinite")};return se.runKernel(Pg,t)}const Wj=ce({isFinite_:Vj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gj(n){const t={x:Z(n,"x","isInf")};return se.runKernel($g,t)}const Hj=ce({isInf_:Gj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xj(n){const t={x:Z(n,"x","isNaN")};return se.runKernel(Fg,t)}const jj=ce({isNaN_:Xj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(n,e=.2){const s={x:Z(n,"x","leakyRelu")},i={alpha:e};return se.runKernel(Ew,s,i)}const fM=ce({leakyRelu_:qj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kj(n,e){let t=Z(n,"a","less","string_or_numeric"),s=Z(e,"b","less","string_or_numeric");[t,s]=ss(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Mw,i)}const gz=ce({less_:Kj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yj(n,e){let t=Z(n,"a","lessEqual","string_or_numeric"),s=Z(e,"b","lessEqual","string_or_numeric");[t,s]=ss(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(kw,i)}const Nf=ce({lessEqual_:Yj});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zj(n,e=5,t=1,s=1,i=.5){const r=Z(n,"x","localResponseNormalization");F(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),F(sf(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=r,a=!1;r.rank===3&&(a=!0,o=ae(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:s,beta:i},u=se.runKernel(Dw,l,c);return a?ae(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Jj=ce({localResponseNormalization_:Zj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qj(n){const t={x:Z(n,"x","log","float32")};return se.runKernel(Og,t)}const ka=ce({log_:Qj});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eq(n){const t={x:Z(n,"x","log1p")};return se.runKernel(zg,t)}const xz=ce({log1p_:eq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tq(n,e){F(U2(n),()=>"The f passed in variableGrads(f) must be a function"),F(e==null||Array.isArray(e)&&e.every(c=>c instanceof p1),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in se.registeredVariables)e.push(se.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,i=e.length;e=e.filter(c=>c.trainable),F(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:o,grads:a}=se.gradients(n,e,null,r);F(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),F(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:o,grads:l}}function uf(n){return se.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nq(n){const t={x:Z(n,"x","neg")};return se.runKernel(Bw,t)}const ps=ce({neg_:nq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sq(n){const t={x:Z(n,"x","softplus")};return se.runKernel(t0,t)}const u0=ce({softplus_:sq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iq(n){const e=Z(n,"x","logSigmoid");return uf(s=>({value:ps(u0(ps(s))),gradFunc:o=>ne(o,Af(ps(s)))}))(e)}const rq=ce({logSigmoid_:iq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oq(n,e){let t=Z(n,"a","sub"),s=Z(e,"b","sub");[t,s]=ss(t,s);const i={a:t,b:s};return se.runKernel(i0,i)}const Ct=ce({sub_:oq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aq(n,e=-1){const t=Z(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return uf((i,r)=>{const a=zo(i,e,!0),l=Ct(i,a),c=Ct(it(l,"float32"),ka(yt(fl(l),e,!0)));return r([c]),{value:c,gradFunc:(h,d)=>{const[f]=d,m=!0,x=fl(f);return Ct(h,ne(yt(h,e,m),x))}}})(t)}const yz=ce({logSoftmax_:aq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lq(n,e=null,t=!1){const s=Z(n,"x","logSumExp"),i=Ut(e,s.shape),r=zo(s,i,!0),o=Ct(s,r),a=fl(o),l=yt(a,i),c=ka(l),u=Ue(ae(r,c.shape),c);if(t){const h=ms(u.shape,i);return ae(u,h)}return u}const cq=ce({logSumExp_:lq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(n,e){const t=Z(n,"a","logicalAnd","bool"),s=Z(e,"b","logicalAnd","bool");Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Aw,i)}const pl=ce({logicalAnd_:uq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hq(n){const t={x:Z(n,"x","logicalNot","bool")};return se.runKernel(Nw,t)}const pM=ce({logicalNot_:hq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dq(n,e){const t=Z(n,"a","logicalOr","bool"),s=Z(e,"b","logicalOr","bool");Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Rw,i)}const vz=ce({logicalOr_:dq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fq(n,e){const t=Z(n,"a","logicalXor","bool"),s=Z(e,"b","logicalXor","bool");return Mt(t.shape,s.shape),pl(vz(n,e),pM(pl(n,e)))}const pq=ce({logicalXor_:fq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mq(n,e,t,s,i){const r=Z(n,"x","maxPool"),o=1;let a=r,l=!1;r.rank===3&&(l=!0,a=ae(r,[1,r.shape[0],r.shape[1],r.shape[2]])),F(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),F(ai(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Hi("maxPool",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i},h=se.runKernel(Pw,c,u);return l?ae(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const mM=ce({maxPool_:mq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gq(n,e=[1,1,1],t,s,i,r="NDHWC"){const o=Z(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),F(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),F(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),Hi("maxPool3d",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r},h=se.runKernel($w,c,u);return l?ae(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const xq=ce({maxPool3d_:gq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yq(n,e){let t=Z(n,"a","maximum"),s=Z(e,"b","maximum");[t,s]=ss(t,s),t.dtype==="bool"&&(t=it(t,"int32"),s=it(s,"int32")),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Bg,i)}const Oc=ce({maximum_:yq});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vq(n,e=null,t=!1){const i={x:Z(n,"x","mean")},r={axis:e,keepDims:t};return se.runKernel(Fw,i,r)}const ds=ce({mean_:vq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(n,e="float32"){if(vl(n),e==="complex64"){const s=Rs(n,"float32"),i=Rs(n,"float32");return af(s,i)}const t=oi(Se(n),e);return se.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _h(n,e="float32"){if(vl(n),e==="complex64"){const s=_h(n,"float32"),i=Rs(n,"float32");return af(s,i)}const t=fE(Se(n),e);return se.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wq(n,e){let t=Z(n,"a","minimum"),s=Z(e,"b","minimum");[t,s]=ss(t,s),t.dtype==="bool"&&(t=it(t,"int32"),s=it(s,"int32")),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Ug,i)}const gM=ce({minimum_:wq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bq(n,e,t){F(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=Z(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");F(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)F(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),F(e[a][0]>=0&&e[a][0]<=s.shape[a]-i&&e[a][1]>=0&&e[a][1]<=s.shape[a]-i,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-i} or less than 0 for input of shape ${s.shape}`);const r={paddings:e,mode:t},o={x:s};return se.runKernel(zw,o,r)}const Sq=ce({mirrorPad_:bq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _q(n,e){let t=Z(n,"a","mod"),s=Z(e,"b","mod");[t,s]=ss(t,s);const i={a:t,b:s};return se.runKernel(Vg,i)}const Cq=ce({mod_:_q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tq(n,e=null,t=!1){n=Z(n,"x","moments");const s=Ut(e,n.shape),i=ds(n,s,t);let r=i.shape;t||(r=ms(i.shape,s));const o=An(Ct(it(n,"float32"),ae(i,r))),a=ds(o,s,t);return{mean:i,variance:a}}const xM=ce({moments_:Tq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iq(n,e){let t=Z(n,"a","notEqual","string_or_numeric"),s=Z(e,"b","notEqual","string_or_numeric");[t,s]=ss(t,s),Mt(t.shape,s.shape);const i={a:t,b:s};return se.runKernel(Uw,i)}const g1=ce({notEqual_:Iq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eq(n,e,t=1,s=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:Z(n,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:t,offValue:s};return se.runKernel(Ww,o,a)}const yM=ce({oneHot_:Eq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mq(n){const t={x:Z(n,"x","onesLike")};return se.runKernel(Vw,t)}const po=ce({onesLike_:Mq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kq(n,e,t=0){const s=Z(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},r={x:s};return se.runKernel(Hw,r,i)}const vM=ce({pad_:kq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aq(n,e,t){const s=Z(n,"x","spaceToBatchND");F(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),F(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),F(s.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:s},r={blockShape:e,paddings:t};return se.runKernel(tb,i,r)}const wM=ce({spaceToBatchND_:Aq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nq(n,e,t,s,i,r,o){i==null&&(i=[1,1]),r==null&&(r=1),s===0&&(s="valid");const a=Z(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]])),F(ai(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const u=go(l.shape,e,r,i,s),h=[u.dilationHeight,u.dilationWidth];let d;s==="same"?d=Dq([u.filterHeight,u.filterWidth],h):d=[[0,0],[0,0]];const f=h[0]===1&&h[1]===1,[m,x]=Rq([u.inHeight,u.inWidth],h,d),y=f?s:"valid",v=f?l:wM(l,h,m),b=(t==="avg"?()=>iM(v,e,r,y,o):()=>mM(v,e,r,y,o))(),S=f?b:oM(b,h,x);return c?ae(S,[S.shape[1],S.shape[2],S.shape[3]]):S}function Rq(n,e,t){const s=t.map(u=>u[0]),i=t.map(u=>u[1]),r=n.concat(s,i),o=e.map((u,h)=>(u-r[h]%u)%u),a=i.map((u,h)=>u+o[h]),l=e.map((u,h)=>[s[h],a[h]]),c=e.map((u,h)=>[0,o[h]]);return[l,c]}function Dq(n,e){const s=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),i=s.map(o=>Math.floor(o/2)),r=s.map((o,a)=>o-i[a]);return s.map((o,a)=>[i[a],r[a]])}const Lq=ce({pool_:Nq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pq(n,e){const t=Z(n,"x","prelu"),s=Z(e,"alpha","prelu"),i={x:t,alpha:s};return se.runKernel(Xw,i)}const bM=ce({prelu_:Pq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $q(n,e=null,t=!1){let s=Z(n,"x","prod");s.dtype==="bool"&&(s=it(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return se.runKernel(jw,i,r)}const Fq=ce({prod_:$q});var wz={exports:{}};(function(n){(function(e,t,s){function i(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function r(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new i(l),h=c&&c.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&r(h,u),d.state=function(){return r(u,{})}),d}function a(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(xh,n,!1)})(wz);var bz={exports:{}};(function(n){(function(e,t,s){function i(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function r(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(xh,n,!1)})(bz);var Sz={exports:{}};(function(n){(function(e,t,s){function i(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function r(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(xh,n,!1)})(Sz);var _z={exports:{}};(function(n){(function(e,t,s){function i(a){var l=this;l.next=function(){var u=l.x,h=l.i,d,f;return d=u[h],d^=d>>>7,f=d^d<<24,d=u[h+1&7],f^=d^d>>>10,d=u[h+3&7],f^=d^d>>>3,d=u[h+4&7],f^=d^d<<7,d=u[h+7&7],d=d^d<<13,f^=d^d<<9,u[h]=f,l.i=h+1&7,f};function c(u,h){var d,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,d=0;d<h.length;++d)f[d&7]=f[d&7]<<15^h.charCodeAt(d)+f[d+1&7]<<13;for(;f.length<8;)f.push(0);for(d=0;d<8&&f[d]===0;++d);for(d==8?f[7]=-1:f[d],u.x=f,u.i=0,d=256;d>0;--d)u.next()}c(l,a)}function r(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,u&&(u.x&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(xh,n,!1)})(_z);var Cz={exports:{}};(function(n){(function(e,t,s){function i(a){var l=this;l.next=function(){var u=l.w,h=l.X,d=l.i,f,m;return l.w=u=u+1640531527|0,m=h[d+34&127],f=h[d=d+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=h[d]=m^f,l.i=d,m+(u^u>>>16)|0};function c(u,h){var d,f,m,x,y,v=[],w=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,w=Math.max(w,h.length)),m=0,x=-32;x<w;++x)h&&(f^=h.charCodeAt((x+32)%h.length)),x===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,x>=0&&(y=y+1640531527|0,d=v[x&127]^=f+y,m=d==0?m+1:0);for(m>=128&&(v[(h&&h.length||0)&127]=-1),m=127,x=4*128;x>0;--x)f=v[m+34&127],d=v[m=m+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,v[m]=f^d;u.w=y,u.X=v,u.i=m}c(l,a)}function r(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,u&&(u.X&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(xh,n,!1)})(Cz);var Tz={exports:{}};(function(n){(function(e,t,s){function i(a){var l=this,c="";l.next=function(){var h=l.b,d=l.c,f=l.d,m=l.a;return h=h<<25^h>>>7^d,d=d-f|0,f=f<<24^f>>>8^m,m=m-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-f|0,l.d=f<<16^d>>>16^m,l.a=m-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function r(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(xh,n,!1)})(Tz);var Iz={exports:{}};const Oq={},zq=Object.freeze(Object.defineProperty({__proto__:null,default:Oq},Symbol.toStringTag,{value:"Module"})),Bq=r6(zq);(function(n){(function(e,t,s){var i=256,r=6,o=52,a="random",l=s.pow(i,r),c=s.pow(2,o),u=c*2,h=i-1,d;function f(S,C,E){var k=[];C=C==!0?{entropy:!0}:C||{};var I=v(y(C.entropy?[S,b(t)]:S==null?w():S,3),k),A=new m(k),N=function(){for(var L=A.g(r),V=l,O=0;L<c;)L=(L+O)*i,V*=i,O=A.g(1);for(;L>=u;)L/=2,V/=2,O>>>=1;return(L+O)/V};return N.int32=function(){return A.g(4)|0},N.quick=function(){return A.g(4)/4294967296},N.double=N,v(b(A.S),t),(C.pass||E||function(L,V,O,P){return P&&(P.S&&x(P,A),L.state=function(){return x(A,{})}),O?(s[a]=L,V):L})(N,I,"global"in C?C.global:this==s,C.state)}function m(S){var C,E=S.length,k=this,I=0,A=k.i=k.j=0,N=k.S=[];for(E||(S=[E++]);I<i;)N[I]=I++;for(I=0;I<i;I++)N[I]=N[A=h&A+S[I%E]+(C=N[I])],N[A]=C;(k.g=function(L){for(var V,O=0,P=k.i,W=k.j,H=k.S;L--;)V=H[P=h&P+1],O=O*i+H[h&(H[P]=H[W=h&W+V])+(H[W]=V)];return k.i=P,k.j=W,O})(i)}function x(S,C){return C.i=S.i,C.j=S.j,C.S=S.S.slice(),C}function y(S,C){var E=[],k=typeof S,I;if(C&&k=="object")for(I in S)try{E.push(y(S[I],C-1))}catch{}return E.length?E:k=="string"?S:S+"\0"}function v(S,C){for(var E=S+"",k,I=0;I<E.length;)C[h&I]=h&(k^=C[h&I]*19)+E.charCodeAt(I++);return b(C)}function w(){try{var S;return d&&(S=d.randomBytes)?S=S(i):(S=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(S)),b(S)}catch{var C=e.navigator,E=C&&C.plugins;return[+new Date,e,E,e.screen,b(t)]}}function b(S){return String.fromCharCode.apply(0,S)}if(v(s.random(),t),n.exports){n.exports=f;try{d=Bq}catch{}}else s["seed"+a]=f})(typeof self<"u"?self:xh,[],Math)})(Iz);var Uq=wz.exports,Vq=bz.exports,Wq=Sz.exports,Gq=_z.exports,Hq=Cz.exports,Xq=Tz.exports,Ch=Iz.exports;Ch.alea=Uq;Ch.xor128=Vq;Ch.xorwow=Wq;Ch.xorshift7=Gq;Ch.xor4096=Hq;Ch.tychei=Xq;var SM=Ch;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ez{constructor(e,t,s,i,r){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=r||Math.random();this.random=SM.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,s=!1;for(;!s;){let i,r,o;do i=2*this.random()-1,r=2*this.random()-1,o=i*i+r*r;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*i*a,t=this.mean+this.stdDev*r*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class jq{constructor(e=0,t=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=SM.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qq(n,e=0,t=1,s,i){if(vl(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const r=new Ez(e,t,s,!1,i),o=zt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=r.nextValue();return o.toTensor()}const Kq=ce({randomNormal_:qq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yq(n,e=0,t=1,s="float32",i){vl(n);const r=zt(n,s),o=new jq(e,t,null,i);for(let a=0;a<r.values.length;a++)r.values[a]=o.nextValue();return r.toTensor()}const gb=ce({randomUniform_:Yq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lm(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:e,step:t,dtype:s};return se.runKernel(GE,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zq(n){const t={input:Z(n,"input","real")};return se.runKernel(HE,t)}const x1=ce({real_:Zq});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jq(n){const t={x:Z(n,"x","reciprocal")};return se.runKernel(Hg,t)}const Qq=ce({reciprocal_:Jq});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eK(n){const t={x:Z(n,"x","relu")};return se.runKernel(Xg,t)}const Th=ce({relu_:eK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tK(n){const t={x:Z(n,"x","relu6")};return se.runKernel(jg,t)}const Mz=ce({relu6_:tK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nK(n,e){const s={x:Z(n,"x","reverse")},i={dims:e};return se.runKernel(Zw,s,i)}const oh=ce({reverse_:nK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sK(n){const t={x:Z(n,"x","round")};return se.runKernel(qg,t)}const kz=ce({round_:sK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(n){const t={x:Z(n,"x","rsqrt","float32")};return se.runKernel(Kg,t)}const Az=ce({rsqrt_:iK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rK(n){const t={x:Z(n,"x","selu")};return se.runKernel(Yg,t)}const Nz=ce({selu_:rK});function oK(n,e,t,s,i,r=[1,1],o="NHWC"){const a=Z(n,"x","separableConv2d"),l=Z(e,"depthwiseFilter","separableConv2d"),c=Z(t,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(a.rank===3&&(h=!0,u=ae(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");F(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),F(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),F(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),F(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),F(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],f=l.shape[3];F(c.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${c.shape[2]}.`);const m=cM(u,l,s,i,o,r),y=rh(m,c,1,"valid",o);return h?ae(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const Rz=ce({separableConv2d_:oK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aK(n){const t={x:Z(n,"x","sign")};return se.runKernel(Qg,t)}const lK=ce({sign_:aK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cK(n){const t={x:Z(n,"x","sin","float32")};return se.runKernel(Zg,t)}const Dz=ce({sin_:cK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uK(n){const t={x:Z(n,"x","sinh")};return se.runKernel(Jg,t)}const Lz=ce({sinh_:uK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hK(n,e,t){const s=Z(n,"x","slice1d");return F(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),_n(s,[e],[t])}const _M=ce({slice1d_:hK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dK(n,e,t){const s=Z(n,"x","slice2d");return F(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),_n(s,e,t)}const Pz=ce({slice2d_:dK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fK(n,e,t){const s=Z(n,"x","slice3d");return F(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),_n(s,e,t)}const CM=ce({slice3d_:fK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pK(n,e,t){const s=Z(n,"x","slice4d");return F(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),_n(s,e,t)}const y1=ce({slice4d_:pK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mK(n,e=-1){const t=Z(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},i={dim:e};return se.runKernel(sb,s,i)}const TM=ce({softmax_:mK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gK(n){F(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel(DE,e)}const $z=ce({fft_:gK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xK(n){F(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return se.runKernel($E,e)}const oT=ce({ifft_:xK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yK(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const i=ae(n,[t,e]);s=oT(i)}else{const i=[t,2*(e-1)],r=ae(x1(n),[t,e]),o=ae(dM(n),[t,e]),a=oh(_n(r,[0,1],[t,e-2]),1),l=ne(oh(_n(o,[0,1],[t,e-2]),1),dn(-1)),c=Ui([r,a],1),u=Ui([o,l],1),h=ae(af(c,u),[i[0],i[1]]);s=oT(h)}if(s=x1(s),n.rank===3&&n.shape[0]!==0){const i=s,r=n.shape[0];s=ae(s,[r,s.shape[0]/r,s.shape[1]]),i.dispose()}return s}const vK=ce({irfft_:yK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wK(n,e,t=0){const i={x:Z(n,"x","split")},r={numOrSizeSplits:e,axis:t};return se.runKernel(nb,i,r)}const Ir=ce({split_:wK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bK(n,e){F(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let i;if(e!=null&&e<t){const m=n.shape.map(y=>0),x=n.shape.map(y=>y);x[n.shape.length-1]=e,i=_n(n,m,x),t=e}else if(e!=null&&e>t){const m=n.shape.map(x=>x);m[n.shape.length-1]=e-t,i=Ui([n,Rs(m)],n.shape.length-1),t=e}else i=n;const r=Qt(i),o=ae(af(i,r),[s,t]),a=$z(o),l=Math.floor(t/2)+1,c=x1(a),u=dM(a),h=Ir(c,[l,t-l],c.shape.length-1),d=Ir(u,[l,t-l],u.shape.length-1),f=i.shape.slice();return f[i.shape.length-1]=l,ae(af(h[0],d[0]),f)}const SK=ce({rfft_:bK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _K(n,e){let t=Z(n,"a","squaredDifference"),s=Z(e,"b","squaredDifference");[t,s]=ss(t,s),Mt(t.shape,s.shape);const i={a:t,b:s},r={};return se.runKernel(s0,i,r)}const CK=ce({squaredDifference_:_K});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TK(n,e){const t=Z(n,"x","squeeze","string_or_numeric");return ae(t,Lc(t.shape,e).newShape)}const h0=ce({squeeze_:TK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IK(n,e=0){const t=KO(n,"tensors","stack","string_or_numeric");F(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&F(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,i={axis:e};return se.runKernel(Gw,s,i)}const bc=ce({stack_:IK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EK(n,e=0){const s={x:Z(n,"x","step")},i={alpha:e};return se.runKernel(l0,s,i)}const d0=ce({step_:EK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MK(n,e,t,s,i=0,r=0,o=0,a=0,l=0){const u={x:Z(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:s,beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return se.runKernel(KE,u,h)}const kK=ce({stridedSlice_:MK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AK(n){const t={x:Z(n,"x","tan","float32")};return se.runKernel(r0,t)}const NK=ce({tan_:AK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oi(n,e){oO(n);const t=lb(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return cb(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lm(n,e,t){if(oO(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=lb(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return cb(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RK(n,e=1,t=!0){const s=Z(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const r={x:s},o={k:e,sorted:t},[a,l]=se.runKernel(YE,r,o);return{values:a,indices:l}}const DK=ce({topk_:RK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LK(n,e=0,t=1,s,i){if(vl(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new Ez(e,t,s,!0,i),o=zt(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=r.nextValue();return o.toTensor()}const Fz=ce({truncatedNormal_:LK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PK(n,e=0){const t=Z(n,"x","unique","string_or_numeric");F(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},i={axis:e},[r,o]=se.runKernel(JE,s,i);return{values:r,indices:o}}const $K=ce({unique_:PK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(n,e,t){const s=Z(n,"x","unsortedSegmentSum"),i=Z(e,"segmentIds","unsortedSegmentSum","int32");F(sf(t),()=>"numSegments must be of dtype int");const r={x:s,segmentIds:i},o={numSegments:t};return se.runKernel(rb,r,o)}const Oz=ce({unsortedSegmentSum_:FK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OK(n,e=0){const t=Z(n,"x","unstack","string_or_numeric");F(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},i={axis:e};return se.runKernel(ib,s,i)}const ah=ce({unstack_:OK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(n,e=!0,t,s){return se.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zz(n,e){const t=[];for(let r=0;r<e.length;r++)e[r]&&t.push(r);const s=zt(n,"int32"),i=zt([t.length,n.length],"int32");for(let r=0;r<t.length;r++){const o=s.indexToLoc(t[r]),a=r*n.length;i.values.set(o,a)}return i.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BK(n,e,t){const s=Z(n,"x","transpose");if(e==null&&(e=s.shape.map((o,a)=>a).reverse()),F(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{F(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const i={x:s},r={perm:e};return s.dtype==="complex64"?de(()=>{let o=x1(s),a=dM(s);return o=se.runKernel(Hd,{x:o},r),a=se.runKernel(Hd,{x:a},r),t&&(a=ps(a)),af(o,a)}):se.runKernel(Hd,i,r)}const Yt=ce({transpose_:BK});function Bz(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(r+` update.rank < ${i}. `);if(n.length<s+(t.rank-i))throw new Error(r+` Output shape length < ${s+(t.rank-i)}`);if(t.rank!==i+n.length-s)throw new Error(r+` update.rank != ${i+n.length-s}`);for(let o=0;o<i;++o)if(t.shape[o]!==e.shape[o])throw new Error(r+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-i;++o)if(t.shape[o+i]!==n[o+s])throw new Error(r+` updates.shape[${o+i}] (${t.shape[o+i]}) != shape[${o+i}] (${n[o+i]})`)}function UK(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Bz(t,e,n)}function f0(n,e,t){const s=e.shape.length,i=s>1?e.shape[s-1]:1,r=t.length;let o=1;for(let h=i;h<r;++h)o*=t[h];const a=i<1?1:i,l=Se(e.shape)/a,c=[...mt(t.slice(0,i)),1],u=Se(t);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VK(n,e){if(e==null)return n.shape.slice();if(pn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WK(n,e,t,s){const i=Z(n,"x","dropout");if(F(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),F(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof ts?i.clone():i;const r=VK(i,t),o=1-e,a=bt(mb(Ue(gb(r,0,1,"float32",s),o)),o);return ne(i,a)}const GK=ce({dropout_:WK});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HK(n,e,t,s,i,r="NHWC",o){let a=n;n.rank===3&&(a=ae(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]])),F(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),F(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),F(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=r==="NHWC"?a.shape[3]:a.shape[1],u=r==="NHWC"?l.shape[3]:l.shape[1];F(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),F(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),Hi("conv2dDerFilter",i,o);const h={x:a,dy:l},d={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,filterShape:t};return se.runKernel(_E,h,d)}const IM=ce({conv2DBackpropFilter_:HK});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EM(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ne(n,d0(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function MM(n,e){let t=e;const s=Is(n.shape,e.shape);return s.length>0&&(t=yt(t,s)),ae(t,n.shape)}function kM(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Th(n);if(e==="elu")return fb(n);if(e==="relu6")return Mz(n);if(e==="prelu")return bM(n,t);if(e==="leakyrelu")return fM(n,s);if(e==="sigmoid")return Af(n);throw new Error(`Unknown fused activation ${e}.`)}const AM=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XK({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",AM(se.state.gradientDepth,l)===!1){F(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=rh(n,e,t,s,i,r,o);return a!=null&&(E=Ue(E,a)),kM(E,l,c,u)}const h=Z(n,"x","conv2d","float32"),d=Z(e,"filter","conv2d","float32");let f=h,m=!1;h.rank===3&&(m=!0,f=ae(h,[1,h.shape[0],h.shape[1],h.shape[2]])),F(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),F(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Hi("fused conv2d",s,o);const x=i==="NHWC"?f.shape[3]:f.shape[1];F(d.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${d.shape[2]}.`),F(ai(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`);const y=Ys(f.shape,d.shape,t,r,s,o);let v;a!=null&&(v=Z(a,"bias","fused conv2d"),[v]=ss(v,h),i==="NHWC"?Mt(y.outShape,v.shape):(F(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),F(v.shape.length===0||v.shape[0]===y.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let w;if(c!=null){const E=c.shape;if(F(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)F(E[0]===1||E[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${y.outChannels}).`);else if(E.length===3)try{Mt(E,y.outShape)}catch{const I=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(I)}w=Z(c,"prelu weights","fused conv2d")}const b=(E,k)=>{F(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[I,A,N,L]=k,V=EM(E,N,l);F(sh(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const O=aM(A.shape,V,I,t,s),P=IM(A,V,I.shape,t,s),W=[O,P];if(L!=null){const H=MM(L,V);W.push(H)}return W},S={x:f,filter:d,bias:v,preluActivationWeights:w},C={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?uf((k,I,A)=>{let N=se.runKernel(h1,S,C);return A([I,k,N]),m&&(N=ae(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(f,d):uf((k,I,A,N)=>{let L=se.runKernel(h1,S,C);return N([I,k,L,A]),m&&(L=ae(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:b}})(f,d,v)}const jK=ce({fusedConv2d_:XK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qK(n,e,t,s,i,r=[1,1],o){let a=n;n.rank===3&&(a=ae(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:s,pad:i,dimRoundingMode:o,dilations:r,filterShape:t};return se.runKernel(AE,c,u)}const KK=ce({depthwiseConv2dNativeBackpropFilter_:qK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YK(n,e,t,s,i,r=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ae(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:s,pad:i,dimRoundingMode:o,dilations:r,inputShape:n},h=se.runKernel(NE,c,u);return l?ae(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ZK=ce({depthwiseConv2dNativeBackpropInput_:YK});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JK({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:i,activation:r="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(AM(se.state.gradientDepth,r)===!1){let L=hn(n,e,t,s);return i!=null&&(L=Ue(L,i)),kM(L,r,o,a)}let l=Z(n,"a","fused matMul"),c=Z(e,"b","fused matMul");[l,c]=ss(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?c.shape[c.rank-2]:c.shape[c.rank-1],m=l.shape.slice(0,-2),x=c.shape.slice(0,-2),y=Se(m),v=Se(x);F(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const b=Mt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,f]),S=t?ae(l,[y,u,d]):ae(l,[y,d,u]),C=s?ae(c,[v,f,h]):ae(c,[v,h,f]);let E;i!=null&&(E=Z(i,"bias","fused matMul"),[E]=ss(E,l),Mt(b,E.shape));let k;o!=null&&(k=Z(o,"prelu weights","fused matMul"));const I=(L,V)=>{const[O,P,W,H]=V,Y=EM(ae(L,W.shape),W,r);let D,$;if(!t&&!s?(D=hn(Y,P,!1,!0),$=hn(O,Y,!0,!1)):!t&&s?(D=hn(Y,P,!1,!1),$=hn(Y,O,!0,!1)):t&&!s?(D=hn(P,Y,!1,!0),$=hn(O,Y,!1,!1)):(D=hn(P,Y,!0,!0),$=hn(Y,O,!0,!0)),i!=null){const U=MM(H,Y);return[D,$,U]}else return[D,$]},A={a:S,b:C,bias:E,preluActivationWeights:k},N={transposeA:t,transposeB:s,activation:r,leakyreluAlpha:a};return i==null?uf((V,O,P)=>{const W=se.runKernel(u1,A,N);return P([V,O,W]),{value:ae(W,b),gradFunc:I}})(S,C):uf((V,O,P,W)=>{const H=se.runKernel(u1,A,N);return W([V,O,H,P]),{value:ae(H,b),gradFunc:I}})(S,C,E)}const X3=ce({fusedMatMul_:JK});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QK(n,e,t,s,i="bilinear",r=0){const o=Z(n,"image","cropAndResize"),a=Z(e,"boxes","cropAndResize","float32"),l=Z(t,"boxInd","cropAndResize","int32"),c=a.shape[0];F(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),F(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),F(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),F(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),F(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),F(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const u={image:o,boxes:a,boxInd:l},h={method:i,extrapolationValue:r,cropSize:s};return se.runKernel(EE,u,h)}const eY=ce({cropAndResize_:QK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(n){const e=Z(n,"image","flipLeftRight","float32");F(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return se.runKernel(PE,t,{})}const nY=ce({flipLeftRight_:tY});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sY(n){const e=Z(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];F(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),F(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,Po(e,i)}const iY=ce({grayscaleToRGB_:sY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(n,e,t=0,s=.5){const i=Z(n,"image","rotateWithOffset","float32");F(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},o={radians:e,fillValue:t,center:s};return se.runKernel(QE,r,o)}const oY=ce({rotateWithOffset_:rY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(n,e,t,s,i,r){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const o=n.shape[0];return t=Math.min(t,o),F(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),F(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),F(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),F(e.rank===1,()=>"scores must be a 1D tensor"),F(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),F(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=Z(n,"boxes","nonMaxSuppression","float32"),o=Z(e,"scores","nonMaxSuppression","float32"),a=Rf(r,o,t,s,i);t=a.maxOutputSize,s=a.iouThreshold,i=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:i};return se.runKernel(UE,{boxes:r,scores:o},l)}const lY=ce({nonMaxSuppression_:aY});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cY(n,e,t){const s=uY(n,e,t),i=s<0?-(s+1):s;n.splice(i,0,e)}function uY(n,e,t){return dY(n,e,t||hY)}function hY(n,e){return n>e?1:n<e?-1:0}function dY(n,e,t){let s=0,i=n.length,r=0,o=!1;for(;s<i;){r=s+(i-s>>>1);const a=t(e,n[r]);a>0?s=r+1:(i=r,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NM(n,e,t,s,i){return LM(n,e,t,s,i,0)}function RM(n,e,t,s,i,r){return LM(n,e,t,s,i,0,!1,r,!0)}function DM(n,e,t,s,i,r){return LM(n,e,t,s,i,r,!0)}function LM(n,e,t,s,i,r,o=!1,a=!1,l=!1){const c=[];for(let y=0;y<e.length;y++)e[y]>i&&c.push({score:e[y],boxIndex:y,suppressBeginIndex:0});c.sort(j3);const u=r>0?-.5/r:0,h=[],d=[];for(;h.length<t&&c.length>0;){const y=c.pop(),{score:v,boxIndex:w,suppressBeginIndex:b}=y;if(v<i)break;let S=!1;for(let C=h.length-1;C>=b;--C){const E=fY(n,w,h[C]);if(E>=s){S=!0;break}if(y.score=y.score*pY(s,u,E),y.score<=i)break}y.suppressBeginIndex=h.length,S||(y.score===v?(h.push(w),d.push(y.score)):y.score>i&&cY(c,y,j3))}const f=h.length,m=t-f;a&&m>0&&(h.push(...new Array(m).fill(0)),d.push(...new Array(m).fill(0)));const x={selectedIndices:h};return o&&(x.selectedScores=d),l&&(x.validOutputs=f),x}function fY(n,e,t){const s=n.subarray(e*4,e*4+4),i=n.subarray(t*4,t*4+4),r=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),f=(a-r)*(l-o),m=(h-c)*(d-u);if(f<=0||m<=0)return 0;const x=Math.max(r,c),y=Math.max(o,u),v=Math.min(a,h),w=Math.min(l,d),b=Math.max(v-x,0)*Math.max(w-y,0);return b/(f+m-b)}function pY(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function j3(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function mY(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=Z(n,"boxes","nonMaxSuppressionAsync"),o=Z(e,"scores","nonMaxSuppressionAsync"),a=Rf(r,o,t,s,i);t=a.maxOutputSize,s=a.iouThreshold,i=a.scoreThreshold;const l=await Promise.all([r.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=NM(c,u,t,s,i);return r!==n&&r.dispose(),o!==e&&o.dispose(),Oi(h,"int32")}const gY=mY;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xY(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=Z(n,"boxes","nonMaxSuppression"),a=Z(e,"scores","nonMaxSuppression"),l=Rf(o,a,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r},h=se.runKernel(WE,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const yY=ce({nonMaxSuppressionWithScore_:xY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function vY(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=Z(n,"boxes","nonMaxSuppressionAsync"),a=Z(e,"scores","nonMaxSuppressionAsync"),l=Rf(o,a,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:f}=DM(u,h,t,s,i,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Oi(d,"int32"),selectedScores:Oi(f)}}const wY=vY;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=Z(n,"boxes","nonMaxSuppression"),a=Z(e,"scores","nonMaxSuppression"),l=Rf(o,a,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},f={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:r},m=se.runKernel(VE,d,f);return{selectedIndices:m[0],validOutputs:m[1]}}const SY=ce({nonMaxSuppressionPadded_:bY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _Y(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=Z(n,"boxes","nonMaxSuppressionAsync"),a=Z(e,"scores","nonMaxSuppressionAsync"),l=Rf(o,a,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,f]=await Promise.all([o.data(),a.data()]),{selectedIndices:m,validOutputs:x}=RM(d,f,c,u,h,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Oi(m,"int32"),validOutputs:dn(x,"int32")}}const CY=_Y;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TY(n,e,t=!1,s=!1){const i=Z(n,"images","resizeBilinear");F(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),F(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),F(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=se.runKernel(Yw,a,l);return o?ae(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Uz=ce({resizeBilinear_:TY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IY(n,e,t=!1,s=!1){const i=Z(n,"images","resizeNearestNeighbor");F(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),F(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),F(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),F(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=ae(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=se.runKernel(Kw,a,l);return o?ae(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Vz=ce({resizeNearestNeighbor_:IY});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EY(n,e="binary",t=!1,s=.5){const i=Z(n,"image","threshold"),r=.2989,o=.587,a=.114,l=i.shape[0]*i.shape[1];let c=ne(Oi([s]),255),u,h,d,f;if(F(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),F(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),F(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),F(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[u,h,d]=Ir(i,[1,1,1],-1);const y=ne(u,r),v=ne(h,o),w=ne(d,a);f=Ue(Ue(y,v),w)}else f=n;if(e==="otsu"){const y=LX(it(kz(f),"int32"),YO([]),256);c=MY(y,l)}const m=t?Nf(f,c):Lr(f,c);return it(ne(m,255),"int32")}function MY(n,e){let t=Oi([-1]),s=Oi([0]),i=Oi([0]),r,o,a,l,c,u;for(let h=0;h<n.size-1;h++){r=_n(n,0,h+1),o=_n(n,h+1),c=bt(yt(r),e),u=bt(yt(o),e);const d=yt(ne(r,Lm(0,r.size)));a=bt(d,yt(r));const f=db(o.shape,r.size),m=Ue(Lm(0,o.size),f),x=ne(o,m);l=bt(yt(x),yt(o));const y=Ct(a,l),v=Ct(a,l),w=ne(c,u);i=ne(ne(w,y),v);const b=Lr(i,s);s=cr(b,i,s),t=cr(b,Oi([h]),t)}return t}const kY=ce({threshold_:EY});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AY(n,e,t="nearest",s="constant",i=0,r){const o=Z(n,"image","transform","float32"),a=Z(e,"transforms","transform","float32");F(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),F(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),F(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:s,fillValue:i,outputShape:r};return se.runKernel(ZE,l,c)}const NY=ce({transform_:AY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RY(n,e,t){F(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),F(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const s=Z(n,"a","bandPart");F(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[r,o]=s.shape.slice(-2);if(!(e<=r))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${r}).`);if(!(t<=o))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`);e<0&&(e=r),t<0&&(t=o);const a=ae(Lm(0,r,1,"int32"),[-1,1]),l=Lm(0,o,1,"int32"),c=Ct(a,l),u=pl(Nf(c,dn(+e,"int32")),Sh(c,dn(-t,"int32"))),h=Rs([r,o],s.dtype);return ae(bc(ah(ae(s,[-1,r,o])).map(d=>cr(u,d,h))),i)}const DY=ce({bandPart_:RY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LY(n){let e;if(Array.isArray(n)){e=!1,F(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let r=1;r<n.length;++r)F(n[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${i})`)}else e=!0,n=Ir(n,n.shape[0],0).map(i=>h0(i,[0]));F(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let i=0;i<n.length;++i)t.push(se.tidy(()=>{let r=s[i];if(i>0)for(let o=0;o<i;++o){const a=ne(yt(ne(t[o],r)),t[o]);r=Ct(r,a)}return bt(r,pb(r,"euclidean"))}));return e?bc(t,0):t}const PY=ce({gramSchmidt_:LY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Y(n,e=!1){if(F(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return q3(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=ah(ae(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],r=[];s.forEach(l=>{const[c,u]=q3(l,e);i.push(c),r.push(u)});const o=ae(bc(i,0),n.shape),a=ae(bc(r,0),n.shape);return[o,a]}}function q3(n,e=!1){return se.tidy(()=>{F(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let i=mz(t),r=Ou(n);const o=lm([[1]],[1,1]);let a=Ou(o);const l=t>=s?s:t;for(let c=0;c<l;++c){const u=r,h=a,d=i;[a,r,i]=se.tidy(()=>{const f=_n(r,[c,c],[t-c,1]),m=pb(f),x=_n(r,[c,c],[1,1]),y=cr(Lr(x,0),lm([[-1]]),lm([[1]])),v=Ct(x,ne(y,m)),w=bt(f,v);w.shape[0]===1?a=Ou(o):a=Ui([o,_n(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const b=ps(bt(hn(y,v),m)),S=_n(r,[c,0],[t-c,s]),C=ne(b,a),E=Yt(a);if(c===0)r=Ct(S,hn(C,hn(E,S)));else{const A=Ct(S,hn(C,hn(E,S)));r=Ui([_n(r,[0,0],[c,s]),A],0)}const k=Yt(C),I=_n(i,[0,c],[t,i.shape[1]-c]);if(c===0)i=Ct(I,hn(hn(I,a),k));else{const A=Ct(I,hn(hn(I,a),k));i=Ui([_n(i,[0,0],[t,c]),A],1)}return[a,r,i]}),Gt([u,h,d])}return!e&&t>s&&(i=_n(i,[0,0],[t,s]),r=_n(r,[0,0],[s,s])),[i,r]})}const FY=ce({qr_:$Y});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var K3;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(K3||(K3={}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ku={flipLeftRight:nY,grayscaleToRGB:iY,resizeNearestNeighbor:Vz,resizeBilinear:Uz,rotateWithOffset:oY,cropAndResize:eY,nonMaxSuppression:lY,nonMaxSuppressionAsync:gY,nonMaxSuppressionWithScore:yY,nonMaxSuppressionWithScoreAsync:wY,nonMaxSuppressionPadded:SY,nonMaxSuppressionPaddedAsync:CY,threshold:kY,transform:NY},OY={bandPart:DY,gramSchmidt:PY,qr:FY};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Df{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class no{constructor(){this.classNameMap={}}static getMap(){return no.instance==null&&(no.instance=new no),no.instance}static register(e){no.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function $e(n){F(n.className!=null,()=>"Class being registered does not have the static className property defined."),F(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),F(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),no.register(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zc extends Df{minimize(e,t=!1,s){const{value:i,grads:r}=this.computeGradients(e,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:r[a.name]}));this.applyGradients(o)}else this.applyGradients(r);return Gt(r),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return tq(e,t)}dispose(){this.iterations_!=null&&Gt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:dn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(zc,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wz extends zc{constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=se.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=se.registeredVariables[s],o=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:de(()=>Qt(r).variable(o))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:de(()=>Qt(r).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;de(()=>{const u=Ue(ne(l,this.rho),ne(An(a),1-this.rho)),h=ne(bt(Ti(Ue(c,this.epsilon)),Ti(Ue(l,this.epsilon))),a),d=Ue(ne(c,this.rho),ne(An(h),1-this.rho));l.assign(u),c.assign(d);const f=Ue(ne(h,-this.learningRate),r);r.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Gt(this.accumulatedGrads.map(e=>e.variable)),Gt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gz extends zc{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=se.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:de(()=>db(r.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[i].tensor:e[s];if(o==null)return;const a=this.accumulatedGrads[i].variable;de(()=>{const l=Ue(a,An(o));a.assign(l);const c=Ue(ne(bt(o,Ti(Ue(l,se.backend.epsilon()))),-this.learningRate),r);r.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Gt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hz extends zc{constructor(e,t,s,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],de(()=>{this.accBeta1=dn(t).variable(),this.accBeta2=dn(s).variable()}),i==null&&(this.epsilon=se.backend.epsilon())}static get className(){return"Adam"}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);de(()=>{const s=Ct(1,this.accBeta1),i=Ct(1,this.accBeta2);t.forEach((r,o)=>{const a=se.registeredVariables[r],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:de(()=>Qt(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${r}/v`,variable:de(()=>Qt(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,d=Ue(ne(u,this.beta1),ne(c,1-this.beta1)),f=Ue(ne(h,this.beta2),ne(An(c),1-this.beta2)),m=bt(d,s),x=bt(f,i);u.assign(d),h.assign(f);const y=Ue(ne(bt(m,Ue(Ti(x),this.epsilon)),-this.learningRate),a);a.assign(y)}),this.accBeta1.assign(ne(this.accBeta1,this.beta1)),this.accBeta2.assign(ne(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Gt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Gt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),de(()=>{this.accBeta1.assign(cf(this.beta1,this.iterations_+1)),this.accBeta2.assign(cf(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xz extends zc{constructor(e,t,s,i=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],de(()=>{this.iteration=dn(0).variable(),this.accBeta1=dn(t).variable()}),i==null&&(this.epsilon=se.backend.epsilon())}static get className(){return"Adamax"}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);de(()=>{const s=Ct(1,this.accBeta1),i=bt(-this.learningRate,Ue(ne(this.iteration,this.decay),1));t.forEach((r,o)=>{const a=se.registeredVariables[r],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:Qt(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${r}/v`,variable:Qt(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,d=Ue(ne(u,this.beta1),ne(c,1-this.beta1)),f=ne(h,this.beta2),m=yi(c),x=Oc(f,m);u.assign(d),h.assign(x);const y=Ue(ne(bt(i,s),bt(d,Ue(x,this.epsilon))),a);a.assign(y)}),this.iteration.assign(Ue(this.iteration,1)),this.accBeta1.assign(ne(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Gt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Gt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PM extends zc{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}static get className(){return"SGD"}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=Array.isArray(e)?e[i].tensor:e[s];if(r==null)return;const o=se.registeredVariables[s];de(()=>{const a=Ue(ne(this.c,r),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=_a(dn(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jz extends PM{constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=dn(this.momentum)}static get className(){return"Momentum"}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=se.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:de(()=>Qt(r).variable(!1))});const o=this.accumulations[i].variable,a=Array.isArray(e)?e[i].tensor:e[s];a!=null&&de(()=>{let l;const c=Ue(ne(this.m,o),a);this.useNesterov?l=Ue(ne(this.c,Ue(a,ne(c,this.m))),r):l=Ue(ne(this.c,c),r),o.assign(c),r.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Gt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qz extends zc{constructor(e,t=.9,s=0,i=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=se.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=se.registeredVariables[s],o=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:de(()=>Qt(r).variable(o))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:de(()=>Qt(r).variable(o))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:de(()=>Qt(r).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;de(()=>{const u=Ue(ne(l,this.decay),ne(An(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,d=Ue(ne(h,this.decay),ne(a,1-this.decay)),f=bt(ne(a,this.learningRate),Ti(Ct(u,Ue(An(d),this.epsilon)))),m=Ue(ne(c,this.momentum),f);l.assign(u),h.assign(d),c.assign(m);const x=Ct(r,m);r.assign(x)}else{const h=Ue(ne(l,this.decay),ne(An(a),1-this.decay)),d=Ue(ne(c,this.momentum),bt(ne(a,this.learningRate),Ti(Ue(h,this.epsilon))));l.assign(h),c.assign(d);const f=Ct(r,d);r.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Gt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Gt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Gt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zY=[Wz,Gz,Hz,Xz,jz,qz,PM];function BY(){for(const n of zY)$e(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UY="model",VY=".json",WY=".weights.bin";function Y3(n){return new Promise(e=>setTimeout(e)).then(n)}class lh{constructor(e){if(!xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(lh.URL_SCHEME)&&(e=e.slice(lh.URL_SCHEME.length)),(e==null||e.length===0)&&(e=UY),this.modelJsonFileName=e+VY,this.weightDataFileName=e+WY}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=JO(e,s),r=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=r,await Y3(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await Y3(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ub(e)}}}}lh.URL_SCHEME="downloads://";const GY=n=>xe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(lh.URL_SCHEME)?HY(n.slice(lh.URL_SCHEME.length)):null;ks.registerSaveRouter(GY);function HY(n="model"){return new lh(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3(n,e,t,s){o(n),t=t==null?0:t,s=s==null?1:s,a(t,s);let i=0;const r=l=>(l.then(c=>{const u=t+ ++i/n.length*(s-t);return e(u),c}),l);function o(l){F(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){F(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),F(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),F(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function XY(n,e){e==null&&(e={});const t=e.fetchFunc==null?xe().platform.fetch:e.fetchFunc,s=n.map(h=>t(h,e.requestInit,{isBinary:!0})),i=0,r=.5,a=(e.onProgress==null?await Promise.all(s):await Z3(s,e.onProgress,i,r)).map(h=>h.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(a):await Z3(a,e.onProgress,l,c)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jY="application/octet-stream",qY="application/json";class $M{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(F(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=xe().platform.fetch,F(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&F(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=JO(e,s);t.body.append("model.json",new Blob([JSON.stringify(i)],{type:qY}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:jY}),"model.weights.bin");const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:ub(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=t.modelTopology,i=t.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return v9(t,r=>this.loadWeights(r))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=KY(t),r=this.weightPathPrefix||s,o=w9(e),a=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(r+h+i);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await XY(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,ZO(c)]}}$M.URL_SCHEME_REGEX=/^https?:\/\//;function KY(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),i=t>e?n.substring(t):"";return[s+"/",i]}function J3(n){return n.match($M.URL_SCHEME_REGEX)!=null}const Kz=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>J3(s)):t=J3(n),t)return YY(n,e)}return null};ks.registerSaveRouter(Kz);ks.registerLoadRouter(Kz);function YY(n,e){return new $M(n,e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ZY(n,e){let t=Z(n,"img","toPixels");if(!(n instanceof ts)){const c=t;t=it(c,"int32"),c.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[s,i]=t.shape.slice(0,2),r=t.rank===2?1:t.shape[2];if(r>4||r===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${r}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*s*4);for(let c=0;c<s*i;++c){const u=[0,0,0,255];for(let d=0;d<r;d++){const f=o[c*r+d];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);r===1?(u[0]=f*a,u[1]=f*a,u[2]=f*a):u[d]=f*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){e.width=i,e.height=s;const c=e.getContext("2d"),u=new ImageData(l,i,s);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}function FM(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(Se(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=e.shape,r=i[i.length-1];let o=1;for(let h=0;h<i.length-1;++h)o*=i[h];const a=n.shape,l=i.slice();l.pop();let c=1;for(let h=r;h<t;++h)c*=a[h],l.push(a[h]);const u=[...mt(n.shape).map(h=>h/c),1].slice(0,r);return[l,o,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aT=-2,JY=-1;function OM(n,e,t){const s=n.shape.length;F(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),F(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)F(e[i]+t[i]<=n.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function QY(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function zM(n,e,t){const s=[];for(let i=0;i<n.length;i++)s[i]=Math.ceil((e[i]-n[i])/t[i]);return s}function Yz(n,e,t,s){const i=[...n];for(let r=i.length;r<s.length;r++)i.push(1);for(let r=0;r<t;r++)r===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function Zz(n,e,t){return t<=n?t:t-(e-1)}function Jz(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function eZ(n,e,t,s,i,r,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&t>0){const f=e[0],m=t+1;u=Qz(o,f,m,s,n),h=e4(a,f,m,i,n),d=Yz(r,f,m,n)}else for(let f=0;f<c;f++)u[f]=n4(o,s,r,n,f,l),h[f]=s4(a,i,r,n,f,l),d[f]=t4(r,f,l);return{begin:u,end:h,strides:d}}function Qz(n,e,t,s,i){const r=[...i],o=Jz(t,e);for(let a=0;a<r.length;a++)if(o.indexOf(a)>-1)r[a]=0;else{const l=Zz(e,t,a);let c=s[l];n&1<<l&&(c=0),r[a]=c}return r}function e4(n,e,t,s,i){const r=[...i],o=Jz(t,e);for(let a=0;a<r.length;a++)if(o.indexOf(a)>-1)r[a]=Number.MAX_SAFE_INTEGER;else{const l=Zz(e,t,a);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),r[a]=c}for(let a=0;a<r.length;a++){const l=i[a];r[a]<0&&(r[a]+=l),r[a]=Qu(0,r[a],i[a])}return r}function t4(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function n4(n,e,t,s,i,r){let o=e[i];const a=t[i]||1;(n&1<<i||r&1<<i||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),o=Qu(0,o,l-1),o}function s4(n,e,t,s,i,r){let o=e[i];const a=t[i]||1;(n&1<<i||r&1<<i||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),a>0?o=Qu(0,o,l):o=Qu(-1,o,l-1),o}function BM(n,e,t){let s=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){s=i;break}for(let i=s+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function UM(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function xb(n,e,t){let s;const i=n.shape.length;typeof e=="number"?s=[e,...new Array(i-1).fill(0)]:e.length<i?s=e.concat(new Array(i-e.length).fill(0)):s=e.slice(),s.forEach(o=>{F(o!==-1,()=>"slice() does not support negative begin indexing.")});let r;return t==null?r=new Array(i).fill(-1):typeof t=="number"?r=[t,...new Array(i-1).fill(-1)]:t.length<i?r=t.concat(new Array(i-t.length).fill(-1)):r=t,r=r.map((o,a)=>o>=0?o:(F(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,r]}function VM(n,e,t,s,i,r,o,a,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)u&&(1<<b&a)!==0&&h.numAddAxisAfterEllipsis++,1<<b&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};tZ(h,d);let f=!0,m=!0,x=!0;const y=[],v=[];for(let b=0;b<n.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const S=!!(d.shrinkAxisMask&1<<b),C=n[b];if(C===-1){y.push(S?1:-1);continue}const E=[d.beginMask&1<<b,d.endMask&1<<b],k=[d.strides[b]>0?0:-1,d.strides[b]>0?C:C-1];if(S&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&d.strides[b]===1;const I=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(S){const V=d.begin[b]<0?C+d.begin[b]:d.begin[b];if(d.begin[b]=V,d.end[b]=d.begin[b]+1,V<0||V>=C)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=Q3(d.begin[b],0,d.strides[b],C,E,k),d.end[b]=Q3(d.end[b],1,d.strides[b],C,E,k);const L=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===C;f=f&&L,m=m&&(b===0&&d.strides[b]===1||L)}else f=f&&d.strides[b]===1&&I,m=m&&(b===0&&d.strides[b]===1||I);let A,N=!1;if(d.beginValid&&d.endValid?(A=d.end[b]-d.begin[b],N=!0):S?(A=1,N=!0):I&&C>=0&&(d.strides[b]<0?A=-C:A=C,N=!0),N){let L;A===0||A<0!=d.strides[b]<0?L=0:L=Math.trunc(A/d.strides[b])+(A%d.strides[b]!==0?1:0),y.push(L)}else y.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const S=d.finalShapeGatherIndices[b];S>=0?v.push(y[S]):S===aT&&v.push(1)}return{finalShapeSparse:v.filter((b,S)=>d.finalShapeGatherIndices[S]!==aT),finalShape:v,isIdentity:f,sliceDim0:m,isSimpleSlice:x,begin:d.begin,end:d.end,strides:d.strides}}function tZ(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const i=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(aT),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(JY),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function Q3(n,e,t,s,i,r){if(i[e])return t>0?r[e]:r[e+1&1];{const o=n<0?s+n:n;return o<r[0]?r[0]:o>r[1]?r[1]:o}}const nZ=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:OM,maskToAxes:QY,computeOutShape:zM,stridesWithElidedDims:Yz,getNormalizedAxes:eZ,startIndicesWithElidedDims:Qz,stopIndicesWithElidedDims:e4,stridesForAxis:t4,startForAxis:n4,stopForAxis:s4,isSliceContinous:BM,computeFlatOffset:UM,parseSliceParams:xb,sliceInfo:VM},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sZ{static sgd(e){return new PM(e)}static momentum(e,t,s=!1){return new jz(e,t,s)}static rmsprop(e,t=.9,s=0,i=null,r=!1){return new qz(e,t,s,i,r)}static adam(e=.001,t=.9,s=.999,i=null){return new Hz(e,t,s,i)}static adadelta(e=.001,t=.95,s=null){return new Wz(e,t,s)}static adamax(e=.002,t=.9,s=.999,i=null,r=0){return new Xz(e,t,s,i,r)}static adagrad(e,t=.1){return new Gz(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mu=sZ;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iZ=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function i4(){return new Promise(n=>iZ(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WM(n,e){const t=n[0].length;n.forEach((i,r)=>{F(i.length===t,()=>`Error in concat${t}D: rank of tensors[${r}] must be the same as the rank of the rest (${t})`)}),F(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((i,r)=>{for(let o=0;o<t;o++)F(o===e||i[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function Ca(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Lo;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Lo||(Lo={}));function r4(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let i=1;i<t.length;++i){const r=t[i],o=s[s.length-t.length+i],a=s[o];if(r>=0)if(a>=0){if(a!==r)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+n}] = ${r} but shape[${i+n}] = ${a}`)}else s[o]=r}return s}function o4(n){const e={FIRST_DIM_SIZE:Lo.FIRST_DIM_SIZE,VALUE_ROWIDS:Lo.VALUE_ROWIDS,ROW_LENGTHS:Lo.ROW_LENGTHS,ROW_SPLITS:Lo.ROW_SPLITS,ROW_LIMITS:Lo.ROW_LIMITS,ROW_STARTS:Lo.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function a4(n){return n.length===0?0:n[0]===Lo.FIRST_DIM_SIZE?n.length-1:n.length}function l4(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(t,s-1);++i){const r=n[i],o=e[i+1];if(r>=0&&o>=0&&r!==1&&r!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-n.length}] = ${r} but ragged tensor input.flatValues.shape[${i-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GM=30;function yb(n){return n<=GM?n:V2(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HM(n,e,t){const s=t*(typeof n=="number"?n:n[0]),i=e*(typeof n=="number"?n:n[1]);return[s,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0(n,e,t,s=!0){let i=[];if(s)i=i.concat(e.slice(0)),i.push(n[0]/t),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const r=e.length;for(let o=0;o<r;++o)i=i.concat([n[o+1]/e[o],e[o]]);i=i.concat(n.slice(r+1))}return i}function m0(n,e,t=!0){const s=[];if(t){s.push(e);for(let i=e+1;i<n;++i)i<=2*e?(s.push(i),s.push(i-(e+1))):s.push(i)}else{const i=[],r=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?r.push(o):i.push(o);s.push(...i),s.push(0),s.push(...r)}return s}function g0(n,e,t,s=!0){const i=[];s?i.push(n[0]/t):i.push(n[0]*t);for(let r=1;r<n.length;++r)r<=e.length?s?i.push(e[r-1]*n[r]):i.push(n[r]/e[r-1]):i.push(n[r]);return i}function XM(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function jM(n,e,t){const s=n.slice(0,1);for(let i=0;i<t;++i)s.push(n[i+1]-e[i][0]-e[i][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vb=1.7580993408473768,wb=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qM=.3275911,KM=.254829592,YM=-.284496736,ZM=1.421413741,JM=-1.453152027,QM=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ml(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function c4(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function u4(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=0;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function h4(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=2;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function ek(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function d4(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function f4(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const r=(e?2:-2)*Math.PI*(i/n);t[i]=Math.cos(r),s[i]=Math.sin(r)}return{real:t,imag:s}}function p4(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),i=Math.cos(s),r=Math.sin(s);return{real:i,imag:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_="->",rZ=/->/g,eD=",",tD="...";function tk(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(rZ,"").length)/z_.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${z_}").`);const[s,i]=n.split(z_);F(s.indexOf(tD)===-1,()=>`The ellipsis notation ("${tD}") is not supported yet.`);const r=s.split(eD),o=r.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<i.length;++d){const f=i[d];if(!r.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<s.length;++d){const f=s[d];a.indexOf(f)===-1&&f!==eD&&a.push(f)}const l=new Array(r.length);for(let d=0;d<o;++d){if(new Set(r[d].split("")).size!==r[d].length)throw new Error(`Found duplicate axes in input component ${r[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let f=0;f<r[d].length;++f)l[d].push(a.indexOf(r[d][f]))}const c=a.length,u=i.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function nk(n,e){let t=new Array(n);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const s=[];for(let i=0;i<n;++i)t[i]===-1&&s.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:s}}function sk(n,e,t){const s=new Array(n);for(let i=0;i<t.length;++i){const r=t[i].shape;for(let o=0;o<e[i].length;++o)s[e[i][o]]===void 0?s[e[i][o]]=r[o]:F(s[e[i][o]]===r[o],()=>`Expected dimension ${s[e[i][o]]} at axis ${o} of input shaped ${JSON.stringify(r)}, but got dimension ${r[o]}`)}}function ik(n,e){const t=n,s=[];let i=0;n.length===0&&t.push(-1),i=n.length+1;for(let o=0;o<i;++o)s.push([]);const r=[];for(let o=0;o<t.length;++o){const a=t[o],l=oZ(e,a);for(const c of l)r.indexOf(c)===-1&&(s[o].push(c),r.push(c))}return{path:t,steps:s}}function rk(n){return n.every((e,t)=>e===t)}function oZ(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function ok(n,e,t=0){let s=[];if(typeof e=="number")F(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const i=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);F(i<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(r!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[r]=n.shape[t]-o}F(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function g4(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function x4(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function v4(n,e){return`size ${n} must be non-negative, not ${e}`}function w4(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function b4(n,e){const t=Se(n),s=Se(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function S4(n,e){const t=Se(n),s=Se(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lT(){return"segment ids must be >= 0"}function _4(){return"segment ids are not increasing"}function C4(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function T4(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I4(n,e){let t=!1,s;for(n<=GM?(s=n,t=!0):s=V2(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=V2(n,s+1);return s}function E4(n,e,t){const s=[],i=n.length;for(let r=0;r<i;r++)r!==e?s.push(n[r]):s.push(t);return s}function ak(n,e,t,s){const i=e.shape.length,r=n.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>r)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<s;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=s;h<i;h++)a.push(e.shape[h]);for(let h=t+1;h<r;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const aZ=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:I4,computeOutShape:E4,collectGatherOpShapeInfo:ak},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ch(n){try{return n.map(e=>wc(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function M4(n){return n.map(e=>fc(e))}const lZ=Object.freeze(Object.defineProperty({__proto__:null,slice_util:nZ,segment_util:aZ,fromUint8ToStringArray:ch,fromStringArrayToUint8:M4,upcastType:lr,axesAreInnerMostDims:uM,combineLocations:fz,computeOutAndReduceShapes:Fs,expandShapeToKeepDim:ms,assertAxesAreInnerMostDims:Zs,getAxesPermutation:Wn,getUndoAxesPermutation:Fc,getInnerMostAxes:is,getBroadcastDims:lf,getReductionAxes:Is,assertAndGetBroadcastShape:Mt,assertParamsConsistent:WM,computeOutShape:Ca,computeDilation2DInfo:c0,computePool2DInfo:go,computePool3DInfo:wl,computeConv2DInfo:Ys,computeConv3DInfo:$c,computeDefaultPad:sM,tupleValuesAreOne:sh,eitherStridesOrDilationsAreOne:ai,stridesOrDilationsArePositive:ih,convertConv2DDataFormat:bl,checkPadOnDimRoundingMode:Hi,getFusedDyActivation:EM,getFusedBiasGradient:MM,applyActivation:kM,shouldFuse:AM,get RowPartitionType(){return Lo},combineRaggedTensorToTensorShapes:r4,getRowPartitionTypesHelper:o4,getRaggedRank:a4,validateDefaultValueShape:l4,PARALLELIZE_THRESHOLD:GM,computeOptimalWindowSize:yb,getImageCenter:HM,getReshaped:p0,getPermuted:m0,getReshapedPermuted:g0,getSliceBeginCoords:XM,getSliceSize:jM,prepareAndValidate:FM,validateUpdateShape:Bz,validateInput:UK,calculateShapes:f0,SELU_SCALEALPHA:vb,SELU_SCALE:wb,ERF_P:qM,ERF_A1:KM,ERF_A2:YM,ERF_A3:ZM,ERF_A4:JM,ERF_A5:QM,warn:wr,log:W7,mergeRealAndImagArrays:ml,splitRealAndImagArrays:c4,complexWithEvenIndex:u4,complexWithOddIndex:h4,getComplexWithIndex:ek,assignToTypedArray:d4,exponents:f4,exponent:p4,decodeEinsumEquation:tk,getEinsumPermutation:nk,checkEinsumDimSizes:sk,getEinsumComputePath:ik,isIdentityPermutation:rk,prepareSplitSize:ok,getSparseFillEmptyRowsIndicesDenseShapeMismatch:m4,getSparseFillEmptyRowsNegativeIndexErrorMessage:g4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:x4,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:y4,getSparseReshapeNegativeOutputDimErrorMessage:v4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:w4,getSparseReshapeInputOutputMultipleErrorMessage:b4,getSparseReshapeInputOutputMismatchErrorMessage:S4,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:lT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:_4,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:C4,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:T4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */BY();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k4={kernelName:aw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,d0(it(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cZ={kernelName:pg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=An(it(t,"float32")),i=Ti(Ct(dn(1),s));return ps(bt(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uZ={kernelName:mg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ti(Ct(An(it(t,"float32")),1));return bt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hZ={kernelName:kf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{let a=n;const l=Is(t.shape,i);return l.length>0&&(a=yt(a,l)),ae(a,t.shape)},b:()=>{let a=n;const l=Is(s.shape,i);return l.length>0&&(a=yt(a,l)),ae(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dZ={kernelName:gE,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,i)=>{t[i]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fZ={kernelName:lw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Qt(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pZ={kernelName:cw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Qt(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZ={kernelName:gg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,Ti(Ct(dn(1),An(it(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gZ={kernelName:xg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Ti(Ue(dn(1),An(it(t,"float32"))));return bt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xZ={kernelName:wg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=Ue(An(t),An(s));let l=ne(n,bt(s,a));const c=Is(t.shape,i);return c.length>0&&(l=yt(l,c)),ae(l,t.shape)},b:()=>{const a=Ue(An(t),An(s));let l=ps(ne(n,bt(t,a)));const c=Is(s.shape,i);return c.length>0&&(l=yt(l,c)),ae(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZ={kernelName:yg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,Ue(An(it(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vZ={kernelName:vg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,Ct(dn(1),An(it(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(n,e,t,s,i,r){const o=Z(n,"dy","avgPool3dGrad"),a=Z(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=ae(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ae(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),F(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),F(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Hi("avgPool3dGrad",i,r);const h={dy:l,input:c},d={filterSize:t,strides:s,pad:i,dimRoundingMode:r},f=se.runKernel(wE,h,d);return u?ae(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const bZ=ce({avgPool3dGrad_:wZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ={kernelName:hw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:o,dimRoundingMode:a}=t;return{x:()=>bZ(n,s,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Z(n,e,t,s,i){const r=Z(n,"dy","avgPoolGrad"),o=Z(e,"input","avgPoolGrad");F(o.rank===r.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${r.rank})`);let a=o,l=r,c=!1;o.rank===3&&(c=!0,a=ae(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ae(r,[1,r.shape[0],r.shape[1],r.shape[2]])),F(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),F(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},h={filterSize:t,strides:s,pad:i},d=se.runKernel(vE,u,h);return c?ae(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const CZ=ce({avgPoolGrad_:_Z});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TZ={kernelName:uw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:o}=t;return{x:()=>CZ(n,s,i,r,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IZ={kernelName:dw,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,i]=e,{transposeA:r,transposeB:o}=t;return!r&&!o?{a:()=>hn(n,i,!1,!0),b:()=>hn(s,n,!0,!1)}:!r&&o?{a:()=>hn(n,i,!1,!1),b:()=>hn(n,s,!0,!1)}:r&&!o?{a:()=>hn(i,n,!1,!0),b:()=>hn(s,n,!1,!1)}:{a:()=>hn(i,n,!0,!0),b:()=>hn(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EZ={kernelName:fw,gradFunc:(n,e,t)=>{const{blockShape:s,crops:i}=t;return{x:()=>wM(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MZ={kernelName:B7,gradFunc:(n,e,t)=>{const s=t,i=s.inputShape,r=s.shape,o=Array.from(r);for(let l=i.length-1;l>=0;l--)if(i[l]===r[l])o[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>yt(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kZ={kernelName:bg,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZ={kernelName:Sg,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZ={kernelName:_g,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:i,clipValueMax:r}=t;return{x:()=>cr(pl(Sh(s,i),Nf(s,r)),n,Qt(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RZ={kernelName:pw,inputsToSave:["x"],gradFunc:k4.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZ={kernelName:mw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:i}=t,r=Ut(i,e[0].shape)[0],o=s.map(l=>l[r]);return Ir(n,o,r).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LZ={kernelName:gw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{dilations:r,strides:o,pad:a,dataFormat:l}=t;return F(sh(r),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`),{x:()=>aM(s.shape,n,i,o,a,l),filter:()=>IM(s,n,i.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZ={kernelName:xw,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{strides:r,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>rh(n,i,r,o,a,1,l),filter:()=>IM(n,s,i.shape,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(n,e,t,s,i){let r=n;n.rank===4&&(r=ae(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ae(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),F(r.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`),F(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),F(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),F(r.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${t[3]}.`),F(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:r,dy:o},l={strides:s,pad:i,filterShape:t};return se.runKernel(CE,a,l)}const FZ=ce({conv3DBackpropFilter_:$Z});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OZ={kernelName:yw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r}=t;F(sh(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>uz(o.shape,n,a,i,r),filter:()=>FZ(o,n,a.shape,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zZ={kernelName:Cg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(ps(Dz(it(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BZ={kernelName:Tg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(Lz(it(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UZ={kernelName:vw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i,exclusive:r,reverse:o}=t;return{x:()=>{const a=Wn([i],s.rank);let l=dz(n,i,r,!o);return a!=null&&(l=Yt(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VZ={kernelName:ww,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r,dimRoundingMode:o}=t,a=s==null?[1,1]:s;F(sh(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return F(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),F(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),F(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),F(ai(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),Hi("depthwiseConv2d",r,o),{x:()=>ZK(l.shape,n,c,i,r,a,o),filter:()=>KK(l,n,c.shape,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WZ={kernelName:bw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,r={x:s,filter:i,dy:n},o={x:s,filter:i,dy:n};return{x:()=>se.runKernel(W2,r,t),filter:()=>se.runKernel(G2,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ={kernelName:Eg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>se.runKernel(RE,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZ={kernelName:Mg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=ne(fl(ps(An(t))),2/Math.sqrt(Math.PI));return{x:()=>ne(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZ={kernelName:kg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jZ={kernelName:_w,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ae(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qZ={kernelName:Ag,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,fl(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KZ={kernelName:Ng,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YZ={kernelName:Rg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=bt(n,it(s,"float32")),l=Is(t.shape,i);return l.length>0?ae(yt(a,l),t.shape):a},b:()=>{let a=ne(n,it(t,"float32"));const l=Is(s.shape,i);l.length>0&&(a=ae(yt(a,l),s.shape));const c=An(s);return ps(bt(a,it(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZZ={kernelName:Cw,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[i,r,o,a]=e,l=a==null?dn(1):a,c=Is(r.shape,i.shape),u=[];if(r.rank===1){for(let S=0;S<i.shape.length-1;++S)u.push(i.shape[S]);u.push(1)}const h=Ct(i,r),d=ne(n,l),f=Az(Ue(o,dn(s))),m=ne(ne(ne(f,f),f),dn(-.5));return{x:()=>r.rank===1?ae(ne(ne(n,Po(ae(f,[1,1,1,r.shape[0]]),u)),l),i.shape):ae(ne(ne(n,f),l),i.shape),mean:()=>{let S=ne(ne(f,dn(-1)),d);return r.rank===1&&(S=yt(S,c)),ae(S,r.shape)},variance:()=>{let S=ne(ne(m,h),d);return r.rank===1&&(S=yt(S,c)),ae(S,r.shape)},scale:()=>{const S=ne(h,f);let C=ne(n,S);return r.rank===1&&(C=yt(C,c)),ae(C,r.shape)},offset:()=>{let S=n;return r.rank===1&&(S=yt(S,c)),ae(S,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JZ={kernelName:Tw,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,i]=e,{axis:r}=t,o=Ut(r,s.shape)[0];return{x:()=>{const l=s.shape,c=i.size,u=l.slice(0,o),h=u.length,d=l.slice(r,l.length).slice(1),f=d.length,m=nD(0,h),x=nD(h+1,h+1+f),y=sD([u,[c],d]),v=ae(n,y),w=ae(i,[c]),b=sD([[h],m,x]),S=Yt(v,b);let C=Oz(S,w,s.shape[o]);const E=Fc(b);return C=Yt(C,E),C},indices:()=>i}}};function nD(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function sD(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QZ={kernelName:Dg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Qt(t),b:()=>Qt(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eJ={kernelName:Lg,gradFunc:n=>({x:()=>it(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tJ={kernelName:Pg,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nJ={kernelName:$g,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJ={kernelName:Fg,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iJ={kernelName:Ew,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:i}=t,r=Lr(s,0);return{x:()=>cr(r,n,ne(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rJ={kernelName:zg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,Ue(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oJ={kernelName:Og,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,it(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aJ={kernelName:U7,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;return{logits:()=>{const o=fl(s);return Ct(n,ne(yt(n,i,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(n,e,t,s=5,i=1,r=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:s,bias:i,alpha:r,beta:o};return se.runKernel(OE,a,l)}const cJ=ce({localResponseNormalizationBackprop_:lJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uJ={kernelName:Dw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{depthRadius:r,bias:o,alpha:a,beta:l}=t;return{x:()=>cJ(s,i,n,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4(n,e,t,s){return e.rank<t.rank&&(e=ae(e,ms(e.shape,s))),n.rank<t.rank&&(n=ae(n,ms(n.shape,s))),{x:()=>ne(n,it(Ma(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iD={kernelName:Lw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:i}=s,r=e[0],o=e[1],a=Ut(i,r.shape),l=A4(n,o,r,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hJ={kernelName:Bg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ne(n,it(Sh(t,s),"float32")),b:()=>ne(n,it(gz(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJ(n,e,t,s,i,r,o){const a=Z(n,"dy","maxPool3dGrad"),l=Z(e,"input","maxPool3dGrad"),c=Z(t,"output","maxPool3dGrad");let u=a,h=l,d=c,f=!1;l.rank===4&&(f=!0,u=ae(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ae(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=ae(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),F(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),F(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),F(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Hi("maxPool3dGrad",r,o);const m={dy:u,input:h,output:d},x={filterSize:s,strides:i,pad:r,dimRoundingMode:o},y=se.runKernel(BE,m,x);return f?ae(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const fJ=ce({maxPool3dGrad_:dJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pJ={kernelName:$w,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>fJ(n,s,i,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(n,e,t,s,i,r,o){const a=Z(n,"dy","maxPoolGrad"),l=Z(e,"input","maxPoolGrad"),c=Z(t,"output","maxPoolGrad");F(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),F(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),F(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Hi("maxPoolGrad",r,o);const u={dy:a,input:l,output:c},h={filterSize:s,strides:i,pad:r,dimRoundingMode:o};return se.runKernel(zE,u,h)}const gJ=ce({maxPoolGrad_:mJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xJ={kernelName:Pw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:o,pad:a}=t;return{x:()=>gJ(n,s,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yJ={kernelName:Fw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t,r=Ut(i,s.shape),a=Fs(s.shape,r)[1],l=Se(a);return{x:()=>{const u=s.shape.slice();r.forEach(f=>{u[f]=1});const h=ae(n,u);return bt(ne(h,_h(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vJ={kernelName:Ow,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:i}=s,[r,o]=e,a=Ut(i,r.shape),l=A4(n,o,r,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wJ={kernelName:Ug,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ne(n,it(Nf(t,s),"float32")),b:()=>ne(n,it(Lr(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bJ={kernelName:zw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(o=>o[0]);return{x:()=>_n(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SJ={kernelName:Vg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=Is(t.shape,i);return a.length>0?ae(yt(n,a),t.shape):n},b:()=>{const a=ne(n,ps(mb(bt(t,s)))),l=Is(s.shape,i);return l.length>0?ae(yt(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _J={kernelName:Wg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=ne(n,it(s,"float32")),l=Is(t.shape,i);return l.length>0?ae(yt(a,l),t.shape):a},b:()=>{const a=ne(n,it(t,"float32")),l=Is(s.shape,i);return l.length>0?ae(yt(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CJ={kernelName:Bw,gradFunc:n=>({x:()=>ps(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TJ={kernelName:Ww,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>Rs(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IJ={kernelName:Vw,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EJ={kernelName:Gw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return ah(n,s).map(r=>()=>r)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rD={kernelName:Hw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(o=>o[0]);return{x:()=>_n(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MJ={kernelName:Gg,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,i]=e,r=t,o=s,a=Mt(r.shape,o.shape);return{a:()=>{const u=it(o,"float32");let h=ne(n,ne(u,cf(r,Ct(u,dn(1)))));const d=Is(r.shape,a);return d.length>0&&(h=yt(h,d)),ae(h,r.shape)},b:()=>{const u=Lr(r,0),h=cr(u,ka(r),Qt(r));let d=ne(n,ne(i,h));const f=Is(o.shape,a);return f.length>0&&(d=yt(d,f)),ae(d,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kJ={kernelName:Xw,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,i=Lr(t,0);return{x:()=>cr(i,n,ne(n,s)),alpha:()=>{let r=cr(i,Qt(n),ne(n,t));const o=Is(s.shape,n.shape);return o.length>0&&(r=yt(r,o)),ae(r,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(n,e,t){const s=n.shape.slice();s[t]=1;const i=ae(e,s),r=rT(n,t,!0,!1),o=rT(n,t,!0,!0),a=ne(r,o);return ne(i,a)}function NJ(n,e,t){const s=n.shape.length,i=s-t.length,r=Wn(t,s);let o=n;r!=null&&(o=Yt(n,r));const a=o.shape.slice(),c=a.splice(s-t.length,t.length).reduce((d,f)=>d*f,1);a.push(c);const u=o.reshape(a);let h=AJ(u,e,i);if(h=h.reshape(o.shape),r!=null){const d=Fc(r);h=Yt(h,d)}return h}const RJ={kernelName:jw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;let r=[];return i==null?r=s.shape.map((o,a)=>a):typeof i=="number"?r=[i]:r=i,{x:()=>NJ(s,n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DJ={kernelName:Ig,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{const a=bt(n,it(s,"float32")),l=Is(t.shape,i);return l.length>0?ae(yt(a,l),t.shape):a},b:()=>{let a=ne(n,it(t,"float32"));const l=Is(s.shape,i);l.length>0&&(a=ae(yt(a,l),s.shape));const c=An(s);return ps(bt(a,it(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LJ={kernelName:Hg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,ps(An(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PJ={kernelName:jg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=ne(Nf(t,6),d0(t));return{x:()=>ne(n,it(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $J={kernelName:Xg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,it(d0(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FJ={kernelName:qw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ae(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OJ={kernelName:Yw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>se.runKernel(jE,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zJ={kernelName:Kw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>se.runKernel(XE,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BJ={kernelName:Zw,gradFunc:(n,e,t)=>{const{dims:s}=t,i=Ut(s,n.shape);return{x:()=>oh(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UJ={kernelName:qg,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VJ={kernelName:Kg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ps(bt(n,ne(cf(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WJ={kernelName:Jw,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>it(Qt(t),"float32"),t:()=>ne(n,it(t,n.dtype)),e:()=>ne(n,it(pM(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GJ={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Lr(t,dn(0)),i=dn(vb),r=dn(wb),o=ne(n,r),a=ne(ne(n,i),fl(it(t,"float32")));return cr(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HJ={kernelName:e0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,ne(t,Ct(dn(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XJ={kernelName:Qg,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jJ={kernelName:Zg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(lM(it(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qJ={kernelName:Jg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(hz(it(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJ={kernelName:Qw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:i,size:r}=t,o=s.shape,[a,l]=xb(s,i,r),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>vM(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJ={kernelName:sb,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:i}=t,r=!0,o=ne(n,s);return{logits:()=>Ct(o,ne(yt(o,[i],r),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZJ={kernelName:t0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,Af(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oD={kernelName:tb,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:i}=t;return{x:()=>oM(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aD={kernelName:nb,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>Ui(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JJ={kernelName:n0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,ne(Ti(it(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QJ={kernelName:qE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(n,ne(it(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eQ={kernelName:s0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=dn(2);return{a:()=>ne(n,ne(i,Ct(t,s))),b:()=>ne(n,ne(i,Ct(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tQ={kernelName:l0,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nQ={kernelName:i0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mt(t.shape,s.shape);return{a:()=>{let a=n;const l=Is(t.shape,i);return l.length>0&&(a=yt(a,l)),ae(a,t.shape)},b:()=>{let a=n;const l=Is(s.shape,i);return l.length>0&&(a=yt(a,l)),ae(ps(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sQ={kernelName:eb,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,i=s.shape.slice(),{axis:r}=t;Ut(r,s.shape).forEach(c=>{i[c]=1});const a=ae(n,i),l=ne(a,_h(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iQ={kernelName:r0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bt(n,An(lM(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rQ={kernelName:o0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ne(Ct(dn(1),An(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oQ={kernelName:a0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:i}=t;return{x:()=>{let o=Qt(s);if(s.rank===1)for(let a=0;a<i[0];++a)o=Ue(o,_n(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)o=Ue(o,_n(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)o=Ue(o,_n(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)for(let u=0;u<i[3];++u)o=Ue(o,_n(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2],u*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aQ={kernelName:Hd,gradFunc:(n,e,t)=>{const s=t,{perm:i}=s,r=Fc(i);return{x:()=>Yt(n,r)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lQ={kernelName:ib,gradFunc:(n,e,t)=>{const s=t,{axis:i}=s;return{value:()=>bc(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cQ={kernelName:rb,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>uQ(n,t)}}};function uQ(n,e){const t=Oc(e,Qt(e)),s=hM(n,t);let i=Sh(e,dn(0,"int32"));const r=s.rank-i.rank;for(let a=0;a<r;++a)i=tr(i,a+1);i=pl(i,_h(s.shape,"bool"));const o=Qt(s);return cr(i,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hQ={kernelName:ob,gradFunc:n=>({x:()=>Qt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dQ=[k4,cZ,uZ,hZ,dZ,fZ,pZ,mZ,gZ,xZ,yZ,vZ,SZ,TZ,IZ,EZ,MZ,kZ,AZ,NZ,RZ,DZ,PZ,LZ,OZ,zZ,BZ,UZ,VZ,WZ,DJ,GZ,HZ,XZ,jZ,qZ,YZ,KZ,ZZ,JZ,QZ,eJ,tJ,nJ,sJ,iJ,rJ,oJ,aJ,uJ,iD,iD,hJ,pJ,xJ,yJ,vJ,wJ,bJ,SJ,_J,CJ,TJ,IJ,EJ,rD,rD,MJ,kJ,RJ,LJ,PJ,$J,FJ,OJ,zJ,BJ,UJ,VJ,WJ,GJ,HJ,XJ,jJ,qJ,KJ,YJ,ZJ,oD,oD,aD,aD,JJ,eQ,QJ,tQ,nQ,sQ,iQ,rQ,oQ,aQ,lQ,cQ,hQ];for(const n of dQ)G7(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.abs=function(){return this.throwIfDisposed(),yi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.acos=function(){return this.throwIfDisposed(),j9(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.acosh=function(){return this.throwIfDisposed(),K9(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.add=function(n){return this.throwIfDisposed(),Ue(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.all=function(n,e){return this.throwIfDisposed(),az(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.any=function(n,e){return this.throwIfDisposed(),sT(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.argMax=function(n){return this.throwIfDisposed(),Nm(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.argMin=function(n){return this.throwIfDisposed(),eX(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.asScalar=function(){return this.throwIfDisposed(),F(this.size===1,()=>"The array must have only 1 element."),ae(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.asType=function(n){return this.throwIfDisposed(),it(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.as1D=function(){return this.throwIfDisposed(),ae(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.as2D=function(n,e){return this.throwIfDisposed(),ae(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),ae(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),ae(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.as5D=function(n,e,t,s,i){return this.throwIfDisposed(),ae(this,[n,e,t,s,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.asin=function(){return this.throwIfDisposed(),nX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.asinh=function(){return this.throwIfDisposed(),iX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.atan=function(){return this.throwIfDisposed(),oX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.atan2=function(n){return this.throwIfDisposed(),lX(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.atanh=function(){return this.throwIfDisposed(),uX(this)};we().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),iM(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),oM(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.batchNorm=function(n,e,t,s,i){return this.throwIfDisposed(),hb(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.broadcastTo=function(n){return this.throwIfDisposed(),am(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.cast=function(n){return this.throwIfDisposed(),it(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.ceil=function(){return this.throwIfDisposed(),FX(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Nr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof ts&&(n=[n]),Ui([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.conv1d=function(n,e,t,s,i,r){return this.throwIfDisposed(),lz(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.conv2dTranspose=function(n,e,t,s,i){return this.throwIfDisposed(),cz(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.conv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),rh(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.cos=function(){return this.throwIfDisposed(),lM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.cosh=function(){return this.throwIfDisposed(),hz(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),rT(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),dz(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),lj(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.depthwiseConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),cM(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.dilation2d=function(n,e,t,s,i){return this.throwIfDisposed(),hj(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.divNoNan=function(n){return this.throwIfDisposed(),gj(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.div=function(n){return this.throwIfDisposed(),bt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.dot=function(n){return this.throwIfDisposed(),yj(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.elu=function(){return this.throwIfDisposed(),fb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.equal=function(n){return this.throwIfDisposed(),Ma(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.erf=function(){return this.throwIfDisposed(),bj(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),Aj(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.exp=function(){return this.throwIfDisposed(),fl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.expandDims=function(n){return this.throwIfDisposed(),tr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.expm1=function(){return this.throwIfDisposed(),Lj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.fft=function(){return this.throwIfDisposed(),$z(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.flatten=function(){return this.throwIfDisposed(),ae(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.floor=function(){return this.throwIfDisposed(),mb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.floorDiv=function(n){return this.throwIfDisposed(),oz(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.gather=function(n,e){return this.throwIfDisposed(),hM(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Sh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.greater=function(n){return this.throwIfDisposed(),Lr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.ifft=function(){return this.throwIfDisposed(),oT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.irfft=function(){return this.throwIfDisposed(),vK(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.isFinite=function(){return this.throwIfDisposed(),Wj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.isInf=function(){return this.throwIfDisposed(),Hj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.isNaN=function(){return this.throwIfDisposed(),jj(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.leakyRelu=function(n){return this.throwIfDisposed(),fM(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.lessEqual=function(n){return this.throwIfDisposed(),Nf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.less=function(n){return this.throwIfDisposed(),gz(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),Jj(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.logSigmoid=function(){return this.throwIfDisposed(),rq(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.logSoftmax=function(n){return this.throwIfDisposed(),yz(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),cq(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.log=function(){return this.throwIfDisposed(),ka(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.log1p=function(){return this.throwIfDisposed(),xz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.logicalAnd=function(n){return this.throwIfDisposed(),pl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.logicalNot=function(){return this.throwIfDisposed(),pM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.logicalOr=function(n){return this.throwIfDisposed(),vz(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.logicalXor=function(n){return this.throwIfDisposed(),pq(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),hn(this,n,e,t)};we().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),mM(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.max=function(n,e){return this.throwIfDisposed(),zo(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.maximum=function(n){return this.throwIfDisposed(),Oc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.mean=function(n,e){return this.throwIfDisposed(),ds(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.min=function(n,e){return this.throwIfDisposed(),m1(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.minimum=function(n){return this.throwIfDisposed(),gM(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),Sq(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.mod=function(n){return this.throwIfDisposed(),Cq(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.mul=function(n){return this.throwIfDisposed(),ne(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.neg=function(){return this.throwIfDisposed(),ps(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.norm=function(n,e,t){return this.throwIfDisposed(),pb(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.notEqual=function(n){return this.throwIfDisposed(),g1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),yM(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.onesLike=function(){return this.throwIfDisposed(),po(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.pad=function(n,e){return this.throwIfDisposed(),vM(this,n,e)};we().prototype.pool=function(n,e,t,s,i,r){return this.throwIfDisposed(),Lq(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.pow=function(n){return this.throwIfDisposed(),cf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.prelu=function(n){return this.throwIfDisposed(),bM(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.prod=function(n,e){return this.throwIfDisposed(),Fq(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.reciprocal=function(){return this.throwIfDisposed(),Qq(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.relu=function(){return this.throwIfDisposed(),Th(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.relu6=function(){return this.throwIfDisposed(),Mz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.reshapeAs=function(n){return this.throwIfDisposed(),ae(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.reshape=function(n){return this.throwIfDisposed(),ae(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),Uz(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),Vz(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.reverse=function(n){return this.throwIfDisposed(),oh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.rfft=function(){return this.throwIfDisposed(),SK(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.round=function(){return this.throwIfDisposed(),kz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.rsqrt=function(){return this.throwIfDisposed(),Az(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.selu=function(){return this.throwIfDisposed(),Nz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.separableConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),Rz(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.sigmoid=function(){return this.throwIfDisposed(),Af(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.sign=function(){return this.throwIfDisposed(),lK(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.sin=function(){return this.throwIfDisposed(),Dz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.sinh=function(){return this.throwIfDisposed(),Lz(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.slice=function(n,e){return this.throwIfDisposed(),_n(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.softmax=function(n){return this.throwIfDisposed(),TM(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.softplus=function(){return this.throwIfDisposed(),u0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),wM(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.split=function(n,e){return this.throwIfDisposed(),Ir(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.sqrt=function(){return this.throwIfDisposed(),Ti(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.square=function(){return this.throwIfDisposed(),An(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.squaredDifference=function(n){return this.throwIfDisposed(),CK(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.squeeze=function(n){return this.throwIfDisposed(),h0(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof ts?[this,n]:[this,...n];return bc(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.step=function(n){return this.throwIfDisposed(),d0(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.stridedSlice=function(n,e,t,s,i,r,o,a){return this.throwIfDisposed(),kK(this,n,e,t,s,i,r,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.sub=function(n){return this.throwIfDisposed(),Ct(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.sum=function(n,e){return this.throwIfDisposed(),yt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.tan=function(){return this.throwIfDisposed(),NK(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.tanh=function(){return this.throwIfDisposed(),rM(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.tile=function(n){return this.throwIfDisposed(),Po(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.toBool=function(){return this.throwIfDisposed(),it(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.toFloat=function(){return this.throwIfDisposed(),it(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.toInt=function(){return this.throwIfDisposed(),it(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.topk=function(n,e){return this.throwIfDisposed(),DK(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.transpose=function(n){return this.throwIfDisposed(),Yt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.unique=function(n){return this.throwIfDisposed(),$K(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Oz(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.unstack=function(n){return this.throwIfDisposed(),ah(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.where=function(n,e){return this.throwIfDisposed(),cr(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */we().prototype.zerosLike=function(){return this.throwIfDisposed(),Qt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class da extends Error{constructor(e){super(e),Object.setPrototypeOf(this,da.prototype)}}class lo extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lo.prototype)}}class ee extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ee.prototype)}}class Et extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Et.prototype)}}class lk extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lk.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class N4{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uh(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function fa(n,e){if(!n)throw new lk(e)}function lD(n,e){let t=0;for(const s of n)s===e&&t++;return t}function $i(n){return n.length===1?n[0]:n}function Mn(n){return Array.isArray(n)?n:[n]}function Ja(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function wu(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Kr={};function ck(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function cT(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>cT(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:cT(s))}}}function x0(n,e={},t={},s="object",i=!1){if(typeof n=="string"){const r=n;let o;if(r in t)o=t[r];else if(r in Kr)o=Kr[r];else if(o=e[r],o==null)throw new ee(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const r=n;if(r.className==null||r.config==null)throw new ee(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);const o=r.className;let a,l;if(o in t?[a,l]=t[o]:o in Kr?[a,l]=Kr.className:o in e&&([a,l]=e[o]),a==null)throw new ee(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const f of Object.keys(Kr))c[f]=Kr[f];for(const f of Object.keys(t))c[f]=t[f];const u=r.config;u.customObjects=c;const h=Object.assign({},Kr);for(const f of Object.keys(t))Kr[f]=t[f];cT(r.config);const d=l(a,r.config,t,i);return Kr=Object.assign({},h),d}else{const c=Object.assign({},Kr);for(const h of Object.keys(t))Kr[h]=t[h];const u=new a(r.config);return Kr=Object.assign({},c),u}}}function fQ(n,e){return n<e?-1:n>e?1:0}function dy(n,e){return-1*fQ(n,e)}function pc(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function pQ(n){if(n==null)throw new ee(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Ih(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new ee(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function uk(n,e,t=0,s=1/0){return fa(t>=0),fa(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(i=>typeof i===e)}function Ls(n,e){Array.isArray(n)?(F(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Ls(t,`element ${s+1} of ${e}`))):F(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${R4(n)}.`)}function R4(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>R4(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function mQ(n,e,t){let s=t!=null?t():Pi(),i;return(...o)=>{const a=t!=null?t():Pi();return a-s<e||(s=a,i=n(...o)),i}}function D4(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let gQ=0;function L4(){return gQ++}const fy={};function bb(n=""){return n in fy||(fy[n]=0),fy[n]+=1,n+fy[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const xQ=["channelsFirst","channelsLast"],yQ=["nearest","bilinear"],vQ=["valid","same","causal"],wQ=["max","avg"],bQ=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Yh=new Map;function rs(n){Ih(xQ,"DataFormat",n)}function SQ(n){Ih(yQ,"InterpolationFormat",n)}function Pr(n){Ih(vQ,"PaddingMode",n)}function P4(n){Ih(wQ,"PoolMode",n)}const cm=[],cD="/";function zu(n,e){cm.push(n);try{const t=e();return cm.pop(),t}catch(t){throw cm.pop(),t}}function _Q(){return cm.length===0?"":cm.join(cD)+cD}function $4(n){if(!O4(n))throw new Error("Not a valid tensor name: '"+n+"'");return _Q()+n}function F4(n){if(!O4(n))throw new Error("Not a valid tensor name: '"+n+"'");Yh.has(n)||Yh.set(n,0);const e=Yh.get(n);if(Yh.set(n,Yh.get(n)+1),e>0){const t=`${n}_${e}`;return Yh.set(t,1),t}else return n}const CQ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function O4(n){return!!n.match(CQ)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function TQ(n){return n===parseInt(n.toString(),10)}function mc(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let i=e;i<t;++i)s*=n[i];return s}function hf(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Sc(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function Go(n,e){if(e<n)throw new ee(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let B_;function Ss(){return B_==null&&(B_=B9().epsilon()),B_}function Ho(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ta(n,e){return it(n,e)}function y0(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ae(n,t)}function IQ(n,e){return de(()=>{if(n.shape.length!==2)throw new ee(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=y0(n,1);return uT(t,[1,e,1])})}function EQ(n){const e=[mc(n.shape)];return ae(n,e)}function MQ(n){if(n.rank<=1)throw new ee(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],mc(n.shape,1)];return ae(n,e)}function Bu(n,e,t){return de(()=>{switch(n.rank){case 1:return _M(n,e,t);case 2:return Pz(n,[e,0],[t,n.shape[1]]);case 3:return CM(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return y1(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return _n(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return _n(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ee(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function U_(n,e,t){return de(()=>{switch(n.rank){case 1:return _M(n,e,t);case 2:return Pz(n,[0,e],[n.shape[0],t]);case 3:return CM(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return y1(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new ee(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function py(n,e,t,s){return de(()=>{switch(n.rank){case 1:return _M(n,e,t);case 2:switch(s){case 1:return Bu(n,e,t);case 2:return U_(n,e,t);default:throw new ee(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Bu(n,e,t);case 2:return CM(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return U_(n,e,t);default:throw new ee(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Bu(n,e,t);case 2:return y1(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return y1(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return U_(n,e,t);default:throw new ee(`The axis is not within the rank of the tensor ${s}`)}default:throw new ee(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function hk(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Ui(n,e)}function uD(n,e){switch(n.rank){case 1:return BX([n,e]);case 2:return VX([n,e],0);case 3:return GX([n,e],0);case 4:return XX([n,e],0);default:throw new ee(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function uT(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new ee(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Po(n,e)}function Sb(n,e=0,t=1,s,i){return Kq(n,e,t,s,i)}function Ia(n,e,t,s){if(n.rank<2||e.rank<2)throw new Et(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=n.shape.slice(-1)[0],r=e.shape.slice(-2)[0];if(i!==r)throw new Et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return X3({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?hT(n.rank,s,Ho()):null,activation:t});{const i=n.shape.slice(),r=i.pop();n=ae(n,[-1,r]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},(m,x)=>x===0?e.rank-2:x<=e.rank-2?x-1:x);e=ae(Yt(e,u),[l,-1]);const h=[...i,...c];return ae(X3({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?hT(n.rank,s,Ho()):null,activation:t}),h)}}function z4(n,e,t){return de(()=>(Array.isArray(e)?e=Oi(e,"int32"):e=it(e,"int32"),hM(n,e,t)))}function v0(n){return ne(n,n)}function hT(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new ee(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?ae(e,[1,s[0],1,1,1]):ae(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?ae(e,[1,1,1,1,s[0]]):ae(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?ae(e,[1,s[0],1,1]):ae(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?ae(e,[1,1,1,s[0]]):ae(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?ae(e,[1,s[0],1]):ae(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?ae(e,[1,1,s[0]]):ae(e,[1].concat(s))}else if(n<3)return e;throw new ee(`Unsupported input rank by biasAdd: ${e.rank}`)}function Ko(n,e,t){return de(()=>(t==null&&(t=Ho()),rs(t),Ue(n,hT(n.rank,e,t))))}function kQ(n,e=1){if(e!==1)throw new Et(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return fb(n)}function AQ(n){return de(()=>bt(n,Ue(yi(n),1)))}function B4(n,e,t,s){return de(()=>GK(n,e,t,s))}function NQ(n){return de(()=>{const e=Ue(.5,ne(.2,n));return Nr(e,0,1)})}function w0(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const RQ=["fanIn","fanOut","fanAvg"],DQ=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LQ(n){Ih(RQ,"FanMode",n)}function PQ(n){Ih(DQ,"Distribution",n)}class xo extends Df{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class U4 extends xo{apply(e,t){return Rs(e,t)}}U4.className="Zeros";$e(U4);class dk extends xo{apply(e,t){return _h(e,t)}}dk.className="Ones";$e(dk);class V4 extends xo{constructor(e){if(super(),typeof e!="object")throw new ee(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ee(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return de(()=>ne(dn(this.value),_h(e,t)))}getConfig(){return{value:this.value}}}V4.className="Constant";$e(V4);class W4 extends xo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return gb(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}W4.className="RandomUniform";$e(W4);class G4 extends xo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Et(`randomNormal does not support dType ${t}.`);return Sb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}G4.className="RandomNormal";$e(G4);class H4 extends xo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Et(`truncatedNormal does not support dType ${t}.`);return Fz(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}H4.className="TruncatedNormal";$e(H4);class X4 extends xo{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return de(()=>{if(e.length!==2||e[0]!==e[1])throw new ee("Identity matrix initializer can only be used for 2D square matrices.");return ne(this.gain,mz(e[0]))})}getConfig(){return{gain:this.gain}}}X4.className="Identity";$e(X4);function $Q(n,e="channelsLast"){let t,s;if(rs(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const i=mc(n,2);t=n[1]*i,s=n[0]*i}else if(e==="channelsLast"){const i=mc(n,0,n.length-2);t=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=mc(n);t=Math.sqrt(i),s=Math.sqrt(i)}return[t,s]}class ur extends xo{constructor(e){if(super(),e.scale<0)throw new ee(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,LQ(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,PQ(this.distribution),this.seed=e.seed}apply(e,t){const s=$Q(e),i=s[0],r=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,i):this.mode==="fanOut"?o/=Math.max(1,r):o/=Math.max(1,(i+r)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Et(`${this.getClassName()} does not support dType ${t}.`);return Fz(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return gb(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}ur.className="VarianceScaling";$e(ur);class fk extends ur{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ur.className}}fk.className="GlorotUniform";$e(fk);class pk extends ur{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ur.className}}pk.className="GlorotNormal";$e(pk);class mk extends ur{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ur.className}}mk.className="HeNormal";$e(mk);class gk extends ur{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ur.className}}gk.className="HeUniform";$e(gk);class xk extends ur{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ur.className}}xk.className="LeCunNormal";$e(xk);class yk extends ur{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ur.className}}yk.className="LeCunUniform";$e(yk);class j4 extends xo{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Et("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return de(()=>{if(e.length<2)throw new Et("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const s=e[0]>e[1]?[e[1],e[0]]:e,i=Sb(s,0,1,"float32");let r=OY.gramSchmidt(i);return e[0]>e[1]&&(r=Yt(r)),ne(this.gain,r)})}getConfig(){return{gain:this.gain,seed:this.seed}}}j4.className="Orthogonal";$e(j4);const hD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function dD(n,e={}){return x0(n,no.getMap().classNameMap,e,"initializer")}function Vn(n){return ck(n)}function $n(n){if(typeof n=="string"){const e=n in hD?hD[n]:n;if(e==="GlorotNormal")return new pk;if(e==="GlorotUniform")return new fk;if(e==="HeNormal")return new mk;if(e==="HeUniform")return new gk;if(e==="LeCunNormal")return new xk;if(e==="LeCunUniform")return new yk;{const t={};return t.className=e,t.config={},dD(t)}}else return n instanceof xo?n:dD(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function dT(n){return Array.isArray(n)&&Array.isArray(n[0])}function v1(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Tt(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new ee(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function an(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new ee(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function w1(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,i)=>s*i);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const fD="Variable";class FQ{constructor(e,t="float32",s=fD,i=!0,r=null){this.dtype=t==null?"float32":t,this.shape=e.shape,this.id=L4(),s=s==null?fD:s,this.originalName=$4(s),this.name=F4(this.originalName),this.trainable_=i,this.constraint=r,this.val=zK(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),OQ(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function OQ(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function fT(n){return n.map(e=>e.read())}function vk(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _s{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ya{constructor(e,t,s,i,r,o,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=i,this.callArgs=r,this.outputTensorIndex=a,this.id=L4(),o!=null&&(this.originalName=$4(o),this.name=F4(this.originalName)),this.rank=t.length}}let zQ=0;class _b{constructor(e,t){this.callArgs=t,this.id=zQ++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let BQ=0;class Ht extends Df{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=BQ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=Ja(s)+"_"+bb(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),s=[r].concat(e.inputShape)}this.batchInputShape=s;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new lo(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ee(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return $i(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return $i(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new da(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new da(`Layer ${this.name} is not connected, no input to return.`);return $i(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new da(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new da(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return $i(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Mn(e),this.inputSpec==null||this.inputSpec.length===0)return;const t=Mn(this.inputSpec);if(e.length!==t.length)throw new ee(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let s=0;s<e.length;s++){const i=e[s],r=t[s];if(r==null)continue;const o=i.rank;if(r.ndim!=null&&o!==r.ndim)throw new ee(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${o}`);if(r.maxNDim!=null&&o>r.maxNDim)throw new ee(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${o}`);if(r.minNDim!=null&&o<r.minNDim)throw new ee(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${o}.`);if(r.dtype!=null&&i.dtype!==r.dtype)throw new ee(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${i.dtype}.`);if(r.axes){const a=i.shape;for(const l in r.axes){const c=Number(l),u=r.axes[l],h=c>=0?a[c]:a[a.length+c];if(u!=null&&[u,null].indexOf(h)===-1)throw new ee(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${a}.`)}}if(r.shape!=null)for(let a=0;a<r.shape.length;++a){const l=r.shape[a],c=i.shape[a];if(l!=null&&c!=null&&l!==c)throw new ee(`Input ${s} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Mn(e);let i=!0;for(const o of s)if(!(o instanceof ya)){i=!1;break}let r=!0;for(const o of s)if(o instanceof ya){r=!1;break}if(i===r)throw new ee("Arguments to apply() must be all SymbolicTensors or all Tensors");return zu(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Mn(e))o.push(a.shape);this.build($i(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let o=this.call(e,t);const a=Mn(o),l=[];for(let c of a)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=$i(l),this.activityRegularizer!=null)throw new Et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=UQ(e),a=this.computeOutputShape(o);let l;const c=VQ(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,h)=>new ya(c,u,this,Mn(e),t,this.name,h)):l=new ya(c,a,this,Mn(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&e[i]!=null&&e[i]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new da(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new da(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new lo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return w1(this.weights)}build(e){this.built=!0}getWeights(e=!1){return fT(e?this.trainableWeights:this.weights)}setWeights(e){de(()=>{const t=this.weights;if(t.length!==e.length)throw new ee(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],i=fT(t);for(let r=0;r<i.length;++r){const o=i[r],a=t[r],l=e[r];if(!pn(o.shape,l.shape))throw new ee(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}vk(s)})}addWeight(e,t,s,i,r,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ee(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():$n("zeros"));const c=i.apply(t,s),u=new FQ(c,s,e,o,a);return c.dispose(),r!=null&&this.addLoss(()=>r.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Mn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,s,i,r,o,a=null){const l=Mn(e);t=Mn(t),s=Mn(s),i=Mn(i),r=v1(r),o=v1(o);const c=[],u=[],h=[];for(const d of l)c.push(d.sourceLayer),u.push(d.nodeIndex),h.push(d.tensorIndex);new _b({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:i,inputShapes:r,outputShapes:o},a);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function UQ(n){n=Mn(n);const e=[];for(const t of n)e.push(t.shape);return $i(e)}function VQ(n){return"float32"}function q4(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let r=0;r<s.inboundLayers.length;r++){const o=s.inputTensors[r],a=s.inboundLayers[r],l=s.nodeIndices[r],c=q4(o,a,l);for(const u of c)i.indexOf(u)===-1&&i.push(u)}return i}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class b0 extends Ht{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:bb("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ee("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ee("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ee("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const i=new ya(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new _b({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ee(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}b0.className="InputLayer";$e(b0);function WQ(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new ee("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new b0({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function GQ(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return it(e,n.dtype)}catch{throw new ee(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class tc{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof tc)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=GQ(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ee(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ya){if(this.id2Value[e.id]==null)throw new ee(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ee(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ya){if(this.id2Value[e.id]==null)throw new ee(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ee(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Gt(this.id2Mask)}}const b1=new N4,S1=new N4;function HQ(n){b1!=null&&b1.setMaxEntries(n),S1!=null&&S1.setMaxEntries(n)}function Xp(n,e,t,s){const i=t==null?!1:t.training,r=Array.isArray(n),o=r?n:[n],a=o.map(m=>m.name),l=[],c=e.names();for(const m of a)c.indexOf(m)!==-1?l.push(e.getValue(m)):l.push(null);s!=null&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const u=a.join(",")+"|"+e.names().sort().join(",");let h=b1.get(u),d;if(h==null){const m=XQ(o,e);h=m.sorted,d=m.recipientCounts,b1.put(u,h),S1.put(u,d)}d={},i||Object.assign(d,S1.get(u));const f=new tc(e);for(let m=0;m<h.length;++m){if(s!=null){const A=nT().numTensors;A>s.maxNumTensors&&(s.maxNumTensors=A),A<s.minNumTensors&&(s.minNumTensors=A)}const x=h[m],y=x.sourceLayer;if(y instanceof b0)continue;const v=[],w=[],b=[];let S=!1;for(const A of x.inputs){const N=f.getValue(A),L=f.getMask(A);v.push(N),w.push(L),L!=null&&(S=!0),i||(d[A.name]--,d[A.name]===0&&!e.hasKey(A)&&a.indexOf(A.name)===-1&&!N.isDisposed&&A.sourceLayer.stateful!==!0&&b.push(N))}S&&(t=t||{},t.mask=w[0]);const C=Mn(y.apply(v,t));let E=null;y.supportsMasking&&(E=y.computeMask(v,w));const k=qQ(x),I=Array.isArray(k)?k:[k];for(let A=0;A<I.length;++A){f.hasKey(I[A])||f.add(I[A],C[A],Array.isArray(E)?E[0]:E);const N=a.indexOf(I[A].name);N!==-1&&(l[N]=C[A])}i||Gt(b)}return f.disposeMasks(),r?l:l[0]}function XQ(n,e){F(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const i=pD(n[0],e);t=i.sorted,s=i.recipientMap}else{const i=new Set;for(const r of n){const{sorted:o,recipientMap:a}=pD(r,e);for(const l of o)i.has(l.name)||(t.push(l),i.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(c=>s[l].add(c))}}return{sorted:t,recipientCounts:jQ(s)}}function jQ(n){const e={};for(const t in n)e[t]=n[t].size;return e}function pD(n,e){const t=new Set,s=[],i={};for(const a of e.names())t.add(a);const r=[],o=[];for(r.push(n);r.length>0;){const a=r[r.length-1];if(t.has(a.name)){r.pop();continue}const l=o[o.length-1]===r.length-1;if(a.inputs.length===0||l)r.pop(),s.push(a),t.add(a.name),l&&o.pop();else{o.push(r.length-1);for(const c of a.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(a.name),!t.has(c.name)&&r.push(c)}}return{sorted:s,recipientMap:i}}function qQ(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KQ=xe();KQ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,HQ);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wk(n,e){return de(()=>Ti(yt(ne(n,n),e,!0)))}class S0 extends Df{getConfig(){return{}}}class K4 extends S0{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return de(()=>{const t=wk(e,this.axis),s=Nr(t,0,this.maxValue);return ne(e,bt(s,Ue(Ss(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}K4.className="MaxNorm";$e(K4);class Y4 extends S0{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return de(()=>bt(e,Ue(Ss(),wk(e,this.axis))))}getConfig(){return{axis:this.axis}}}Y4.className="UnitNorm";$e(Y4);class Z4 extends S0{apply(e){return Th(e)}}Z4.className="NonNeg";$e(Z4);class J4 extends S0{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return de(()=>{const t=wk(e,this.axis),s=Ue(ne(this.rate,Nr(t,this.minValue,this.maxValue)),ne(1-this.rate,t));return ne(e,bt(s,Ue(Ss(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}J4.className="MinMaxNorm";$e(J4);const mD={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Cs(n){return ck(n)}function gD(n,e={}){return x0(n,no.getMap().classNameMap,e,"constraint")}function Ts(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in mD?mD[n]:n,config:{}};return gD(t)}else return n instanceof S0?n:gD(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function nu(n){if(n==null)return;const e=[],t=[],s=[];for(const i in n){const r=n[i];if(typeof r!="number"){const o=r;e.push(o.data()),t.push(i),s.push(o)}}if(e.length>0){const i=await Promise.all(e);for(let r=0;r<i.length;++r)n[t[r]]=i[r][0];Gt(s)}}function Q4(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var xD;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(xD||(xD={}));const YQ=125;class Pm{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class ZQ{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class JQ extends Pm{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const i in t){const r=t[i];if(typeof r=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+r*s;else{let o;i in this.totals?o=this.totals[i]:this.totals[i]=0;const a=de(()=>Ue(this.totals[i],ne(r,s)));this.totals[i]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:de(()=>{const i=ne(bt(1,this.seen),this.totals[s]);t[s]=i,this.totals[s].dispose(),_a(t[s])}))}}class QQ extends Pm{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const r in this.history){const o=this.history[r];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(r),s.push(a)}}const i=await Promise.all(e);for(let r=0;r<i.length;++r)this.history[t[r]][s[r]].dispose(),this.history[t[r]][s[r]]=i[r][0]}}class eee extends Pm{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||i4,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=YQ),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");B2(this.yieldEvery)&&(this.maybeWait=mQ(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const i=[];this.yield!=null&&(await nu(s),i.push(this.yield(e,t,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await nu(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await nu(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await nu(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await nu(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):B2(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await nu(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await nu(e),await this.trainEnd(e))}}function eB(n,e){return n==null&&(n={}),n instanceof Pm?[n]:Array.isArray(n)&&n[0]instanceof Pm?n:Mn(n).map(s=>new eee(s,e))}class Jr{constructor(){}static registerCallbackConstructor(e,t){F(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Jr.checkForDuplicate(t),Jr.constructors[e]==null&&(Jr.constructors[e]=[]),Jr.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Jr.constructors)Jr.constructors[+t].forEach(i=>{if(i===e)throw new ee("Duplicate callback constructor.")})}static clear(){Jr.constructors={}}static createCallbacks(e){const t=[];for(const s in Jr.constructors){const i=+s;e>=i&&t.push(...Jr.constructors[i])}return t.map(s=>new s)}}Jr.constructors={};function tB(n,e,t,s,i,r,o,a,l){const c=new QQ,u=[new JQ,...Jr.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const h=new ZQ(u);return h.setParams({epochs:t,initialEpoch:s,samples:i,steps:r,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function al(n,e={},t=!1){return x0(n,no.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _1(n,e){return de(()=>{n.dtype!=="float32"&&(n=it(n,"float32"));const t=yt(v0(n),e,!0),s=db(t.shape,Ss()),i=Ti(Oc(t,s));return bt(n,i)})}function Cb(n,e){return de(()=>ds(v0(Ct(e,n)),-1))}function bk(n,e){return de(()=>ds(yi(Ct(e,n)),-1))}function Sk(n,e){return de(()=>{const t=Ct(n,e),s=Nr(yi(n),Ss(),Number.MAX_VALUE),i=yi(bt(t,s));return ne(100,ds(i,-1))})}function tee(n,e){return de(()=>{const t=Nr(e,Ss(),Number.MAX_VALUE),s=ka(Ue(1,t)),i=Nr(n,Ss(),Number.MAX_VALUE),r=ka(Ue(1,i));return ds(v0(Ct(s,r)),-1)})}function nee(n,e){return de(()=>{const t=Oc(0,Ct(1,ne(n,e)));return ds(v0(t),-1)})}function see(n,e){return de(()=>{const t=Oc(0,Ct(1,ne(n,e)));return ds(t,-1)})}function iee(n,e){return de(()=>{const t=yt(ne(n,e),-1),s=zo(ne(Ct(1,n),e),-1);return Oc(0,Ue(1,Ct(s,t)))})}function ree(n,e){return de(()=>{const t=Math.log(2),s=Ct(e,n),i=Ct(Ue(s,u0(ne(-2,s))),t);return ds(i,-1)})}function $m(n,e,t=!1){return de(()=>{if(t)e=TM(e);else{const s=yt(e,e.shape.length-1,!0);e=bt(e,s)}return e=Nr(e,Ss(),1-Ss()),ps(yt(ne(it(n,"float32"),ka(e)),e.shape.length-1))})}function C1(n,e,t=!1){return de(()=>{const s=it(mb(EQ(n)),"int32");e=Nr(e,Ss(),1-Ss());const i=e.shape,r=ae(yM(s,i[i.length-1]),i);return $m(r,e,t)})}function oee(n,e){if(!pn(n.shape,e.shape))throw new ee(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return de(()=>{const t=Th(e),s=ps(yi(e));return Ue(Ct(t,ne(e,n)),xz(fl(s)))})}function Tb(n,e){return de(()=>{let t;return t=Nr(e,Ss(),1-Ss()),t=ka(bt(t,Ct(1,t))),ds(oee(n,t),-1)})}function aee(n,e){return de(()=>{const t=Nr(n,Ss(),1),s=Nr(e,Ss(),1);return yt(ne(n,ka(bt(t,s))),-1)})}function lee(n,e){return de(()=>{const t=ka(Ue(Ss(),e));return ds(Ct(e,ne(n,t)),-1)})}function nB(n,e){return de(()=>{const t=_1(n,-1),s=_1(e,-1),i=ne(t,s);return ps(yt(i,-1))})}const T1={meanSquaredError:Cb,meanAbsoluteError:bk,meanAbsolutePercentageError:Sk,meanSquaredLogarithmicError:tee,squaredHinge:nee,hinge:see,categoricalHinge:iee,logcosh:ree,categoricalCrossentropy:$m,sparseCategoricalCrossentropy:C1,binaryCrossentropy:Tb,kullbackLeiblerDivergence:aee,poisson:lee,cosineProximity:nB};function V_(n){if(typeof n=="string"){if(n in T1)return T1[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ee(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sB(n,e){return de(()=>{const t=ne(.5,po(e)),s=Ta(Lr(e,t),n.dtype);return ds(Ma(n,s),-1)})}function iB(n,e){return de(()=>Ta(Ma(Nm(n,-1),Nm(e,-1)),"float32"))}function cee(n,e){return de(()=>it(yt(pl(Ma(n,1),Ma(e,1))),"float32"))}function uee(n,e){return de(()=>it(yt(pl(Ma(n,0),Ma(e,1))),"float32"))}function hee(n,e){return de(()=>{const t=cee(n,e),s=uee(n,e),i=Ue(t,s);return it(cr(Lr(i,0),bt(t,i),0),"float32")})}function dee(n,e){return Tb(n,e)}function fee(n,e){return n.rank===e.rank&&(n=h0(n,[n.rank-1])),e=Nm(e,-1),e.dtype!==n.dtype&&(e=it(e,n.dtype)),it(Ma(n,e),"float32")}const pee=Cb,mee=Cb,gee=bk,xee=bk,yee=Sk,vee=Sk,rB=$m,wee=nB,oB=C1,I1={binaryAccuracy:sB,categoricalAccuracy:iB,precision:hee,categoricalCrossentropy:rB,sparseCategoricalCrossentropy:oB,mse:pee,MSE:mee,mae:gee,MAE:xee,mape:yee,MAPE:vee,cosine:wee};function bee(n){if(typeof n=="string"&&n in I1)return I1[n];if(typeof n!="string"&&n!=null)return n;throw new ee(`Unknown metric ${n}`)}function my(n){if(fa(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(T1))if(T1[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(I1))if(I1[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function See(n){const e={Adagrad:()=>mu.adagrad(.01),Adadelta:()=>mu.adadelta(1,.95,Ss()),Adam:()=>mu.adam(.001,.9,.999,Ss()),Adamax:()=>mu.adamax(.002,.9,.999,Ss(),0),RMSProp:()=>mu.rmsprop(.001,.9,0,Ss()),SGD:()=>mu.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new ee(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const yD=1*1024*1024;function vD(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!pT(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>yD&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${yD}.`)}}function pT(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!pT(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!pT(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _ee(n,e,t,s=console.log){const i=Tee(n),r=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let o;if(!i){r.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}s("_".repeat(e)),E1(r,t,s),s("=".repeat(e));const a=n.layers;for(let u=0;u<a.length;++u)i?Iee(a[u],t,s):Eee(a[u],t,o,s),s((u===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Cee(n),c=w1(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function Cee(n){let e;return n.collectedTrainableWeights!=null?e=w1(n.collectedTrainableWeights):e=w1(n.trainableWeights),e}function Tee(n){let e=!0;const t=[],s=[];for(const i in n.nodesByDepth)t.push(n.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}s.push(...i)}if(e)for(const i of n.layers){let r=!1;for(const o of i.inboundNodes)if(s.indexOf(o)!==-1)if(r){e=!1;break}else r=!0;if(!e)break}return e}function E1(n,e,t=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,e[i]),s+=" ".repeat(e[i]-s.length);t(s)}function Iee(n,e,t){let s,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const r=n.name,o=n.getClassName(),a=[`${r} (${o})`,i,s,n.countParams().toString()];E1(a,e,t)}function Eee(n,e,t,s){let i,r;try{r=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const f=h.inboundLayers[d].name,m=h.nodeIndices[d],x=h.tensorIndices[d];o.push(`${f}[${m}][${x}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,r,i,n.countParams().toString(),c];E1(u,e,s);for(let h=1;h<o.length;++h)E1(["","","","",o[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aB(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function mT(n,e){if(n===null)return null;if(typeof n=="string")return wu(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];aB(e,i,r)?t.push(r):t.push(mT(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")t[s]=i;else{const r=wu(s);t[r]=mT(i,r)}}return t}}function gT(n,e){if(n==null)return null;if(typeof n=="string")return Ja(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];aB(e,i,r)?t.push(r):t.push(gT(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s],r=Ja(s);(s==="name"||s==="className")&&typeof i=="string"?t[r]=i:t[r]=gT(i,s)}return t}}/** @license See the LICENSE file. */const lB="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Mo extends Ht{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=bb(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],pc(this.inputs).length!==this.inputs.length)throw new ee(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);pc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const b=w.sourceLayer,S=w.nodeIndex,C=w.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(S),this.outputLayersTensorIndices.push(C)}for(const w of this.inputs){const b=w.sourceLayer,S=w.nodeIndex,C=w.tensorIndex;fa(S===0,"input layer has >1 nodes"),fa(C===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(S),this.inputLayersTensorIndices.push(C)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const b=this.inputLayers[w];if(!(b instanceof b0))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${w} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const t={},s={},i={},r={},o={},a=[],l=(w,b,S,C,E,k)=>{(C==null||E==null||k==null)&&(C=w.sourceLayer,E=w.nodeIndex,k=w.tensorIndex);const I=C.inboundNodes[E];if(S.indexOf(I)!==-1)throw new lo(`The tensor ${w.name} at layer "${C.name}" is part of a cycle.`);if(b.indexOf(I)!==-1)return;this.containerNodes.add(Mo.nodeKey(C,E)),C.id in o||(o[C.id]=Object.keys(o).length),S.indexOf(I)===-1&&S.push(I);const A=I.inboundLayers.length;for(let N=0;N<A;N++){const L=I.inputTensors[N],V=I.inboundLayers[N],O=I.nodeIndices[N],P=I.tensorIndices[N];l(L,b,S,V,O,P)}for(b.push(I);S.indexOf(I)>=0;)S.splice(S.indexOf(I),1);a.push(I)},c=[],u=[];for(const w of this.outputs)l(w,c,u);const h=a.slice().reverse();for(const w of h){s[w.id]=w,w.id in t||(t[w.id]=0);let b=t[w.id];const S=i[w.outboundLayer.id]==null?0:i[w.outboundLayer.id];b=Math.max(b,S),i[w.outboundLayer.id]=b,r[w.outboundLayer.id]=w.outboundLayer,t[w.id]=b;for(let C=0;C<w.inboundLayers.length;C++){const E=w.inboundLayers[C],k=w.nodeIndices[C],I=E.inboundNodes[k],A=t[I.id]==null?0:t[I.id];t[I.id]=Math.max(b+1,A),s[I.id]=I}}const d={};for(const w in t){const b=t[w];b in d||(d[b]=[]),d[b].push(s[w])}const f={};for(const w in i){const b=i[w];b in f||(f[b]=[]),f[b].push(r[w])}let m=Object.keys(f).map(w=>parseInt(w,10)).sort(dy);this.layers=[];for(const w of m){const b=f[w];b.sort((S,C)=>{const E=o[S.id],k=o[C.id];return E<k?-1:E>k?1:0});for(const S of b)S instanceof Mo&&this.internalContainerRefs.push(S),this.layers.push(S)}this.layersByDepth=f,m=Object.keys(d).map(w=>parseInt(w,10)).sort(dy);const x=this.inputs.slice(),y=[];for(const w of m)for(const b of d[w]){const S=b.outboundLayer;if(S!=null){for(const C of b.inputTensors)if(x.indexOf(C)===-1)throw new lo(`Graph disconnected: cannot obtain value for tensor ${C} at layer "${S.name}". The following previous layers were accessed without issue: ${y}`);for(const C of b.outputTensors)x.push(C);y.push(S.name)}}this.nodesByDepth=d;const v=this.layers.map(w=>w.name);for(const w of v){const b=v.filter(S=>S===w).length;if(b!==1)throw new lo(`The name "${w}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new _b({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ee("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let i=0;for(const o of this.layers)for(const a of o.weights){if(s[a.originalName]!=null)throw new ee(`Duplicate weight name: ${a.originalName}`);s[a.originalName]=a,i++}const r=[];for(const o in e){let a=o;if(s[o]==null){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[a]!=null)r.push([s[a],e[o]]);else if(t)throw new ee(`Provided weight data has no target variable: ${o}`);delete s[a]}if(t){const o=[];for(const a in s)o.push(a);if(o.length>0)throw new ee(`${o.length} of ${i} weights are not set: ${o}`)}vk(r)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${lB}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=gT(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return de(()=>{e=Mn(e);const s=new tc;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],e[i]);return Xp(this.outputs,s,t)})}computeMask(e,t){return de(()=>{e=Mn(e);let s;return t==null?s=uh(null,e.length):s=Mn(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=v1(e);if(t.length!==this.inputLayers.length)throw new ee(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],u=l.name+"_0_0";s[u]=c}const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(dy);if(i.length>1)for(const a of i){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(u.id)!==-1)continue;const h=[];for(let x=0;x<c.inboundLayers.length;x++){const y=c.inboundLayers[x],v=c.nodeIndices[x],w=c.tensorIndices[x],b=`${y.name}_${v}_${w}`,S=s[b];h.push(S)}const d=u.computeOutputShape($i(h)),f=v1(d),m=u.inboundNodes.indexOf(c);for(let x=0;x<f.length;x++){const y=`${u.name}_${m}_${x}`;s[y]=f[x]}}}const r=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],h=`${l.name}_${c}_${u}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];fa(l in s),r.push(s[l])}return $i(r)}runInternalGraph(e,t){t==null&&(t=uh(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],h=t[l];s[c.id]=[u,h]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(dy);for(const l of i){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,d=u.inputTensors,f=u.outputTensors,m=new Array;for(const x of d)x.id in s&&m.push(s[x.id]);if(m.length===d.length){let x={},y,v,w,b;if(u.callArgs!=null&&(x=u.callArgs),m.length===1){const[S,C]=m[0];x.mask==null&&(x.mask=C),w=Mn(h.call(S,x)),b=Mn(h.computeMask(S,C)),y=[S],v=[C]}else y=m.map(S=>S[0]),v=m.map(S=>S[1]),x.mask==null&&(x.mask=v),w=Mn(h.call(y,x)),b=Mn(h.computeMask(y,v));if(h.activityRegularizer)throw new Et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let S=0;S<f.length;++S){const C=f[S],E=w[S],k=b[S];s[C.id]=[E,k]}}}}const r=[],o=[],a=[];for(const l of this.outputs){fa(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=s[l.id];a.push(c.shape),r.push(c),o.push(u)}return[r,o,a]}buildNodeConversionMap(e){const t={};let s;for(const i of this.layers){s=i instanceof Mo?1:0;for(let r=0;r<i.inboundNodes.length;r++){const o=Mo.nodeKey(i,r);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new ee(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new ee("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===e)return s;throw new ee(`No such layer: ${e}`)}calculateLosses(){return de(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const i=Mo.nodeKey(t,s);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const d=o.inboundNodes[h],f=Mo.nodeKey(o,h);let m={};if(this.containerNodes.has(f)){if(d.callArgs)try{JSON.stringify(d.callArgs),m=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(d.inboundLayers.length>0){const x=[];for(let y=0;y<d.inboundLayers.length;y++){const v=d.inboundLayers[y],w=d.nodeIndices[y],b=d.tensorIndices[y],S=Mo.nodeKey(v,w);let C=t[S];C==null&&(C=0),x.push([v.name,C,b,m])}c.push(x)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,s.push(u)}e.layers=s;const i=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=Mo.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[o];i.push([a.name,u,h])}e.inputLayers=i;const r=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=Mo.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[o];r.push([a.name,u,h])}return e.outputLayers=r,e}static fromConfig(e,t,s={},i=!1){const r={},o={};function a(y,v){y.name in o?o[y.name].push(v):o[y.name]=[v]}function l(y,v){const w=[];let b;for(const S of v){const C=S[0],E=S[1],k=S[2];if(b=S[3]==null?{}:S[3],!(C in r)){a(y,v);return}const I=r[C];if(I.inboundNodes.length<=E){a(y,v);return}const A=I.inboundNodes[E];w.push(A.outputTensors[k])}w.length>0&&y.apply($i(w),b)}function c(y){const v=y.name,w=al(y,t.customObjects!=null?t.customObjects:{});w.setFastWeightInitDuringBuild(i),r[v]=w,y.inboundNodes.forEach(S=>{if(!(S instanceof Array))throw new ee(`Corrupted configuration, expected array for nodeData: ${S}`);a(w,S)})}const u=t.name,h=t.layers;for(const y of h)c(y);for(;!pQ(o);)for(const y of h){const v=r[y.name];if(v.name in o){const w=o[v.name];delete o[v.name];for(const b of w)l(v,b)}}const d=[],f=[],m=t.inputLayers;for(const y of m){const v=y[0],w=y[1],b=y[2];fa(v in r);const C=r[v].inboundNodes[w].outputTensors;d.push(C[b])}const x=t.outputLayers;for(const y of x){const v=y[0],w=y[1],b=y[2];fa(v in r);const C=r[v].inboundNodes[w].outputTensors;f.push(C[b])}return new e({inputs:d,outputs:f,name:u})}get stateful(){if(this._stateful)throw new ee("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){de(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Mee(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return e.forEach(r=>{r in n?i.push(n[r]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function cB(n,e){return Mee(n,e,"classWeight")}async function uB(n,e,t,s){if(e!=null||s!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const i=de(()=>{if(n.shape.length===1)return Ou(n);if(n.shape.length===2){if(n.shape[1]>1)return Nm(n,1);if(n.shape[1]===1)return ae(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await i.data());Gt(i);const o=[];return r.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),Oi(o,"float32")}else return null}function kee(n,e){return ne(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Aee=32;function hB(n,e){let t,s;const i=e;t=i.xs,s=i.ys,F(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const r=wD("input",n.inputNames,t),o=wD("output",n.outputNames,s),a=r[0].shape[0];F(r.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),F(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<r.length;l++)F(r[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${r[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)F(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:r,ys:o}}function wD(n,e,t){if(t instanceof ts)return[t];if(Array.isArray(t))return F(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const i of e){if(t[i]==null)throw new ee(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(t[i])}return s}}function Nee(n){if(n.length===3)throw new Et("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Ree(n,e,t){const s=t.batchesPerEpoch!=null;if(F(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),F(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),F(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),F(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),F(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=t.validationData!=null;let r,o;if(i)if(bD(t.validationData))F(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const y=Nee(t.validationData);r=y.xs,o=y.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;i?c=l.slice().concat(l.map(y=>"val_"+y)):c=l.slice();const u=eB(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:f}=tB(u,h,t.epochs,null,null,Dee(e,t),null,i,c);d.setModel(n),n.history=f,await d.onTrainBegin(),n.stopTraining_=!1;let m=t.initialEpoch==null?0:t.initialEpoch,x=await e.iterator();for(;m<t.epochs;){const y={};await d.onEpochBegin(m);let v=0,w=0;for(s||(x=await e.iterator());!s||v<t.batchesPerEpoch;){const b=await x.next();if(s&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){const{xs:S,ys:C}=hB(n,b.value),E={};E.batch=w,E.size=S[0].shape[0],await d.onBatchBegin(w,E);const k=[];if(t.classWeight!=null){const N=cB(t.classWeight,n.outputNames);for(let L=0;L<N.length;++L)k.push(await uB(C[L],null,N[L]))}const I=S.concat(C).concat(k),A=a(I);Gt(I);for(let N=0;N<l.length;++N){const L=l[N],V=A[N];E[L]=V,_a(V)}await d.onBatchEnd(w,E),Q4(E),w++,v++}if(s?v>=t.batchesPerEpoch:b.done){if(i){let S;bD(t.validationData)?S=Mn(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):S=Mn(n.evaluate(r,o,{batchSize:t.validationBatchSize==null?Aee:t.validationBatchSize,verbose:0}));for(let C=0;C<n.metricsNames.length;++C)y[`val_${n.metricsNames[C]}`]=S[C]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(m,y),m++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Dee(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function bD(n){return typeof n.iterator=="function"}function Lee(n){return typeof n.next=="function"}async function Pee(n,e,t){t=t||{};const s=t.batches!=null,i=n.testFunction;let r=[];if(t.verbose>0)throw new Et("Verbose mode is not implemented yet.");F(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=Lee(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<t.batches;){const c=await o.next();if(r=de(()=>{if(c.value){const{xs:u,ys:h}=hB(n,c.value),d=u.concat(h),f=de(()=>i(d));if(Gt(d),l===0)for(let x=0;x<f.length;++x)r.push(dn(0));const m=d[0].shape[0];for(let x=0;x<f.length;++x){const y=f[x],v=r[x];r[x]=de(()=>Ue(r[x],ne(m,y))),l>0&&Gt(v)}Gt(f),a+=m,++l}return r}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<r.length;++c){const u=r[c];r[c]=bt(r[c],a),Gt(u)}return $i(r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function W_(n){F(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Ip(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Bu(s,e,t-e)):Bu(n,e,t-e)}function xT(n,e){return de(()=>n==null?null:Array.isArray(n)?n.map(t=>xT(t,e)):z4(n,e.dtype==="int32"?e:it(e,"int32")))}function G_(n,e){const t=[];let s=0,i=null;for(;s<n;)i=s+e,i>=n&&(i=n),t.push([s,i]),s=i;return t}function dB(n){const e=[];n instanceof ts&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(y0(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Co(n,e){if(n==null)return;const t=[];if(e instanceof ts)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const r=e[i];t.push(r.id)}const s=[];if(n instanceof ts)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{t.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const r=n[i];t.indexOf(r.id)===-1&&s.push(r)}s.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $ee(n){return n instanceof ts}function yT(n){return Array.isArray(n)}function SD(n){return!$ee(n)&&!yT(n)}function _D(n,e,t,s=!0,i=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(yT(n)&&n.length>0)o=!0;else if(SD(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new ee(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let r;if(SD(n)){n=n,r=[];for(const o of e){if(n[o]==null)throw new ee(`No data provided for "${o}". Need data for each key in: ${e}`);r.push(n[o])}}else if(yT(n)){if(n=n,n.length!==e.length)throw new ee(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);r=n}else{if(n=n,e.length>1)throw new ee(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);r=[n]}if(r=dB(r),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=r[o];if(a.shape.length!==t[o].length)throw new ee(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u>=0&&c!==u)throw new ee(`${i} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return r}function Fee(n,e,t){const s=pc(n.map(r=>r.shape[0]));s.sort();const i=pc(e.map(r=>r.shape[0]));if(i.sort(),s.length>1)throw new ee(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(r=>r.shape))}`);if(i.length>1)throw new ee(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(r=>r.shape))}`);if(s.length>0&&i.length>0&&!pn(s,i))throw new ee(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function Oee(n,e,t){const s=[Cb,Tb,$m];for(let i=0;i<n.length;++i){const r=n[i],o=e[i],a=t[i];if(o!=null){if(o===$m&&r.shape[r.shape.length-1]===1)throw new ee(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=r.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const h=l[u],d=c[u];if(d!=null&&h!==d)throw new ee(`A target Tensor with shape ${r.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function CD(n,e,t,s=!0,i=""){let r;if(Array.isArray(n)){if(n.length!==e.length)throw new ee(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);r=n}else{if(e.length>1)throw new ee(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);r=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=r[o];if(a.shape.length!==t[o].length)throw new ee(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u!==c)throw new ee(`Error when checking ${i}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function zee(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const i of e){let r=t.hasOwnProperty(i)?t[i]:[];Array.isArray(r)||(r=[r]),s.push(r)}return s}}const Bee="layers-model";class jd extends Mo{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new ee("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");_ee(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=See(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof zc))throw new ee("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new ee(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(V_(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ee(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>V_(a))}else{const o=V_(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],zu("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const i=zee(e.metrics,this.outputNames),r=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};zu("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=i[o];(c=>{const u="";let h,d,f;for(const m of c){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){const y=this.internalOutputShapes[o];y[y.length-1]===1||this.lossFunctions[o]===Tb?["accuracy","acc"].indexOf(m)!==-1?d=sB:["crossentropy","ce"].indexOf(m)!==-1&&(d=dee):this.lossFunctions[o]===C1?["accuracy","acc"].indexOf(m)!==-1?d=fee:["crossentropy","ce"].indexOf(m)!==-1&&(d=oB):["accuracy","acc"].indexOf(m)!==-1?d=iB:["crossentropy","ce"].indexOf(m)!==-1&&(d=rB);let v;["accuracy","acc"].indexOf(m)!==-1?v="acc":["crossentropy","ce"].indexOf(m)!==-1&&(v="ce"),f=d,h=u+v}else f=bee(m),h=u+my(m);let x;zu(h,()=>{x=f}),r(o,h,x)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const i=s.batchSize==null?32:s.batchSize;W_(i);const r=!0,o=this.standardizeUserDataXY(e,t,r,i);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,i,s.verbose,s.steps);return $i(c)}finally{Co(o[0],e),Co(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Pee(this,e,t)}checkNumSamples(e,t,s,i="steps"){let r;if(s!=null){if(r=null,t!=null)throw new ee(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new ee(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ee("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),i=s?t:[t],r=this.retrieveSymbolicTensors(i),o=new tc;if(e instanceof ts&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ee(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new ee(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=Xp(r,o);return s?a:a[0]}retrieveSymbolicTensors(e){const t=uh(null,e.length);let s=e.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],o=r.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=r[l],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw t.forEach((r,o)=>{r==null&&i.push(e[o])}),new ee(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,s=!1){return de(()=>{const i=this.checkNumSamples(e);if(s)throw new Et("Verbose predictLoop() is not implemented yet.");const r=G_(i,t),o=this.outputs.map(a=>[]);for(let a=0;a<r.length;++a)de(()=>{const c=r[a][0],u=r[a][1],h=Ip(e,c,u),d=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)d.push({key:this.inputs[m],value:h[m]});else d.push({key:this.inputs[0],value:h});const f=new tc(d);return Xp(this.outputs,f)}).forEach((c,u)=>o[u].push(c));return $i(o.map(a=>Ui(a,0)))})}predict(e,t={}){const s=dB(e);CD(s,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return W_(i),this.predictLoop(s,i)}finally{Co(s,e)}}predictOnBatch(e){CD(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,i){if(this.optimizer_==null)throw new lo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===C1?r.push(a.slice(0,a.length-1).concat([1])):r.push(a)}if(e=_D(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=_D(t,this.feedOutputNames,r,!1,"target"),Fee(e,t),Oee(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new ee(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,i,r=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,r,o);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(i!=null){const u=cB(i,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await uB(l[h],null,u[h]))}return[a,l,c]}testLoop(e,t,s,i=0,r){return de(()=>{const o=this.checkNumSamples(t,s,r,"steps"),a=[];if(i>0)throw new Et("Verbose mode is not implemented yet.");if(r!=null)throw new Et("steps mode in testLoop() is not implemented yet");{const l=G_(o,s),c=Oi(Go(0,o));for(let u=0;u<l.length;++u){const h=l[u][0],d=l[u][1],f=Bu(c,h,d-h),m=xT(t,f),x=e(m);if(u===0)for(let y=0;y<x.length;++y)a.push(dn(0));for(let y=0;y<x.length;++y){const v=x[y];a[y]=Ue(a[y],ne(d-h,v))}}for(let u=0;u<a.length;++u)a[u]=bt(a[u],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const i=e[s];let r=i;if(lD(e,i)>1){const o=lD(e.slice(0,s),i);r+=`_${o}`}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let x=0;x<this.inputs.length;++x)h.push({key:this.inputs[x],value:s[x]});const d=new tc(h),f=Xp(this.outputs,d,{training:!0});let m;for(let x=0;x<this.lossFunctions.length;++x){const y=this.lossFunctions[x];let v=y(i[x],f[x]);r[x]!=null&&(v=kee(v,r[x]));const w=ds(v);t.push(w),x===0?m=v:m=Ue(m,v)}for(let x=0;x<this.metricsTensors.length;++x){let y;if(this.outputs.length>1&&x<this.outputs.length)y=t[x];else{const v=this.metricsTensors[x][0],w=this.metricsTensors[x][1];y=ds(v(i[w],f[w]))}_a(y),o.push(y)}return m=ds(m),this.calculateLosses().forEach(x=>{m=Ue(m,x)}),m},l=this.collectedTrainableWeights.map(h=>h.read()),c=!0;return[this.optimizer_.minimize(a,c,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>de(()=>{const t=[];let s;const i=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:i[c]});const a=new tc(o),l=Xp(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=ds(u(r[c],l[c]));c===0?s=h:s=Ue(s,h),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],d=ds(u(r[h],l[h]));t.push(d)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,r,o,a,l,c,u,h,d;try{const f=s.batchSize==null?32:s.batchSize;W_(f);const m=!1,x=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,m,f);i=x[0],r=x[1],d=x[2];let y=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(y=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new Et("validationData including sample weights is not supported yet."):new ee(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const A=!0,N=await this.standardizeUserData(l,c,null,null,A,f);u=N[0],h=N[1],v=u.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){y=!0;const A=Math.floor(i[0].shape[0]*(1-s.validationSplit)),N=i[0].shape[0];u=Ip(i,A,N),o=i,i=Ip(i,0,A),h=Ip(r,A,N),a=r,r=Ip(r,0,A),v=u.concat(h)}else s.validationSteps!=null&&(y=!0);const w=i.concat(r).concat(d);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),S=this.getDedupedMetricsNames();let C,E;y?(this.makeTestFunction(),C=this.testFunction,E=S.slice().concat(S.map(A=>"val_"+A))):(C=null,v=[],E=S.slice());const k=eB(s.callbacks,s.yieldEvery);return await this.fitLoop(b,w,S,f,s.epochs,s.verbose,k,C,v,s.shuffle,E,s.initialEpoch,null,null)}finally{this.isTraining=!1,Co(i,e),Co(r,t),Co(o,e),Co(a,t),Co(u,l),Co(h,c),d!=null&&Gt(d)}}async fitLoop(e,t,s,i,r,o,a,l,c,u,h,d,f,m){i==null&&(i=32),r==null&&(r=1),u==null&&(u=!0),d==null&&(d=0);let x=!1;if(l!=null&&c!=null&&(x=!0),m!=null&&(x=!0,f==null))throw new ee("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const y=this.checkNumSamples(t,i,f,"steps_per_epoch");let v;y!=null&&(v=Go(0,y)),o==null&&(o=1);const{callbackList:w,history:b}=tB(a,o,r,d,y,f,i,x,h);w.setModel(this),this.history=b,await w.onTrainBegin(),this.stopTraining_=!1;for(let S=d;S<r;++S){await w.onEpochBegin(S);const C={};if(f!=null)throw new Et("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Et("batch shuffling is not implemneted yet");u&&I7(v);const E=Oi(v),k=G_(y,i);for(let I=0;I<k.length;++I){const A={};if(await w.onBatchBegin(I,A),de(()=>{const N=k[I][0],L=k[I][1],V=Bu(E,N,L-N);A.batch=I,A.size=L-N;const O=xT(t,V),P=e(O);for(let W=0;W<s.length;++W){const H=s[W],Y=P[W];A[H]=Y,_a(Y)}if(I===k.length-1&&x){const W=this.testLoop(l,c,i);for(let H=0;H<s.length;++H){const Y=s[H],D=W[H];_a(D),C["val_"+Y]=D}}}),await w.onBatchEnd(I,A),Q4(A),this.stopTraining_)break}E.dispose()}if(await w.onEpochEnd(S,C),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Ree(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),i=s[0],r=s[1],a=this.makeTrainFunction()(i.concat(r)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return Gt(a),Co(s[0],e),Co(s[1],t),$i(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,i=s?this.trainableWeights:this.weights,r=this.getWeights(s);for(let o=0;o<i.length;++o)s&&!i[o].trainable||t.push({name:i[o].originalName,tensor:r[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=nT().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-nT().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Ja(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Ja(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const i of t)if(typeof s[i]=="string")e[i]=Ja(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ja(my(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ja(my(e)));{const e={};for(const t in this.metrics)e[t]=Ja(my(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=mT(e.optimizer_config),s=al(t);let i;if(typeof e.loss=="string")i=wu(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(o=>wu(o));else if(e.loss!=null){i={};for(const o in e.loss)i[o]=wu(e.loss[o])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(o=>wu(o));else if(e.metrics!=null){r={};for(const o in e.metrics)r[o]=wu(e.metrics[o])}this.compile({loss:i,metrics:r,optimizer:s})}async save(e,t){if(typeof e=="string"){const c=b9(e);if(c.length===0)throw new ee(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new ee(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new ee("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await V3(this.getNamedWeights(t)),i=!1,r=null,a={modelTopology:this.toJSON(r,i),format:Bee,generatedBy:`TensorFlow.js tfjs-layers v${lB}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:h}=await V3(await this.optimizer.getWeights(),c);s.specs.push(...h),s.data=ZO([s.data,u])}return this.userDefinedMetadata!=null&&(vD(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){vD(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}jd.className="Model";$e(jd);class fB extends jd{}fB.className="Functional";$e(fB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class df extends jd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:bb("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ee(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof df||e instanceof jd;let s;if(t){if(s=e,s.outputs.length!==1)throw new ee("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ee("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ee("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=WQ({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ee(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ee("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=q4(this.outputs[0])}this.inboundNodes=[],new _b({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:uh(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(an(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new jd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new lo("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new lo("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new lo("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new lo("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},i=!1){let r,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new ee("Legacy serialization format not supported yet.");r=t}else F(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof df))throw new Et(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of r){const u=al(l,void 0,i);i&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new ee("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ee("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}df.className="Sequential";$e(df);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Uee(n){return new df(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Xi extends Df{getConfig(){return{}}}class pB extends Xi{apply(e,t=1){return kQ(e,t)}}pB.className="elu";$e(pB);class mB extends Xi{apply(e){return Nz(e)}}mB.className="selu";$e(mB);class gB extends Xi{apply(e){return Th(e)}}gB.className="relu";$e(gB);class xB extends Xi{apply(e){return de(()=>gM(6,Th(e)))}}xB.className="relu6";$e(xB);class yB extends Xi{apply(e){return e}}yB.className="linear";$e(yB);class vB extends Xi{apply(e){return Af(e)}}vB.className="sigmoid";$e(vB);class wB extends Xi{apply(e){return NQ(e)}}wB.className="hardSigmoid";$e(wB);class bB extends Xi{apply(e){return u0(e)}}bB.className="softplus";$e(bB);class SB extends Xi{apply(e){return AQ(e)}}SB.className="softsign";$e(SB);class _B extends Xi{apply(e){return rM(e)}}_B.className="tanh";$e(_B);class _k extends Xi{apply(e,t=-1){return TM(e,t)}}_k.className="softmax";$e(_k);class CB extends Xi{apply(e,t=-1){return yz(e,t)}}CB.className="logSoftmax";$e(CB);class TB extends Xi{apply(e,t=1){return de(()=>ne(Af(ne(e,t)),e))}}TB.className="swish";$e(TB);class IB extends Xi{apply(e){return de(()=>ne(e,rM(u0(e))))}}IB.className="mish";$e(IB);function _c(n){return n.getClassName()}function H_(n,e={}){return x0(n,no.getMap().classNameMap,e,"activation")}function Cc(n){if(n==null){const e={};return e.className="linear",e.config={},H_(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},H_(e)}else return n instanceof Xi?n:H_(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vee(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class EB extends Df{}class MB extends EB{constructor(e){super(),Vee(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return de(()=>{let t=Rs([1]);return this.hasL1&&(t=Ue(t,yt(ne(this.l1,yi(e))))),this.hasL2&&(t=Ue(t,yt(ne(this.l2,v0(e))))),ae(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}MB.className="L1L2";$e(MB);const TD={l1l2:"L1L2"};function yn(n){return ck(n)}function ID(n,e={}){return x0(n,no.getMap().classNameMap,e,"regularizer")}function Fn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in TD?TD[n]:n,config:{}};return ID(t)}else return n instanceof EB?n:ID(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class kB extends Ht{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Tt(e);let s=Th(e);return this.maxValue!=null&&(s=Nr(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}kB.className="ReLU";$e(kB);class AB extends Ht{constructor(e){super(e==null?{}:e),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Tt(e);return fM(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}AB.className="LeakyReLU";$e(AB);class NB extends Ht{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=$n(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Fn(e.alphaRegularizer),this.alphaConstraint=Ts(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ee(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=an(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new _s({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Tt(e),bM(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Vn(this.alphaInitializer),alphaRegularizer:yn(this.alphaRegularizer),alphaConstraint:Cs(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}NB.className="PReLU";$e(NB);class RB extends Ht{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Et(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Tt(e);return fb(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}RB.className="ELU";$e(RB);class DB extends Ht{constructor(e){super(e==null?{}:e),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Tt(e);return ne(s,it(Lr(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}DB.className="ThresholdedReLU";$e(DB);class LB extends Ht{constructor(e){super(e==null?{}:e),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new _k().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){const s=Tt(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}LB.className="Softmax";$e(LB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qd(n,e,t){if(typeof n=="number")return uh(n,e);if(n.length!==e)throw new ee(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const i=n[s];if(!TQ(i))throw new ee(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function Bo(n,e,t,s,i=1){if(n==null)return n;const r=e+(e-1)*(i-1);let o;return t==="same"?o=n:o=n-r+1,Math.floor((o+s-1)/s)}function pa(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Sc([t-e,0]);else if(s==="same")n=n*e;else throw new ee(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ck(n,e){return de(()=>(rs(e),e==="channelsFirst"?Yt(n,[0,2,3,1]):n))}function PB(n,e){return de(()=>(rs(e),e==="channelsFirst"?Yt(n,[0,2,3,4,1]):n))}function Wee(n,e,t,s=1,i="valid",r,o=1){return de(()=>{if(r==null&&(r=Ho()),rs(r),n.shape.length!==3)throw new ee(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new ee(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new ee(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(r==="channelsFirst"&&(n=Yt(n,[0,2,1])),i==="causal")throw new Et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=lz(n,e,s,i==="same"?"same":"valid","NWC",o);return t!=null&&(a=Ko(a,t)),a})}function ED(n,e,t,s=[1,1],i="valid",r,o,a=null){return de(()=>{if(r==null&&(r=Ho()),rs(r),n.rank!==3&&n.rank!==4)throw new ee(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ee(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=Ck(n,r);if(i==="causal")throw new Et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=jK({x:l,filter:e,strides:s,pad:i==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),r==="channelsFirst"&&(l=Yt(l,[0,3,1,2])),l})}function Gee(n,e,t,s=[1,1,1],i="valid",r,o){return de(()=>{if(r==null&&(r=Ho()),rs(r),n.rank!==4&&n.rank!==5)throw new ee(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ee(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=PB(n,r);if(i==="causal")throw new Et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=JX(a,e,s,i==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Ko(a,t)),r==="channelsFirst"&&(a=Yt(a,[0,4,1,2,3])),a})}class Ib extends Ht{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Ib.verifyArgs(t),this.rank=e,Ls(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qd(t.kernelSize,e,"kernelSize"),this.strides=qd(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Pr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,rs(this.dataFormat),this.activation=Cc(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=$n(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ts(t.biasConstraint),this.biasRegularizer=Fn(t.biasRegularizer),this.activityRegularizer=Fn(t.activityRegularizer),this.dilationRate=qd(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ee(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ee(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ee(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(fa("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!uk(e.kernelSize,"number",1,3))throw new ee(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:_c(this.activation),useBias:this.useBias,biasInitializer:Vn(this.biasInitializer),biasRegularizer:yn(this.biasRegularizer),activityRegularizer:yn(this.activityRegularizer),biasConstraint:Cs(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Lf extends Ib{constructor(e,t){super(e,t),this.kernel=null,Lf.verifyArgs(t),this.filters=t.filters,Ls(this.filters,"filters"),this.kernelInitializer=$n(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ts(t.kernelConstraint),this.kernelRegularizer=Fn(t.kernelRegularizer)}build(e){e=an(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ee(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return de(()=>{e=Tt(e);let s;const i=this.bias==null?null:this.bias.read(),r=D4(this.activation.getClassName());if(r!=null&&this.rank===2)s=ED(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)s=Wee(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=ED(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=Gee(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Et("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=an(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<s.length;++r){const o=Bo(s[r],this.kernelSize[r],this.padding,this.strides[r],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[r]);t.push(o)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:Vn(this.kernelInitializer),kernelRegularizer:yn(this.kernelRegularizer),kernelConstraint:Cs(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ee(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class _0 extends Lf{constructor(e){super(2,e),_0.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!uk(e.kernelSize,"number",1,2))throw new ee(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}_0.className="Conv2D";$e(_0);class C0 extends Lf{constructor(e){super(3,e),C0.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ee(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}C0.className="Conv3D";$e(C0);class $B extends _0{constructor(e){if(super(e),this.inputSpec=[new _s({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ee(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=an(e),e.length!==4)throw new ee("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ee("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new _s({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return de(()=>{let s=Tt(e);if(s.shape.length!==4)throw new ee(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=i[o],c=i[a],u=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],f=this.strides[1],m=pa(l,d,u,this.padding),x=pa(c,f,h,this.padding),y=[r,m,x,this.filters];this.dataFormat!=="channelsLast"&&(s=Yt(s,[0,2,3,1]));let v=cz(s,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Yt(v,[0,3,1,2])),this.bias!=null&&(v=Ko(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=an(e);const t=e.slice();let s,i,r;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3):(s=3,i=1,r=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[i]=pa(t[i],l,o,this.padding),t[r]=pa(t[r],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}$B.className="Conv2DTranspose";$e($B);class FB extends C0{constructor(e){if(super(e),this.inputSpec=[new _s({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ee(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=an(e),e.length!==5)throw new ee("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ee("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new _s({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return de(()=>{let s=Tt(e);if(s.shape.length!==5)throw new ee(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=i[l],u=i[o],h=i[a],d=this.kernelSize[0],f=this.kernelSize[1],m=this.kernelSize[2],x=this.strides[0],y=this.strides[1],v=this.strides[2],w=pa(c,x,d,this.padding),b=pa(u,y,f,this.padding),S=pa(h,v,m,this.padding),C=[r,w,b,S,this.filters];this.dataFormat!=="channelsLast"&&(s=Yt(s,[0,2,3,4,1]));let E=tj(s,this.kernel.read(),C,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=Yt(E,[0,4,1,2,3])),this.bias!==null&&(E=Ko(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(e){e=an(e);const t=e.slice();let s,i,r,o;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3,o=4):(s=4,i=1,r=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],d=this.strides[2];return t[s]=this.filters,t[i]=pa(t[i],u,a,this.padding),t[r]=pa(t[r],h,l,this.padding),t[o]=pa(t[o],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}FB.className="Conv3DTranspose";$e(FB);class OB extends Lf{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ee("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ee("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ee(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=$n(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Fn(t.depthwiseRegularizer),this.depthwiseConstraint=Ts(t.depthwiseConstraint),this.pointwiseInitializer=$n(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Fn(t.pointwiseRegularizer),this.pointwiseConstraint=Ts(t.pointwiseConstraint)}build(e){if(e=an(e),e.length<this.rank+2)throw new ee(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ee(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],i=this.kernelSize.concat([s,this.depthMultiplier]),r=[];for(let a=0;a<this.rank;++a)r.push(1);r.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new _s({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return de(()=>{e=Tt(e);let s;if(this.rank===1)throw new Et("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Yt(e,[0,2,3,1])),s=Rz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Ko(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Yt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Vn(this.depthwiseInitializer),e.pointwiseInitializer=Vn(this.pointwiseInitializer),e.depthwiseRegularizer=yn(this.depthwiseRegularizer),e.pointwiseRegularizer=yn(this.pointwiseRegularizer),e.depthwiseConstraint=Cs(this.depthwiseConstraint),e.pointwiseConstraint=Cs(this.pointwiseConstraint),e}}OB.className="SeparableConv";class zB extends OB{constructor(e){super(2,e)}}zB.className="SeparableConv2D";$e(zB);class Eb extends Lf{constructor(e){super(1,e),Eb.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!uk(e.kernelSize,"number",1,1))throw new ee(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Eb.className="Conv1D";$e(Eb);class BB extends Ht{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return de(()=>{if(e=Tt(e),this.dataFormat==="channelsLast"){const s=py(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return py(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=py(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return py(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}BB.className="Cropping2D";$e(BB);class UB extends Ht{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,rs(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,SQ(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return de(()=>{let s=Tt(e);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=Yt(s,[0,2,3,1]);const r=this.size[0]*i[2],o=this.size[1]*i[3],a=this.interpolation==="nearest"?ku.resizeNearestNeighbor(s,[r,o]):ku.resizeBilinear(s,[r,o]);return Yt(a,[0,3,1,2])}else{const r=this.size[0]*i[1],o=this.size[1]*i[2];return this.interpolation==="nearest"?ku.resizeNearestNeighbor(s,[r,o]):ku.resizeBilinear(s,[r,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}UB.className="UpSampling2D";$e(UB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hee(n,e,t=[1,1],s="valid",i,r){return de(()=>{i==null&&(i=Ho()),rs(i);let o=Ck(n,i);if(n.rank!==4)throw new ee(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new ee(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=cM(o,e,t,s==="same"?"same":"valid","NHWC",r),i==="channelsFirst"&&(o=Yt(o,[0,3,1,2])),o})}class VB extends Ib{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=$n(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ts(e.depthwiseConstraint),this.depthwiseRegularizer=Fn(e.depthwiseRegularizer)}build(e){if(e=an(e),e.length<4)throw new ee(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ee(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return de(()=>{e=Tt(e);let s=Hee(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Ko(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=an(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Bo(t,this.kernelSize[0],this.padding,this.strides[0]),o=Bo(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,r,o]:[e[0],r,o,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Vn(this.depthwiseInitializer),e.depthwiseRegularizer=yn(this.depthwiseRegularizer),e.depthwiseConstraint=Cs(this.depthwiseRegularizer),e}}VB.className="DepthwiseConv2D";$e(VB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function WB(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new ee("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function i(r){return r==null||Array.isArray(r)?r:[r]}return e=i(e),t=i(t),{inputs:n,initialState:e,constants:t}}function GB(n,e,t,s=!1,i,r,o=!1,a=!1){return de(()=>{const l=e.shape.length;if(l<3)throw new ee(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Go(2,l));if(e=Yt(e,c),r!=null)throw new Et("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=it(it(i,"bool"),"float32"),i.rank===l-1&&(i=tr(i,-1)),i=Yt(i,c)),s&&(e=oh(e,0),i!=null&&(i=oh(i,0)));const u=[];let h,d=t;const f=e.shape[0],m=ah(e);let x;i!=null&&(x=ah(i));for(let v=0;v<f;++v){const w=m[v],b=de(()=>n(w,d));if(i==null)h=b[0],d=b[1];else{const S=de(()=>{const C=x[v],E=Ct(po(C),C),k=Ue(ne(b[0],C),ne(d[0],E)),I=d.map((A,N)=>Ue(ne(b[1][N],C),ne(A,E)));return{output:k,newStates:I}});h=S.output,d=S.newStates}a&&u.push(h)}let y;return a&&(y=bc(u,1)),[h,y,d]})}class Bc extends Ht{constructor(e){super(e);let t;if(e.cell==null)throw new ee("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Ek({cells:e.cell}):t=e.cell,t.stateSize==null)throw new ee("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new _s({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Go(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){dT(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let i;if(this.returnSequences?i=[e[0],e[1],s]:i=[e[0],s],this.returnState){const r=[];for(const o of t)r.push([e[0],o]);return[i].concat(r)}else return i}computeMask(e,t){return de(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(r=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Et("Constants support is not implemented in RNN yet.");dT(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new _s({shape:[t,null,...s]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let r;if(Array.isArray(this.cell.stateSize)?r=this.cell.stateSize:r=[this.cell.stateSize],this.stateSpec!=null){if(!pn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),r))throw new ee(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(o=>new _s({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){de(()=>{if(!this.stateful)throw new da("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ee("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Rs([s,i])):this.states_=[Rs([s,this.cell.stateSize])];else if(e==null)Gt(this.states_),this.keptStates!=null&&(Gt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Rs([s,i])):this.states_[0]=Rs([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ee(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Gt(this.states_);for(let i=0;i<this.states_.length;++i){const r=e[i],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,a=[s,o];if(!pn(r.shape,a))throw new ee(`State ${i} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[i]=r}}this.states_=this.states_.map(i=>_a(i.clone()))})}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=WB(e,s,i,this.numConstants);e=r.inputs,s=r.initialState,i=r.constants;let o=[],a=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new _s({shape:c.shape}));a=a.concat(this.stateSpec)}if(i!=null&&(t.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof ya){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const d=super.apply(c,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return de(()=>{const s=t==null?null:t.mask,i=t==null?null:t.training;let r=t==null?null:t.initialState;e=Tt(e),r==null&&(this.stateful?r=this.states_:r=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==o)throw new ee(`RNN Layer has ${o} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:i},c=GB((m,x)=>{const y=this.cell.call([m].concat(x),a);return[y[0],y.slice(1)]},e,r,this.goBackwards,s,null,this.unroll,this.returnSequences),u=c[0],h=c[1],d=c[2];this.stateful&&this.resetStates(d,i);const f=this.returnSequences?h:u;return this.returnState?[f].concat(d):f})}getInitialState(e){return de(()=>{let t=Rs(e.shape);return t=yt(t,[1,2]),t=y0(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?uT(t,[1,s]):t):this.cell.stateSize>1?[uT(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Bc.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const i=t.cell,r=al(i,s);return new e(Object.assign(t,{cell:r}))}}Bc.className="RNN";$e(Bc);class Mb extends Ht{}class Tk extends Mb{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ls(this.units,"units"),this.activation=Cc(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Fn(e.kernelRegularizer),this.recurrentRegularizer=Fn(e.recurrentRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.kernelConstraint=Ts(e.kernelConstraint),this.recurrentConstraint=Ts(e.recurrentConstraint),this.biasConstraint=Ts(e.biasConstraint),this.dropout=hf([1,Sc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=hf([1,Sc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=an(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return de(()=>{if(e=e,e.length!==2)throw new ee(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>po(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>po(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let r;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?r=Ia(ne(e,o),this.kernel.read()):r=Ia(e,this.kernel.read()),this.bias!=null&&(r=Ko(r,this.bias.read())),a!=null&&(s=ne(s,a));let l=Ue(r,Ia(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:_c(this.activation),useBias:this.useBias,kernelInitializer:Vn(this.kernelInitializer),recurrentInitializer:Vn(this.recurrentInitializer),biasInitializer:Vn(this.biasInitializer),kernelRegularizer:yn(this.kernelRegularizer),recurrentRegularizer:yn(this.recurrentRegularizer),biasRegularizer:yn(this.biasRegularizer),activityRegularizer:yn(this.activityRegularizer),kernelConstraint:Cs(this.kernelConstraint),recurrentConstraint:Cs(this.recurrentConstraint),biasConstraint:Cs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Tk.className="SimpleRNNCell";$e(Tk);class HB extends Bc{constructor(e){e.cell=new Tk(e),super(e)}call(e,t){return de(()=>{this.cell.dropoutMask!=null&&(Gt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return new e(t)}}HB.className="SimpleRNN";$e(HB);class Ik extends Mb{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ee("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ls(this.units,"units"),this.activation=Cc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Cc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Fn(e.kernelRegularizer),this.recurrentRegularizer=Fn(e.recurrentRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.kernelConstraint=Ts(e.kernelConstraint),this.recurrentConstraint=Ts(e.recurrentConstraint),this.biasConstraint=Ts(e.biasConstraint),this.dropout=hf([1,Sc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=hf([1,Sc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=an(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return de(()=>{if(e=e,e.length!==2)throw new ee(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>po(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>po(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=ne(e,r[0]));let u=Ia(e,this.kernel.read());this.useBias&&(u=Ko(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=ne(i,o[0]));const h=this.recurrentKernel.read(),[d,f]=Ir(h,[2*this.units,this.units],h.rank-1),m=Ia(i,d),[x,y,v]=Ir(u,3,u.rank-1),[w,b]=Ir(m,2,m.rank-1);a=this.recurrentActivation.apply(Ue(x,w)),l=this.recurrentActivation.apply(Ue(y,b));const S=Ia(ne(l,i),f);c=this.activation.apply(Ue(v,S));const C=Ue(ne(a,i),ne(Ue(1,ps(a)),c));return[C,C]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:_c(this.activation),recurrentActivation:_c(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Vn(this.kernelInitializer),recurrentInitializer:Vn(this.recurrentInitializer),biasInitializer:Vn(this.biasInitializer),kernelRegularizer:yn(this.kernelRegularizer),recurrentRegularizer:yn(this.recurrentRegularizer),biasRegularizer:yn(this.biasRegularizer),activityRegularizer:yn(this.activityRegularizer),kernelConstraint:Cs(this.kernelConstraint),recurrentConstraint:Cs(this.recurrentConstraint),biasConstraint:Cs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Ik.className="GRUCell";$e(Ik);class XB extends Bc{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Ik(e),super(e)}call(e,t){return de(()=>{this.cell.dropoutMask!=null&&(Gt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}XB.className="GRU";$e(XB);class kb extends Mb{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ls(this.units,"units"),this.activation=Cc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Cc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=$n(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Fn(e.kernelRegularizer),this.recurrentRegularizer=Fn(e.recurrentRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.kernelConstraint=Ts(e.kernelConstraint),this.recurrentConstraint=Ts(e.recurrentConstraint),this.biasConstraint=Ts(e.biasConstraint),this.dropout=hf([1,Sc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=hf([1,Sc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=an(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const r=this.biasInitializer,o=this.units;i=new(t=class extends xo{apply(l,c){const u=r.apply([o]),h=new dk().apply([o]),d=r.apply([o*2]);return uD(uD(u,h),d)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return de(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ee(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>po(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>po(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(e=ne(e,o[0]));let d=Ia(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=ne(i,a[0])),d=Ue(d,Ia(i,this.recurrentKernel.read())),this.useBias&&(d=Ko(d,this.bias.read()));const[f,m,x,y]=Ir(d,4,d.rank-1);l=this.recurrentActivation.apply(f),c=this.recurrentActivation.apply(m),u=Ue(ne(c,r),ne(l,this.activation.apply(x))),h=this.recurrentActivation.apply(y);const v=ne(h,this.activation.apply(u));return[v,v,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:_c(this.activation),recurrentActivation:_c(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Vn(this.kernelInitializer),recurrentInitializer:Vn(this.recurrentInitializer),biasInitializer:Vn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:yn(this.kernelRegularizer),recurrentRegularizer:yn(this.recurrentRegularizer),biasRegularizer:yn(this.biasRegularizer),activityRegularizer:yn(this.activityRegularizer),kernelConstraint:Cs(this.kernelConstraint),recurrentConstraint:Cs(this.recurrentConstraint),biasConstraint:Cs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}kb.className="LSTMCell";$e(kb);class jB extends Bc{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new kb(e),super(e)}call(e,t){return de(()=>{this.cell.dropoutMask!=null&&(Gt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}jB.className="LSTM";$e(jB);class Ek extends Mb{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return de(()=>{e=e;let s=e.slice(1);const i=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?i.push(s.splice(0,a.stateSize.length)):i.push(s.splice(0,1));i.reverse();const r=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=i[a],a===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,t),r.push(o.slice(1))}s=[];for(const a of r.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(e){dT(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,i)=>{zu(`RNNCell_${i}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,s={}){const i=[];for(const r of t.cells)i.push(al(r,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return fT(e)}setWeights(e){const t=[];for(const s of this.cells){const i=s.weights.length,r=e.splice(i);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],r[o]])}vk(t)}}Ek.className="StackedRNNCells";$e(Ek);function Tc(n){const{ones:e,rate:t,training:s=!1,count:i=1,dropoutFunc:r}=n,o=()=>r!=null?r(e(),t):B4(e(),t),a=()=>w0(o,e,s);return!i||i<=1?_a(a().clone()):Array(i).fill(void 0).map(a).map(c=>_a(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Xee=globalThis&&globalThis.__rest||function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(t[s[i]]=n[s[i]]);return t};class qB extends Bc{constructor(e){if(e.unroll)throw new Et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Et("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new _s({ndim:5})]}call(e,t){return de(()=>{if(this.cell.dropoutMask!=null&&(Gt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Gt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ee("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return de(()=>{const{stateSize:t}=this.cell,s=e.shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)],o=Rs(r);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){de(()=>{if(!this.stateful)throw new da("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)];if(s[0]==null)throw new ee("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Rs(r)):this.states_=[Rs(r)];else if(e==null)Gt(this.states_),this.keptStates!=null&&(Gt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Rs(r)):this.states_[0]=Rs(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ee(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Gt(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=r;if(!pn(l.shape,c))throw new ee(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>_a(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:i,padding:r,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],h=Bo(c,i[0],r,o[0],a[0]),d=Bo(u,i[1],r,o[1],a[1]);return[...e.slice(0,2),...l?[s,h,d]:[h,d,s]]}}qB.className="ConvRNN2D";class Mk extends kb{constructor(e){const{filters:t,kernelSize:s,strides:i,padding:r,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ls(this.filters,"filters"),this.kernelSize=qd(s,2,"kernelSize"),this.kernelSize.forEach(l=>Ls(l,"kernelSize")),this.strides=qd(i||1,2,"strides"),this.strides.forEach(l=>Ls(l,"strides")),this.padding=r||"valid",Pr(this.padding),this.dataFormat=o||"channelsLast",rs(this.dataFormat),this.dilationRate=qd(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ls(l,"dilationRate"))}build(e){var t;e=an(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ee(`The channel dimension of the input should be defined. Found ${e[s]}`);const i=e[s],r=4,o=this.kernelSize.concat([i,this.filters*r]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends xo{apply(d,f){const m=c.apply([u]),x=_h([u]),y=c.apply([u*2]);return hk([m,x,y])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return de(()=>{if(e.length!==3)throw new ee(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,i=e[0],r=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Tc({ones:()=>po(i),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(U,B,X)=>!B||!B[X]?U:ne(B[X],U);let u=c(i,l,0),h=c(i,l,1),d=c(i,l,2),f=c(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Tc({ones:()=>po(r),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let x=c(r,m,0),y=c(r,m,1),v=c(r,m,2),w=c(r,m,3);const b=3,[S,C,E,k]=Ir(this.kernel.read(),a,b),[I,A,N,L]=this.useBias?Ir(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,S,I,this.padding),h=this.inputConv(h,C,A,this.padding),d=this.inputConv(d,E,N,this.padding),f=this.inputConv(f,k,L,this.padding);const[V,O,P,W]=Ir(this.recurrentKernel.read(),a,b);x=this.recurrentConv(x,V),y=this.recurrentConv(y,O),v=this.recurrentConv(v,P),w=this.recurrentConv(w,W);const H=this.recurrentActivation.apply(Ue(u,x)),Y=this.recurrentActivation.apply(Ue(h,y)),D=Ue(ne(Y,o),ne(H,this.activation.apply(Ue(d,v)))),$=ne(this.recurrentActivation.apply(Ue(f,w)),this.activation.apply(D));return[$,$,D]})}getConfig(){const e=super.getConfig(),t=Xee(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),s)}inputConv(e,t,s,i){const r=rh(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Ko(r,s,this.dataFormat):r}recurrentConv(e,t){return rh(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Mk.className="ConvLSTM2DCell";$e(Mk);class KB extends qB{constructor(e){const t=new Mk(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}KB.className="ConvLSTM2D";$e(KB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class kk extends Ht{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return s}call(e,t){return de(()=>{this.invokeCallHook(e,t);const s=Tt(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,r=this.getNoiseShape(s);return w0(()=>B4(s,this.rate,r,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}kk.className="Dropout";$e(kk);class YB extends kk{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}YB.className="SpatialDropout1D";$e(YB);class Ak extends Ht{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ls(this.units,"units"),this.activation=Cc(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=$n(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=$n(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ts(e.kernelConstraint),this.biasConstraint=Ts(e.biasConstraint),this.kernelRegularizer=Fn(e.kernelRegularizer),this.biasRegularizer=Fn(e.biasRegularizer),this.activityRegularizer=Fn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=an(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=an(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return de(()=>{this.invokeCallHook(e,t);const s=Tt(e),i=D4(this.activation.getClassName());let r;return i!=null?r=Ia(s,this.kernel.read(),i,this.bias?this.bias.read():null):(r=Ia(s,this.kernel.read()),this.bias!=null&&(r=Ko(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:_c(this.activation),useBias:this.useBias,kernelInitializer:Vn(this.kernelInitializer),biasInitializer:Vn(this.biasInitializer),kernelRegularizer:yn(this.kernelRegularizer),biasRegularizer:yn(this.biasRegularizer),activityRegularizer:yn(this.activityRegularizer),kernelConstraint:Cs(this.kernelConstraint),biasConstraint:Cs(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Ak.className="Dense";$e(Ak);class ZB extends Ht{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=an(e);for(const t of e.slice(1))if(t==null)throw new ee(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],mc(e,1)]}call(e,t){return de(()=>{this.invokeCallHook(e,t);let s=Tt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let r=2;r<s.rank;++r)i.push(r);i.push(1),s=Yt(s,i)}return MQ(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}ZB.className="Flatten";$e(ZB);class JB extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.activation=Cc(e.activation)}call(e,t){return de(()=>{this.invokeCallHook(e,t);const s=Tt(e);return this.activation.apply(s)})}getConfig(){const e={activation:_c(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}JB.className="Activation";$e(JB);class QB extends Ht{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return de(()=>(e=Tt(e),IQ(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}QB.className="RepeatVector";$e(QB);class eU extends Ht{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",i=t.slice();let r=1,o=null;for(let l=0;l<i.length;++l){const c=i[l];if(this.isUnknown(c))if(o===null)o=l;else throw new ee("Can only specifiy one unknown dimension.");else r*=c}const a=mc(e);if(o!==null){if(r===0||a%r!==0)throw new ee(s);i[o]=a/r}else if(a!==r)throw new ee(s);return i}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return de(()=>{this.invokeCallHook(e,t);const s=Tt(e),i=s.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return ae(s,r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}eU.className="Reshape";$e(eU);class tU extends Ht{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Go(1,e.dims.length+1);if(!pn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new _s({ndim:this.dims.length+1})]}computeOutputShape(e){e=an(e);const t=e.slice();return this.dims.forEach((s,i)=>{t[i+1]=e[s]}),t}call(e,t){return Yt(Tt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}tU.className="Permute";$e(tU);class nU extends Ht{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Tt(e),i=-1;return sT(g1(s,this.maskValue),i)}call(e,t){return de(()=>{this.invokeCallHook(e,t);const s=Tt(e),i=-1,r=!0,o=sT(g1(s,this.maskValue),i,r);return ne(s,it(o,s.dtype))})}}nU.className="Masking";$e(nU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sU extends Ht{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Mn(e.inputLength))}this.inputDim=e.inputDim,Ls(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ls(this.outputDim,"outputDim"),this.embeddingsInitializer=$n(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Fn(e.embeddingsRegularizer),this.activityRegularizer=Fn(e.activityRegularizer),this.embeddingsConstraint=Ts(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return de(()=>this.maskZero?(e=Tt(e),g1(e,Qt(e))):null)}computeOutputShape(e){if(e=an(e),this.inputLength==null)return[...e,this.outputDim];const t=Mn(this.inputLength);if(t.length!==e.length-1)throw new ee(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<t.length;++i){const r=t[i],o=e[i+1];if(r!=null&&o!=null&&r!==o)throw new ee(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return de(()=>{this.invokeCallHook(e,t);let s=Tt(e);s.dtype!=="int32"&&(s=Ta(s,"int32"));const i=z4(this.embeddings.read(),ae(s,[s.size]));return ae(i,an(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Vn(this.embeddingsInitializer),embeddingsRegularizer:yn(this.embeddingsRegularizer),activityRegularizer:yn(this.activityRegularizer),embeddingsConstraint:Cs(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}sU.className="Embedding";$e(sU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Eh extends Ht{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Et}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const r=e[e.length-t.length+i],o=t[i];if(r==null||o==null||r<0||o<0)s.push(null);else if(r===1)s.push(o);else if(o===1)s.push(r);else{if(r!==o)throw new ee("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(r)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[an(e)]),e=e,e.length<2)throw new ee(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=pc(t),t.length>1)throw new ee(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const i=e.map(r=>r.length);e.indexOf(null)===-1&&pc(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return de(()=>{if(e=e,this.reshapeRequired){const s=[],i=e.map(r=>r.rank);if(i.indexOf(null)===-1){const r=Sc(i);for(let o of e){const a=o.rank;for(let l=0;l<r-a;++l)o=y0(o,1);s.push(o)}return this.mergeFunction(s)}else{let r=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,h=u[0],d=u.slice(1).concat([h]);let f=ae(l,[h].concat(mc(u.slice(1))));f=Yt(f,[1,0]),f=ae(f,d),s.push(f),r=!0}else if(c>1){const u=Go(1,c).concat([0]);s.push(Yt(l,u)),r=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(r){if(a==null){const l=o.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));o=ae(Yt(ae(o,[-1,u]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Go(0,a-1));o=Yt(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const r=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let s=[];for(const i of e)i!=null&&i[0]!==null&&s.push(i[0]);return s=pc(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return de(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ee("`mask` should be an Array");if(!Array.isArray(e))throw new ee("`inputs` should be an Array");if(t.length!==e.length)throw new ee(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:tr(i,0));let s=t[0];for(let i=1;i<t.length-1;++i)s=pl(s,t[i]);return s})}}class iU extends Eh{constructor(e){super(e)}mergeFunction(e){return de(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ue(t,e[s]);return t})}}iU.className="Add";$e(iU);class rU extends Eh{constructor(e){super(e)}mergeFunction(e){return de(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=ne(t,e[s]);return t})}}rU.className="Multiply";$e(rU);class oU extends Eh{constructor(e){super(e)}mergeFunction(e){return de(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ue(t,e[s]);return ne(1/e.length,t)})}}oU.className="Average";$e(oU);class aU extends Eh{constructor(e){super(e)}mergeFunction(e){return de(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Oc(t,e[s]);return t})}}aU.className="Maximum";$e(aU);class lU extends Eh{constructor(e){super(e)}mergeFunction(e){return de(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=gM(t,e[s]);return t})}}lU.className="Minimum";$e(lU);class cU extends Eh{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ee("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const s=[];for(let i=0;i<e.length;++i){const r=e[i].slice();r.splice(this.axis,1);let o=!1;for(const a of s)if(pn(a,r)){o=!0;break}o||s.push(r)}if(s.length>1)throw new ee("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return de(()=>hk(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ee("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const r of t.slice(1)){if(s[i]==null||r[i]==null){s[i]=null;break}s[i]+=r[i]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ee("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ee("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ee(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return de(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const i=[];for(let o=0;o<e.length;++o)t[o]==null?i.push(it(po(e[o]),"bool")):t[o].rank<e[o].rank?i.push(tr(t[o],-1)):i.push(t[o]);const r=Ui(i,this.axis);return az(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}cU.className="Concatenate";$e(cU);function Ep(n,e){for(;n<0;)n+=e;return n}function jee(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Et("batchDot is not implemented for tensors of 4D or higher rank yet");if(F(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),F(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Et("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=e.shape.length;t==null&&(t=[s-1,i-2]);const r=t;return de(()=>{let o;if(s>i){o=s-i;const l=[];for(let c=0;c<o;++c)l.push(1);e=ae(e,e.shape.concat(l))}else if(i>s){o=i-s;const l=[];for(let c=0;c<o;++c)l.push(1);n=ae(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)r[0]===r[1]?a=yt(ne(n,e),r[0]):a=yt(ne(Yt(n,[1,0]),e),r[1]);else{const l=r[0]!==n.shape.length-1,c=r[1]===e.shape.length-1;a=hn(n,e,l,c)}if(o>0){let l;s>i?l=s+i-3:l=s-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=h0(a,c)}return a.shape.length===1&&(a=tr(a,1)),a})}class uU extends Eh{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){F(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new Et("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);if(t[i[0]]!==s[i[1]])throw new ee(`Dimension incompatibility: ${t[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ee(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((r,o)=>Ep(r,e[o].shape.length)):i=[Ep(this.axes,t.shape.length),Ep(this.axes,s.shape.length)],this.normalize&&(t=_1(t,i[0]),s=_1(s,i[1])),jee(t,s,i)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Ep(this.axes,e.length),Ep(this.axes,t.length)],s}computeOutputShape(e){F(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new Et("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);t.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const r=t.concat(s);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}uU.className="Dot";$e(uU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hU extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return de(()=>{this.invokeCallHook(e,t);const s=Tt(e);return w0(()=>Ue(Sb(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}hU.className="GaussianNoise";$e(hU);class dU extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return de(()=>{this.invokeCallHook(e,t);const s=Tt(e);return this.rate>0&&this.rate<1?w0(()=>{const r=Math.sqrt(this.rate/(1-this.rate));return ne(s,Sb(s.shape,1,r))},()=>s,t.training||!1):s})}}dU.className="GaussianDropout";$e(dU);class fU extends Ht{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Tt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return de(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return w0(()=>{const r=Tt(e),o=1.6732632423543772,a=1.0507009873554805,l=-o*a;let c=Sh(gb(s),this.rate);c=Ta(c,"float32");const u=((1-this.rate)*(1+this.rate*l**2))**-.5,h=-u*l*this.rate,d=Ue(ne(r,c),ne(Ue(c,-1),l));return Ue(ne(d,u),h)},()=>Tt(e),t.training||!1)}return e})}}fU.className="AlphaDropout";$e(fU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fm(n,e,t,s,i,r=.001){let o;if(n.rank===2)o=MX(n,e,t,s,i,r);else if(n.rank===3)o=AX(n,e,t,s,i,r);else if(n.rank===4)o=RX(n,e,t,s,i,r);else throw new Et(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function qee(n,e,t,s,i=.001){return de(()=>{const r=xM(n,s),o=r.mean,a=r.variance;return[Fm(n,o,a,t,e,i),o,a]})}function Kee(n,e,t,s,i=.001){return de(()=>{const r=xM(n,s),o=r.mean,a=r.variance,l=[];for(const m of Go(0,n.rank))s.indexOf(m)!==-1?l.push(1):l.push(n.shape[m]);const c=ae(o,l),u=ae(a,l),h=e==null?null:ae(e,l),d=t==null?null:ae(t,l);return[Fm(n,c,u,d,h,i),o,a]})}function Yee(n,e,t,s,i=.001){return pn(s.slice().sort(),Go(0,n.rank-1))?qee(n,e,t,s,i):Kee(n,e,t,s,i)}class pU extends Ht{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=$n(e.betaInitializer||"zeros"),this.gammaInitializer=$n(e.gammaInitializer||"ones"),this.movingMeanInitializer=$n(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=$n(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ts(e.betaConstraint),this.gammaConstraint=Ts(e.gammaConstraint),this.betaRegularizer=Fn(e.betaRegularizer),this.gammaRegularizer=Fn(e.gammaRegularizer)}build(e){e=an(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new ee(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new _s({ndim:e.length,axes:{[t]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return de(()=>{const s=t.training==null?!1:t.training,i=Tt(e),r=i.shape,o=r.length,a=Go(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=uh(1,o);c[l]=r[l];const u=a.slice();u.sort();const h=!pn(u,Go(0,o).slice(0,o-1)),d=()=>{if(h){const w=ae(this.movingMean.read(),c),b=ae(this.movingVariance.read(),c),S=this.center?ae(this.beta.read(),c):null,C=this.scale?ae(this.gamma.read(),c):null;return Fm(i,w,b,S,C,this.epsilon)}else return Fm(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[f,m,x]=Yee(i,this.gamma.read(),this.beta.read(),a,this.epsilon),y=(w,b,S)=>{de(()=>{const C=1-S,E=w.read(),k=ne(Ct(E,b),C);w.write(Ct(E,k))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,x,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Vn(this.betaInitializer),gammaInitializer:Vn(this.gammaInitializer),movingMeanInitializer:Vn(this.movingMeanInitializer),movingVarianceInitializer:Vn(this.movingVarianceInitializer),betaRegularizer:yn(this.betaRegularizer),gammaRegularizer:yn(this.gammaRegularizer),betaConstraint:Cs(this.betaConstraint),gammaConstraint:Cs(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}pU.className="BatchNormalization";$e(pU);class mU extends Ht{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=$n(e.betaInitializer||"zeros"),this.gammaInitializer=$n(e.gammaInitializer||"ones"),this.betaRegularizer=Fn(e.betaRegularizer),this.gammaRegularizer=Fn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=an(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==pc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(r=>e[r]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const s=Tt(e),i=s.shape,r=i.length;return de(()=>{let{mean:a,variance:l}=xM(s,this.axis,!0);const c=uh(1,r);for(const x of this.axis)c[x]=i[x];const u=x=>x!=null&&x.shape.length!==r?ae(x,c):x;let h=this.scale?u(this.gamma.read()):null,d=this.center?u(this.beta.read()):null;const f=[],m=[];for(let x=0;x<r;++x)this.axis.indexOf(x)!==-1?(f.push(i[x]),m.push(1)):(f.push(1),m.push(i[x]));return a=Po(a,f),l=Po(l,f),h!=null&&(h=Po(h,m)),d!=null&&(d=Po(d,m)),Fm(s,a,l,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Vn(this.betaInitializer),gammaInitializer:Vn(this.gammaInitializer),betaRegularizer:yn(this.betaRegularizer),gammaRegularizer:yn(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}mU.className="LayerNormalization";$e(mU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Zee(n,e,t){return de(()=>{if(n.rank!==4)throw new ee(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ee("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Ho()),t!=="channelsLast"&&t!=="channelsFirst")throw new ee(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],vM(n,s)})}class gU extends Ht{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ho():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ee(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ee(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ee(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new _s({ndim:4})]}computeOutputShape(e){e=an(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return de(()=>Zee(Tt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}gU.className="ZeroPadding2D";$e(gU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ab(n,e,t,s,i,r){return de(()=>{rs(i),P4(r),Pr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),i==null&&(i=Ho()),r==null&&(r="max"),n=Ck(n,i);let o;const a=s==="same"?"same":"valid";return r==="max"?o=mM(n,e,t,a):o=iM(n,e,t,a),i==="channelsFirst"&&(o=Yt(o,[0,3,1,2])),o})}function xU(n,e,t,s,i,r){return de(()=>{rs(i),P4(r),Pr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),i==null&&(i=Ho()),r==null&&(r="max"),n=PB(n,i);let o;const a=s==="same"?"same":"valid";return r==="max"?o=xq(n,e,t,a):o=yX(n,e,t,a),i==="channelsFirst"&&(o=Yt(o,[0,4,1,2,3])),o})}class yU extends Ht{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ee(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ls(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ee(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ls(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Pr(this.padding),this.inputSpec=[new _s({ndim:3})]}computeOutputShape(e){e=an(e);const t=Bo(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return de(()=>{this.invokeCallHook(e,t),e=y0(Tt(e),2);const s=this.poolingFunction(Tt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return h0(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class vU extends yU{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return rs(r),Pr(i),Ab(e,t,s,i,r,"max")}}vU.className="MaxPooling1D";$e(vU);class wU extends yU{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return rs(r),Pr(i),Ab(e,t,s,i,r,"avg")}}wU.className="AveragePooling1D";$e(wU);class bU extends Ht{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ee(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ls(this.poolSize,"poolSize"),Ls(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,rs(this.dataFormat),Pr(this.padding),this.inputSpec=[new _s({ndim:4})]}computeOutputShape(e){e=an(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Bo(t,this.poolSize[0],this.padding,this.strides[0]),s=Bo(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return de(()=>(this.invokeCallHook(e,t),this.poolingFunction(Tt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class SU extends bU{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return rs(r),Pr(i),Ab(e,t,s,i,r,"max")}}SU.className="MaxPooling2D";$e(SU);class _U extends bU{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return rs(r),Pr(i),Ab(e,t,s,i,r,"avg")}}_U.className="AveragePooling2D";$e(_U);class CU extends Ht{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ee(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ls(this.poolSize,"poolSize"),Ls(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,rs(this.dataFormat),Pr(this.padding),this.inputSpec=[new _s({ndim:5})]}computeOutputShape(e){e=an(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Bo(t,this.poolSize[0],this.padding,this.strides[0]),s=Bo(s,this.poolSize[1],this.padding,this.strides[1]),i=Bo(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,i]:[e[0],t,s,i,e[4]]}call(e,t){return de(()=>(this.invokeCallHook(e,t),this.poolingFunction(Tt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class TU extends CU{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return rs(r),Pr(i),xU(e,t,s,i,r,"max")}}TU.className="MaxPooling3D";$e(TU);class IU extends CU{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return rs(r),Pr(i),xU(e,t,s,i,r,"avg")}}IU.className="AveragePooling3D";$e(IU);class EU extends Ht{constructor(e){super(e),this.inputSpec=[new _s({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Et}}class MU extends EU{constructor(e){super(e||{})}call(e,t){return de(()=>{const s=Tt(e);return ds(s,1)})}}MU.className="GlobalAveragePooling1D";$e(MU);class kU extends EU{constructor(e){super(e||{})}call(e,t){return de(()=>{const s=Tt(e);return zo(s,1)})}}kU.className="GlobalMaxPooling1D";$e(kU);class AU extends Ht{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,rs(this.dataFormat),this.inputSpec=[new _s({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Et}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class NU extends AU{call(e,t){return de(()=>{const s=Tt(e);return this.dataFormat==="channelsLast"?ds(s,[1,2]):ds(s,[2,3])})}}NU.className="GlobalAveragePooling2D";$e(NU);class RU extends AU{call(e,t){return de(()=>{const s=Tt(e);return this.dataFormat==="channelsLast"?zo(s,[1,2]):zo(s,[2,3])})}}RU.className="GlobalMaxPooling2D";$e(RU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class DU extends Ht{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const i=t.layer,r=al(i,s);delete t.layer;const o={layer:r};return Object.assign(o,t),new e(o)}}class LU extends DU{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=an(e),e.length<3)throw new ee(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=an(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),i=e[1];return[s[0],i].concat(s.slice(1))}call(e,t){return de(()=>(e=Tt(e),GB((o,a)=>[Tt(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}LU.className="TimeDistributed";$e(LU);function Jee(n){Ih(bQ,"BidirectionalMergeMode",n)}const Qee="concat";class PU extends DU{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=al(s),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=al(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Qee:e.mergeMode,Jee(this.mergeMode),e.weights)throw new Et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,i,r;return this.returnState&&(r=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(r).concat(r.slice()):[s].concat(r).concat(r.slice()):$i(i)}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=WB(e,s,i,this.numConstants);if(e=r.inputs,s=r.initialState,i=r.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&i==null)return super.apply(e,t);const o=[],a=[];if(s!=null){const c=s.length;if(c%2>0)throw new ee("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const u=s.map(h=>new _s({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(i!=null)throw new Et("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof ya;for(const c of o)if(c instanceof ya!==l)throw new ee("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const d=super.apply(c,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return de(()=>{const s=t.initialState;let i,r;if(s==null)i=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(i)&&(o=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=oh(r,1));let a;return this.mergeMode==="concat"?a=hk([i,r]):this.mergeMode==="sum"?a=Ue(i,r):this.mergeMode==="ave"?a=ne(.5,Ue(i,r)):this.mergeMode==="mul"?a=ne(i,r):this.mergeMode==null&&(a=[i,r]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){zu(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),zu(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const r=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(r).concat(r):[s].concat(r).concat(r)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=al(t.layer);if(delete t.layer,t.numConstants!=null)throw new Et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=s,new e(i)}}PU.className="Bidirectional";$e(PU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $U extends Ht{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return de(()=>(e=Tt(e),e.dtype!=="float32"&&(e=Ta(e,"float32")),Ue(ne(e,this.scale),this.offset)))}}$U.className="Rescaling";$e($U);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:ete,cropAndResize:tte}=ku;class FU extends Ht{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,i,r,o,a,l){return de(()=>{let c,u=!1;const h=t/o,d=s/a,f=(i+t)/o,m=(r+s)/a,x=[h,d,f,m],y=[];e.rank===3?(u=!0,c=bc([e])):c=e;for(let C=0;C<c.shape[0];C++)y.push(x);const v=YO(y,[y.length,4]),w=Lm(0,y.length,1,"int32"),S=tte(c,v,w,[i,r],"nearest");return Ta(u?Tt(ah(S)):S,l)})}upsize(e,t,s,i){return de(()=>{const r=ete(e,[t,s]);return Ta(r,i)})}call(e,t){return de(()=>{const s=Tt(e),i=s.dtype,r=s.shape,o=r[r.length-3],a=r[r.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,o,a,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=an(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}FU.className="CenterCrop";$e(FU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nte(n,e,t,s){let i=Tt(n);if(i.dtype!=="int32"&&(i=Ta(i,"int32")),e==="int")return i;const r=i.shape;if(i.rank===0&&(i=tr(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=tr(i,-1)),i.rank>2)throw new ee(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${r} which would result in output rank ${i.rank}.`);const o=["multiHot","oneHot"].includes(e),a=i;let l;if(typeof s<"u"&&e==="count"?l=H3(a,s,t,o):l=H3(a,[],t,o),e!=="tfIdf")return l;if(s)return ne(l,s);throw new ee("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class OU extends Ht{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=an(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return de(()=>{e=Tt(e),e.dtype!=="int32"&&(e=Ta(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ee(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Tt(t.countWeights)}const i=zo(e),r=m1(e),o=Lr(this.numTokens,i).bufferSync().get(0),a=Sh(r,0).bufferSync().get(0);if(!(o&&a))throw new ee(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return nte(e,this.outputMode,this.numTokens,s)})}}OU.className="CategoryEncoding";$e(OU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ste=["bilinear","nearest"],MD=new Set(ste);class zU extends Ht{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(MD.has(e.interpolation))this.interpolation=e.interpolation;else throw new ee(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){e=an(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return de(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return ku.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return ku.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...MD]} are supported`)})}}zU.className="Resizing";$e(zU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function X_(n){return new Ak(n)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ite=xe();ite.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var kD;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(kD||(kD={}));var AD;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(AD||(AD={}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ND;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(ND||(ND={}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&F(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rte=zz;class Nb extends uE{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new rO(this,ua())}nextDataId(){return Nb.nextDataId++}write(e,t,s){this.firstUse&&(this.firstUse=!1,xe().get("IS_NODE")&&wr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&dg(s[0])){const r=s.map(o=>fc(o));i=this.write(r,e,t)}else i=this.write(s,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,i,r){this.data.set(e,{values:t,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const i=this.readSync(s.real.dataId),r=this.readSync(s.imag.dataId);return ml(i,r)}return D7(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>wc(i));return zt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(e.shape,e.dtype,t)}makeOutput(e,t,s){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Pi();return e(),{kernelMs:Pi()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){lt([e],"where");const t=this.readSync(e.dataId);return rte(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Nb.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const ote=n=>{const{x:e}=n.inputs,t=n.backend;lt(e,"abs");let s=new Float32Array(Se(e.shape));const i=t.data.get(e.dataId).values;return s=BU(i),t.makeOutput(s,e.shape,e.dtype)},ate={kernelName:aw,backendName:"cpu",kernelFunc:ote};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gs(n){return(e,t,s,i,r)=>{const o=Mt(e,t),a=o.length,l=mt(o),c=Se(o),u=Ks(r,c),h=e.length,d=t.length,f=mt(e),m=mt(t),x=lf(e,o),y=lf(t,o);if(x.length+y.length===0)for(let v=0;v<u.length;++v)u[v]=n(s[v%s.length],i[v%i.length]);else for(let v=0;v<u.length;++v){const w=Mf(v,a,l),b=w.slice(-h);x.forEach(k=>b[k]=0);const S=Sa(b,h,f),C=w.slice(-d);y.forEach(k=>C[k]=0);const E=Sa(C,d,m);u[v]=n(s[S],i[E])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nr(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",r),imag:t.makeTensorInfo(i.shape,"float32",o)},a}const lte={kernelName:SE,backendName:"cpu",kernelFunc:nr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M1(n,e,t="float32"){if(t==="complex64"){const i=M1(n,e,"float32"),r=M1(n,e,"float32");return nr({inputs:{real:i,imag:r},backend:n})}const s=oi(Se(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aa(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const cte={kernelName:Lg,backendName:"cpu",kernelFunc:Aa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hh(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.real,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const ute={kernelName:HE,backendName:"cpu",kernelFunc:hh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UU(n,e,t,s){if(s==="int32"){const i=Int32Array.from(n);return[e,"int32",i]}if(s==="bool"){const i=bh([0],t),[r,o]=gs((a,l)=>a!==l?1:0)(e,[],n,i,"bool");return[o,"bool",r]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Ic(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return Aa({inputs:{x:i},backend:t});const u=M1(t,i.shape,i.dtype),h=Ic({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),d=nr({inputs:{real:h,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),d}if(i.dtype==="complex64"){const u=hh({inputs:{input:i},backend:t}),h=Ic({inputs:{x:u},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(u),h}if(!lO(i.dtype,r)){const u=Aa({inputs:{x:i},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:r}}const o=t.data.get(i.dataId).values,[a,l,c]=UU(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}const hte={kernelName:bg,backendName:"cpu",kernelFunc:Ic};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Os(n,e,t,s){return t==null?({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;lt([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=o.dtype==="string"?ch(c):c,d=o.dtype==="string"?ch(u):u,f=s||o.dtype,[m,x]=e(o.shape,a.shape,h,d,f);return l.makeTensorInfo(x,f,m)}:({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=Ic({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(d.dataId).values,x=Ic({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(x.dataId),v=y.complexTensorInfos.real,w=y.complexTensorInfos.imag,b=l.data.get(v.dataId).values,S=l.data.get(w.dataId).values,[C,E,k]=t(o.shape,a.shape,f,m,b,S),I=l.makeTensorInfo(k,"float32",C),A=l.makeTensorInfo(k,"float32",E),N=nr({inputs:{real:I,imag:A},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(x),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo(A),N}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=s||o.dtype,[d,f]=e(o.shape,a.shape,c,u,h);return l.makeTensorInfo(f,h,d)}}}function Nk(n){return(e,t,s,i,r,o)=>{const a=Mt(e,t),l=Se(a),c=a.length,u=mt(a),h=Ks("float32",l),d=Ks("float32",l),f=lf(e,a),m=lf(t,a),x=ml(s,i),y=ml(r,o),v=e.length,w=mt(e),b=t.length,S=mt(t);if(f.length+m.length===0)for(let C=0;C<h.length;C++){const E=C%x.length,k=C%y.length,I=n(x[E*2],x[E*2+1],y[k*2],y[k*2+1]);h[C]=I.real,d[C]=I.imag}else for(let C=0;C<h.length;C++){const E=Mf(C,c,u),k=E.slice(-v);f.forEach(V=>k[V]=0);const I=Sa(k,v,w),A=E.slice(-b);m.forEach(V=>A[V]=0);const N=Sa(A,b,S),L=n(x[I*2],x[I*2+1],y[N*2],y[N*2+1]);h[C]=L.real,d[C]=L.imag}return[h,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VU=gs((n,e)=>n+e),dte=Nk((n,e,t,s)=>({real:n+t,imag:e+s})),ff=Os(kf,VU,dte),fte={kernelName:kf,backendName:"cpu",kernelFunc:ff};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rk(n,e,t,s,i){const r=Se(s),o=oi(i,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(r>0?o[l]+=e[a]:o[l]+=1)}return o}function WU(n,e,t,s=!1){const i=n.shape[0],r=n.shape[1],o=zt([i,t],e.dtype);for(let a=0;a<i;a++)for(let l=0;l<r;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uc(n){return(e,t,s)=>{const i=Ks(t,e.length);for(let r=0;r<e.length;++r)i[r]=n(e[r],s);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gn(n,e,t){return({inputs:s,attrs:i,backend:r})=>{const{x:o}=s;if(lt(o,n),o.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const a=r,l=a.data.get(o.dataId).values,c=Se(o.shape),u=t||o.dtype,h=fs(u,c);for(let d=0;d<c;++d)h[d]=e(l[d],i);return a.makeTensorInfo(o.shape,u,h)}}function Pf(n,e,t){return({inputs:s,attrs:i,backend:r})=>{const{x:o}=s;if(lt(o,n),o.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const a=r,l=a.data.get(o.dataId).values,c=t||o.dtype,u=e(l,c,i);return a.makeTensorInfo(o.shape,c,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GU=Uc(n=>Math.ceil(n)),pte=Pf(Sg,GU),mte={kernelName:Sg,backendName:"cpu",kernelFunc:pte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(n,e,t,s){const i=fs(t,Se(e));if(s&&t!=="string"){let r=0;n.forEach(o=>{const a=Se(o.shape);i.set(o.vals,r),r+=a})}else{let r=0;n.forEach(o=>{const a=t==="string"?ch(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+r;for(let h=0;h<o.shape[1];++h)i[u+h]=a[l++]}r+=o.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XU=gs((n,e)=>n===e?1:0),jU=Os(Sw,XU,null,"bool"),gte={kernelName:Sw,backendName:"cpu",kernelFunc:jU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qU=Uc(n=>Math.exp(n)),KU=Pf(kg,qU,"float32"),xte={kernelName:kg,backendName:"cpu",kernelFunc:KU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YU=Uc(n=>Math.expm1(n)),yte=Pf(Ag,YU),vte={kernelName:Ag,backendName:"cpu",kernelFunc:yte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZU=Uc(n=>Math.floor(n)),wte=Pf(Ng,ZU),bte={kernelName:Ng,backendName:"cpu",kernelFunc:wte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JU(n,e,t,s,i,r,o,a,l){const c=zt([s,r],t);for(let u=0;u<s;u++){const h=[];let d=0;for(let f=0;f<i;f++){const m=n[u*i+f];d+=m*o[f],h.push(m)}if(d<0||d>=l/r)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let f=0;f<r;f++)c.values[u*r+f]=e.get(...e.indexToLoc(d*r+f))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QU(n,e,t){const s=zt(t,n.dtype);for(let i=0;i<s.size;++i){const o=s.indexToLoc(i).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(s.values[i]=n.values[u])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eV=gs((n,e)=>n>e?1:0),Ste=Os(Iw,eV,null,"bool"),_te={kernelName:Iw,backendName:"cpu",kernelFunc:Ste};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tV=gs((n,e)=>n>=e?1:0),Cte=Os(Dg,tV,null,"bool"),Tte={kernelName:Dg,backendName:"cpu",kernelFunc:Cte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nV=gs((n,e)=>n<e?1:0),Ite=Os(Mw,nV,null,"bool"),Ete={kernelName:Mw,backendName:"cpu",kernelFunc:Ite};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sV=gs((n,e)=>n<=e?1:0),Mte=Os(kw,sV,null,"bool"),kte={kernelName:kw,backendName:"cpu",kernelFunc:Mte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iV(n,e,t){const s=(e-n)/(t-1),i=oi(t,"float32");i[0]=n;for(let r=1;r<i.length;r++)i[r]=i[r-1]+s;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rV=Uc(n=>Math.log(n)),Ate=Pf(Og,rV),Nte={kernelName:Og,backendName:"cpu",kernelFunc:Ate};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(n,e,t,s){const i=Ks(s,Se(t));for(let r=0;r<i.length;++r){const o=r*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}i[r]=a}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aV=gs((n,e)=>Math.max(n,e)),Rte=Os(Bg,aV),Dte={kernelName:Bg,backendName:"cpu",kernelFunc:Rte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lV=gs((n,e)=>Math.min(n,e)),Lte=Os(Ug,lV),Pte={kernelName:Ug,backendName:"cpu",kernelFunc:Lte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk=gs((n,e)=>n*e),$te=Nk((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),Rb=Os(Wg,Dk,$te),Fte={kernelName:Wg,backendName:"cpu",kernelFunc:Rb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(n,e,t){const s=Pc(-1,t);return Dk([],e,s,n,t)}function Ote(n){const{inputs:e,backend:t}=n,{x:s}=e;lt(s,"neg");const i=t.data.get(s.dataId).values,[r,o]=cV(i,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,r)}const zte={kernelName:Bw,backendName:"cpu",kernelFunc:Ote};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uV=gs((n,e)=>n!==e?1:0),Bte=Os(Uw,uV,null,"bool"),Ute={kernelName:Uw,backendName:"cpu",kernelFunc:Bte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lk(n,e,t,s,i){const r=e.length,o=Se(e),a=mt(e),l=mt(i),c=Ks(t,Se(i));for(let u=0;u<o;++u){const h=Mf(u,r,a),d=new Array(h.length);for(let m=0;m<d.length;m++)d[m]=h[s[m]];const f=Sa(d,r,l);c[f]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vi(n){const{inputs:e,attrs:t,backend:s}=n,{x:i}=e,{perm:r}=t;lt(i,"transpose");const o=i.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=i.shape[r[h]];const l=s.data.get(i.dataId).values,c=Lk(l,i.shape,i.dtype,r,a);return{dataId:s.write(c,a,i.dtype),shape:a,dtype:i.dtype}}const Vte={kernelName:Hd,backendName:"cpu",kernelFunc:Vi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hV(n,e,t,s){const[i,r]=Fs(n,s),o=lr(e,"int32"),a=oi(Se(i),o),l=Se(r);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let d=0;d<l;++d)h*=t[u+d];a[c]=h}return{outVals:a,outShape:i,outDtype:o}}function Wte(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;lt(i,"prod");const a=i.shape.length,l=Ut(r,i.shape),c=Wn(l,a);let u=l,h=i;const d=[];c!=null&&(h=Vi({inputs:{x:i},backend:t,attrs:{perm:c}}),d.push(h),u=is(u.length,a));const f=t.data.get(h.dataId).values,{outVals:m,outShape:x,outDtype:y}=hV(h.shape,h.dtype,f,u);let v=x;return o&&(v=ms(x,l)),d.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(v,y,m)}const Gte={kernelName:jw,backendName:"cpu",kernelFunc:Wte};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hte(n,e,t){n.forEach((s,i)=>{if(s<0||s>=t){const r=Mf(i,e.length,mt(e)).join(",");throw new Error(`indices[${r}] = ${s} is not in [0, ${t})`)}})}function Xte(n,e){for(let t=0;t<n.length;++t){const s=n[t],i=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<s.length;++r)if(s[r-1]>s[r])throw new Error("Ragged splits must be sorted in ascending order")}}function jte(n,e,t,s){const i=[];let r=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);Xte(t,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let h=1;h<l+1;++h)a[c].push(h*u)}for(let c=0;c<n.length;++c){let u=n[c],h=n[c]+1;for(let d=0;d<t.length;++d){const f=t[d],m=d+e.length-1;if(m>=0){const x=a[m],y=x[x.length-1]-f[u];for(let v=u;v<h;++v)a[m].push(f[v+1]+y)}u=f[u],h=f[h]}h!==u&&(i.push([u,h]),r+=h-u)}return{outSplits:a,valueSlices:i,numValues:r}}function qte(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,i=fs("int32",s);e.push(i),n[t].forEach((r,o)=>i[o]=r)}return e}function RD(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function Kte(n,e,t,s,i,r){const o=RD(e,2)[1],a=RD(r,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let h=0;h<s;++h)i[l*a+h]=n[u*o+h];++l}}function Yte(n,e,t,s,i){const r=e.slice();r[0]=i;const o=fs(t,Se(r)),a=n.length,l=a===0?0:a/e[0];return Kte(n,e,s,l,o,r),[o,r]}function dV(n,e,t,s,i,r,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Hte(r,o,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:u,valueSlices:h,numValues:d}=jte(r,o,n,c),f=qte(u),m=Yte(t,s,i,h,d);return[f,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DD=2147483647;function fV(n,e,t,s,i,r,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=i.length===0,c=o.length===0,u=[];a||u.push(e[0]),l||u.push(i[0]),c||u.push(o[0]);for(let y=1;y<u.length;++y)if(u[y]!==u[y-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],d=fs("int32",h+1);d[0]=0;for(let y=0;y<h;++y){const v=a?n[0]:n[y],w=l?s[0]:s[y],b=c?r[0]:r[y];if(b===0)throw new Error("Requires delta != 0");let S;if(b>0&&w<v||b<0&&w>v)S=0;else if(S=Math.ceil(Math.abs((w-v)/b)),S>DD)throw new Error(`Requires ((limit - start) / delta) <= ${DD}`);d[y+1]=d[y]+S}const f=d[h],m=fs(t,f);let x=0;for(let y=0;y<h;++y){const v=d[y+1]-d[y];let w=a?n[0]:n[y];const b=c?r[0]:r[y];for(let S=0;S<v;++S)m[x++]=w,w+=b}return[d,m]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yr=Lo;class k1{constructor(e,t,s,i,r,o,a,l,c,u){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=i,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=o4(u),this.raggedRank=a4(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Yr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Yr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Yr.VALUE_ROWIDS:return k1.getMaxWidthValueRowID(t);case Yr.ROW_SPLITS:return k1.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Yr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let i=0;i<t-1;++i){const r=e[i+1]-e[i];r>s&&(s=r)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,i=e[0],r=0;for(let o=1;o<t;++o){const a=e[o];a!==i&&(i=a,r=Math.max(o-s,r),s=o)}return Math.max(t-s,r)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return PD(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;l4(s,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=r4(this.raggedRank,i,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,s){const i=Math.min(e,s),r=[];let o=0;for(let a=0;a<i;++a,o+=t)r.push(o);for(let a=i;a<e;++a)r.push(-1);return F(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,s,i){const r=e.length,o=[];for(let a=0;a<r-1;++a){const l=e[a+1]-e[a];let c=Math.min(i,l),u=t[a];u===-1&&(c=0);for(let h=0;h<c;++h)o.push(u),u+=s;for(let h=0;h<l-c;++h)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,i){const r=e.length,o=[];if(r===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let u=1;u<r;++u){const h=e[u];if(h===l)c>=0&&(++a,a<i?c+=s:c=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,i){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Yr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,s,i);case Yr.ROW_SPLITS:if(r.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(r,t,s,i);default:throw new Error(`Unsupported partition type: ${Yr[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Yr.FIRST_DIM_SIZE:return e[0];case Yr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Yr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Yr[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*s[l+1];const r=PD(s,!1),o=fs(this.valuesDType,Se(r));if(i[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,i[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],s[c]);this.setOutput(this.raggedRank,l,o,r)}return[r,o]}setOutput(e,t,s,i){if(s.length===0)return;const r=this.values,o=s;let a=i.slice();a=a.slice(e+1);const l=Se(a),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const m=this.defaultValueShape;de(()=>{const x=ae(u,m);u=am(x,a).dataSync()})}let h=0,d=0,f=0;for(let m=0;m<=c;++m){let x=m<c?t[m]:-1;if(x===f){++f;continue}if(d<f){const y=r.subarray(h*l),v=o.subarray(d*l),w=(f-d)*l;LD(v,y,w)}if(m>=c){const y=s.length;x=Math.floor(y/l)}if(x>f)if(this.defaultValue.length===1)o.subarray(f*l,x*l).fill(this.defaultValue[0]),f=x;else for(;x>f;){const y=o.slice(f*l);LD(y,u,l),++f}x<0?(h=m+1,d=f):(h=m,d=f,f=d+1)}}}function LD(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function PD(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function pV(n,e,t,s,i,r,o,a,l,c){return new k1(n,e,t,s,i,r,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mV(n,e,t,s){const i=n===e,r=n<e&&t<0,o=e<n&&t>1;if(i||r||o)return oi(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=oi(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gV=Uc(n=>1/Math.sqrt(n)),Zte=Pf(Kg,gV),Jte={kernelName:Kg,backendName:"cpu",kernelFunc:Zte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dd(n,e,t,s,i,r,o,a,l,c){const u=[s/i,i],h=n.values,d=e.values;if(s===0)return zt(t,e.dtype);const f=zt(u,e.dtype);typeof l=="string"||typeof l=="number"?f.values.fill(l):typeof l=="boolean"&&f.values.fill(+l);for(let m=0;m<r;m++){const x=[];let y=0;for(let v=0;v<o;v++){const w=h[m*o+v];x.push(w),y+=w*a[v]}if(y<0||y>=s/i)throw new Error(`Invalid indices: ${x} does not index into ${t}`);for(let v=0;v<i;v++)c?f.values[y*i+v]+=d[m*i+v]:f.values[y*i+v]=e.rank===0?d[0]:d[m*i+v]}return f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qte=Uc(n=>1/(1+Math.exp(-n))),xV=gn(e0,n=>1/(1+Math.exp(-n))),ene={kernelName:e0,backendName:"cpu",kernelFunc:xV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yV(n,e,t,s,i){const r=BM(s,e,t),o=Se(t),a=mt(s);if(r){const h=UM(e,a);return i==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=i==="string"?ch(n):n,c=zt(s,i,l),u=zt(t,i);for(let h=0;h<u.size;++h){const d=u.indexToLoc(h),f=d.map((m,x)=>m+e[x]);u.set(c.get(...f),...d)}return i==="string"?M4(u.values):u.values}function dh(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s;lt(i,"slice");const[a,l]=xb(i,r,o);OM(i,a,l);const c=t.data.get(i.dataId).values,u=yV(c,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,u)}const tne={kernelName:Qw,backendName:"cpu",kernelFunc:dh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vV(n,e,t,s,i,r,o){const a=e[0],l=r[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(m4(a));const y=fs(t,0),v=fs(i,0);return[y,[0,h],v,c,u]}let d=!0,f=0;const m=new Array(l).fill(0);for(let y=0;y<a;++y){const v=n[y*h];if(v<0)throw new Error(g4(y,v));if(v>=l)throw new Error(x4(y,v,l));++m[v],d=d&&v>=f,f=v}let x=!0;for(let y=0;y<l;++y){const v=m[y]===0;c[y]=v,x=x&&!v,m[y]=Math.max(m[y],1),y>0&&(m[y]+=m[y-1])}if(x&&d){const y=n,v=s;for(let w=0;w<a;++w)u[w]=w;return[y,[a,h],v,c,u]}else{const y=m[l-1],v=fs(t,y*h),w=fs(i,y),b=new Array(l).fill(0);for(let S=0;S<a;++S){const C=n[S*h],E=b[C],k=(C===0?0:m[C-1])+E;b[C]++;for(let I=0;I<h;++I)v[k*h+I]=n[S*h+I];w[k]=s[S],u[S]=k}for(let S=0;S<l;++S)if(b[S]===0){const E=S===0?0:m[S-1];v[E*h+0]=S;for(let k=1;k<h;++k)v[E*h+k]=0;w[E]=o}return[v,[y,h],w,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wV(n,e,t,s,i){const r=Se(s),o=e[0],a=i.length,l=[];let c=1,u=-1;for(let y=0;y<a;++y){const v=i[y];if(v===-1){if(u!==-1)throw new Error(y4(u,y));u=y,l.push(1)}else{if(v<0)throw new Error(v4(y,v));c*=v,l.push(v)}}if(u!==-1){if(c<=0)throw new Error(w4());const y=Math.trunc(r/c);if(c*y!==r)throw new Error(b4(s,l));l[u]=y}if(Se(l)!==r)throw new Error(S4(s,l));const d=s.length,f=[];if(d>0){f[d-1]=1;for(let y=d-2;y>=0;--y)f[y]=f[y+1]*s[y+1]}const m=[];if(a>0){m[a-1]=1;for(let y=a-2;y>=0;--y)m[y]=m[y+1]*l[y+1]}const x=fs(t,o*a);for(let y=0;y<o;++y){let v=0;for(let w=0;w<d;++w)v+=n[y*d+w]*f[w];for(let w=0;w<a;++w)x[y*a+w]=Math.trunc(v/m[w]),v%=m[w]}return[x,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pk(n,e,t,s,i,r=!1,o=0){const a=s.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?i[a-1]+1:0;if(h<0)throw new Error(lT());const d=e.slice();d[0]=h;const f=d.reduce((b,S)=>b*S,1),m=fs(t,f);if(a===0)return h>0&&m.fill(o),[m,d];if(h<=0)throw new Error(lT());let x=0,y=1,v=0,w=i[x];for(;;){let b=0;if(y<a){if(b=i[y],w===b){++y;continue}if(w>=b)throw new Error(_4())}if(w<0||w>=h)throw new Error(C4(w,h));w>v&&m.fill(o,v*c,w*c);for(let S=x;S<y;++S){const C=s[S];if(C<0||C>=l[0])throw new Error(T4(S,s[S],l[0]));for(let E=0;E<c;E++)m[w*c+E]+=n[C*c+E]}if(r)for(let S=0;S<c;S++)m[w*c+S]/=y-x;if(x=y,++y,v=w+1,w=b,y>a)break}return v<h&&m.fill(o,v*c,h*c),[m,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nne=Uc(n=>Math.sqrt(n)),sne=gn(n0,n=>Math.sqrt(n)),ine={kernelName:n0,backendName:"cpu",kernelFunc:sne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bV=gs((n,e)=>{const t=n-e;return t*t}),rne=Os(s0,bV),one={kernelName:s0,backendName:"cpu",kernelFunc:rne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SV(n,e,t,s){const i=zt(n,e.dtype);for(let r=0;r<i.size;r++){const o=i.indexToLoc(r),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+s[l];i.set(e.get(...a),...o)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ane{constructor(e,t,s,i,r,o){this.separator=fc(e),this.nGramWidths=t,this.leftPad=fc(s),this.rightPad=fc(i),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,i,r,o){for(let a=0;a<r;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(r-(a+1))),h=o-(c+u),d=t+(c>0?0:a-l);let f=0;f+=c*this.leftPad.length;for(let w=0;w<h;++w)f+=e[d+w].length;f+=u*this.rightPad.length;const m=c+u+h-1;f+=m*this.separator.length,s[i+a]=new Uint8Array(f);const x=s[i+a];let y=0;const v=w=>w.forEach(b=>x[y++]=b);for(let w=0;w<c;++w)v(this.leftPad),v(this.separator);for(let w=0;w<h-1;++w)v(e[d+w]),v(this.separator);if(h>0){v(e[d+h-1]);for(let w=0;w<u;++w)v(this.separator),v(this.rightPad)}else{for(let w=0;w<u-1;++w)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,t){const s=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let u=t[c]>=l;if(u=u&&t[c]<=s,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const r=i-1,o=fs("int32",i);if(s===0||i===0){const l=new Array(s);for(let c=0;c<=r;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=r;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[r]);for(let l=0;l<r;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],f=this.getNumNGrams(d,h);this.createNGrams(e,c,a,u,f,h),u+=f}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth,f=1;this.createNGrams(e,c,a,u,f,d)}}return[a,o]}}function _V(n,e,t,s,i,r,o,a){return new ane(t,s,i,r,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lne(n,e,t,s){if(!n.length)return;if(e.length===0){for(let r=0;r<n.length;++r)s.push(n.subarray(r,r+1));return}if(e.length===1){const r=e[0];let o=n.indexOf(r);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(r)}(!t||n.length!==0)&&s.push(n);return}let i=0;for(let r=0;r<n.length+1;r++)if(r===n.length||e.indexOf(n[r])!==-1){const o=n.subarray(i,r);(!t||o.length!==0)&&s.push(o),i=r+1}}function CV(n,e,t){const s=n.length,i=[];let r=0,o=0;const a=new Array(s);for(let d=0;d<s;++d){const f=i.length;lne(n[d],e,t,i);const m=i.length-f;a[d]=m,r+=m,o=Math.max(o,m)}const l=fs("int32",r*2),c=new Array(r),u=[s,o];let h=0;for(let d=0;d<s;++d)for(let f=0;f<a[d];++f)l[h*2]=d,l[h*2+1]=f,c[h]=i[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TV(n,e){const t=fs("int32",n.length);for(let s=0;s<n.length;++s)t[s]=Z7(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IV=gs((n,e)=>n-e),cne=Nk((n,e,t,s)=>({real:n-t,imag:e-s})),$k=Os(i0,IV,cne),une={kernelName:i0,backendName:"cpu",kernelFunc:$k};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EV(n,e){const t=new Array(n.rank);for(let i=0;i<t.length;i++)t[i]=n.shape[i]*e[i];const s=zt(t,n.dtype);for(let i=0;i<s.values.length;++i){const r=s.indexToLoc(i),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=r[l]%n.shape[l];const a=n.locToIndex(o);s.values[i]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jp=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function MV(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*u/a+h)),f=Math.min(s,Math.floor(e+(a-l)*u/a+h));MV(n,e,d,f)}const i=n[e];let r=t,o=s;for(Zl(n,t,e),jp(n[s],i)>0&&Zl(n,t,s);r<o;){for(Zl(n,r,o),r++,o--;jp(n[r],i)<0;)r=r+1;for(;jp(n[o],i)>0;)o=o-1}jp(n[t],i)===0?Zl(n,t,o):(o=o+1,Zl(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function kV(n,e,t,s,i){const r=e[e.length-1],[o,a]=[n.length/r,r],l=Ks(t,o*s),c=Ks("int32",o*s);for(let h=0;h<o;h++){const d=h*a,f=n.subarray(d,d+a);let m=new Array(f.length);f.forEach((w,b)=>m[b]={value:w,index:b}),s<m.length&&(MV(m,s),m=m.slice(0,s)),i&&m.sort(jp);const x=h*s,y=l.subarray(x,x+s),v=c.subarray(x,x+s);for(let w=0;w<s;w++)y[w]=m[w].value,v[w]=m[w].index}const u=e.slice();return u[u.length-1]=s,[zt(u,t,l),zt(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AV(n,e,t,s){const i=Ut(e,t)[0],r=[1,t[0],1];for(let m=0;m<i;m++)r[0]*=t[m];r[1]=t[i];for(let m=i+1;m<t.length;m++)r[2]*=t[m];const o={},a=new Int32Array(t[i]),l=new ii(r,s,n),c=[],u=r[0]===1&&r[2]===1;for(let m=0;m<t[i];m++){let x;if(u)x=n[m].toString();else{const y=[];for(let v=0;v<r[0];v++)for(let w=0;w<r[2];w++)y.push(l.get(v,m,w));x=y.join(",")}if(o[x]!==void 0)a[m]=o[x];else{const y=Object.keys(o).length;o[x]=y,a[m]=y,c.push(m)}}const h=r.slice();h[1]=Object.keys(o).length;const d=new ii(h,s);c.forEach((m,x)=>{for(let y=0;y<r[0];y++)for(let v=0;v<r[2];v++)d.set(l.get(y,m,v),y,x,v)});const f=t.slice();return f[i]=h[1],{outputValues:d.values,outputShape:f,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hne=Object.freeze(Object.defineProperty({__proto__:null,simpleAbsImpl:BU,addImpl:VU,bincountImpl:Rk,bincountReduceImpl:WU,castImpl:UU,ceilImpl:GU,concatImpl:HU,equalImpl:XU,expImpl:qU,expm1Impl:YU,floorImpl:ZU,gatherNdImpl:JU,gatherV2Impl:QU,greaterImpl:eV,greaterEqualImpl:tV,lessImpl:nV,lessEqualImpl:sV,linSpaceImpl:iV,logImpl:rV,maxImpl:oV,maximumImpl:aV,minimumImpl:lV,multiplyImpl:Dk,negImpl:cV,notEqualImpl:uV,prodImpl:hV,raggedGatherImpl:dV,raggedRangeImpl:fV,raggedTensorToTensorImpl:pV,rangeImpl:mV,rsqrtImpl:gV,scatterImpl:Dd,sigmoidImpl:Qte,sliceImpl:yV,sparseFillEmptyRowsImpl:vV,sparseReshapeImpl:wV,sparseSegmentReductionImpl:Pk,sqrtImpl:nne,squaredDifferenceImpl:bV,stridedSliceImpl:SV,stringNGramsImpl:_V,stringSplitImpl:CV,stringToHashBucketFastImpl:TV,subImpl:IV,tileImpl:EV,topKImpl:kV,transposeImpl:Lk,uniqueImpl:AV},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */rz("cpu",()=>new Nb,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NV=gn(Eg,n=>n>=0?n:Math.exp(n)-1),dne={kernelName:Eg,backendName:"cpu",kernelFunc:NV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s;lt([i],"leakyRelu");const o=Se(i.shape),a=t.data.get(i.dataId).values,l=Ks("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?r*a[c]:a[c];return t.makeTensorInfo(i.shape,"float32",l)}const fne={kernelName:Ew,backendName:"cpu",kernelFunc:RV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pne=gs((n,e)=>n<0?e*n:n);function DV(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e;lt([s,i],"prelu");const r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,[a,l]=pne(s.shape,i.shape,r,o,"float32");return t.makeTensorInfo(l,"float32",a)}const mne={kernelName:Xw,backendName:"cpu",kernelFunc:DV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LV=gn(Xg,n=>Math.max(0,n)),gne={kernelName:Xg,backendName:"cpu",kernelFunc:LV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PV=gn(jg,n=>Math.min(Math.max(0,n),6)),xne={kernelName:jg,backendName:"cpu",kernelFunc:PV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n,e,t,s,i){if(t==="linear")return Aa({inputs:{x:e},backend:n});if(t==="relu")return LV({inputs:{x:e},backend:n});if(t==="elu")return NV({inputs:{x:e},backend:n});if(t==="relu6")return PV({inputs:{x:e},backend:n});if(t==="prelu")return DV({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return RV({inputs:{x:e},backend:n,attrs:{alpha:i}});if(t==="sigmoid")return xV({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tn(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,o=Se(i.shape),a=aO(r,o),l=Se(a);F(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const c=t.data.get(i.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=a,h.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const yne={kernelName:qw,backendName:"cpu",kernelFunc:Tn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $V(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;lt([i,r],"matMul");const l=i.shape.length,c=r.shape.length,u=o?i.shape[l-2]:i.shape[l-1],h=a?r.shape[c-1]:r.shape[c-2],d=o?i.shape[l-1]:i.shape[l-2],f=a?r.shape[c-2]:r.shape[c-1],m=i.shape.slice(0,-2),x=r.shape.slice(0,-2),y=Se(m),v=Se(x),b=Mt(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([d,f]);F(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${o} and transposeB=${a} must match.`);const S=o?[y,u,d]:[y,d,u],C=a?[v,f,h]:[v,h,f],E=Tn({inputs:{x:i},backend:t,attrs:{shape:S}}),k=Tn({inputs:{x:r},backend:t,attrs:{shape:C}}),I=o?E.shape[1]:E.shape[2],A=o?E.shape[2]:E.shape[1],N=a?k.shape[1]:k.shape[2],L=Math.max(y,v),V=t.data.get(E.dataId).values,O=t.data.get(k.dataId).values,P=mt(E.shape),W=mt(k.shape),[H,Y,D]=o?[P[0],1,P[1]]:[P[0],P[1],1],[$,U,B]=a?[1,W[1],W[0]]:[W[1],1,W[0]],X=A*N,te=zt([L,A,N],E.dtype),oe=te.values,ue=t.blockSize;for(let Q=0;Q<L;Q++){const ke=Q%y,Me=Q%v;for(let De=0;De<A;De+=ue){const Ee=Math.min(De+ue,A);for(let Be=0;Be<N;Be+=ue){const ye=Math.min(Be+ue,N);for(let fe=0;fe<I;fe+=ue){const Re=Math.min(fe+ue,I);for(let We=De;We<Ee;We++)for(let Le=Be;Le<ye;Le++){let nt=0;for(let Ke=fe;Ke<Re;Ke++){const ot=V[ke*H+We*Y+Ke*D],vt=O[Ke*$+Le*U+Me*B];nt+=ot*vt}oe[Q*X+(We*N+Le)]+=nt}}}}}return t.disposeIntermediateTensorInfo(E),t.disposeIntermediateTensorInfo(k),t.makeTensorInfo(b,te.dtype,te.values)}const vne={kernelName:dw,backendName:"cpu",kernelFunc:$V};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wne(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;let d,f,m;const x=[];d=$V({inputs:{a:i,b:r},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(f=ff({inputs:{a:d,b:o},backend:t}),x.push(d),d=f),u&&(m=A1(t,d,u,a,h),x.push(d),d=m);for(const v of x)t.disposeIntermediateTensorInfo(v);return d}const bne={kernelName:u1,backendName:"cpu",kernelFunc:wne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sne=gn(pg,n=>Math.acos(n)),_ne={kernelName:pg,backendName:"cpu",kernelFunc:Sne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cne=gn(mg,n=>Math.acosh(n)),Tne={kernelName:mg,backendName:"cpu",kernelFunc:Cne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ine(n){const{inputs:e,backend:t}=n,s=e;lt(e,"addN");const i=s.map(a=>t.data.get(a.dataId).values),r=zt(s[0].shape,s[0].dtype),o=r.values;for(let a=0;a<s.length;a++){const l=i[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(r.shape,r.dtype,r.values)}const Ene={kernelName:gE,backendName:"cpu",kernelFunc:Ine};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;lt(i,"all");const a=Ut(r,i.shape);let l=a;const c=Wn(l,i.shape.length);let u=i;c!=null&&(u=Vi({inputs:{x:i},backend:t,attrs:{perm:c}}),l=is(l.length,i.shape.length)),Zs("all",l,u.shape.length);const[h,d]=Fs(u.shape,l),f=Se(d),m=oi(Se(h),u.dtype),x=t.data.get(u.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let b=x[w];for(let S=0;S<f;++S){const C=x[w+S];b=b&&C}m[v]=b}c!=null&&t.disposeIntermediateTensorInfo(u);const y=t.makeTensorInfo(h,u.dtype,m);if(o){const v=ms(h,a),w=Tn({inputs:{x:y},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(y),w}return y}const kne={kernelName:xE,backendName:"cpu",kernelFunc:Mne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ane(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;lt(i,"any");const a=Ut(r,i.shape);let l=a;const c=Wn(l,i.shape.length);let u=i;c!=null&&(u=Vi({inputs:{x:i},backend:t,attrs:{perm:c}}),l=is(l.length,i.shape.length)),Zs("any",l,u.shape.length);const[h,d]=Fs(u.shape,l),f=Se(d),m=oi(Se(h),u.dtype),x=t.data.get(u.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let b=x[w];for(let S=0;S<f;++S){const C=x[w+S];b=b||C}m[v]=b}c!=null&&t.disposeIntermediateTensorInfo(u);const y=t.makeTensorInfo(h,u.dtype,m);if(o){const v=ms(h,a),w=Tn({inputs:{x:y},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(y),w}return y}const Nne={kernelName:yE,backendName:"cpu",kernelFunc:Ane};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;lt(i,"argMax");let o=Ut(r,i.shape);const a=Wn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Vi({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=is(o.length,l.shape.length)),o=[o[0]],Zs("argMax",o,l.shape.length);const[u,h]=Fs(l.shape,o),d=Se(u),f=oi(d,"int32"),m=Se(h),x=t.data.get(l.dataId).values;for(let y=0;y<f.length;++y){const v=y*m;let w=x[v],b=0;for(let S=0;S<m;++S){const C=x[v+S];C>w&&(w=C,b=S)}f[y]=b}return c.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(u,"int32",f)}const Dne={kernelName:lw,backendName:"cpu",kernelFunc:Rne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;lt(i,"argMin");let o=Ut(r,i.shape);const a=Wn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Vi({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=is(o.length,l.shape.length)),o=[o[0]],Zs("argMin",o,l.shape.length);const[u,h]=Fs(l.shape,o),d=Se(u),f=oi(d,"int32"),m=Se(h),x=t.data.get(l.dataId).values;for(let y=0;y<f.length;++y){const v=y*m;let w=x[v],b=0;for(let S=0;S<m;++S){const C=x[v+S];C<w&&(w=C,b=S)}f[y]=b}return c.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(u,"int32",f)}const Pne={kernelName:cw,backendName:"cpu",kernelFunc:Lne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ne=gn(gg,n=>Math.asin(n)),Fne={kernelName:gg,backendName:"cpu",kernelFunc:$ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const One=gn(xg,n=>Math.asinh(n)),zne={kernelName:xg,backendName:"cpu",kernelFunc:One};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bne=gn(yg,n=>Math.atan(n)),Une={kernelName:yg,backendName:"cpu",kernelFunc:Bne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vne=gs((n,e)=>Math.atan2(n,e)),Wne=Os(wg,Vne),Gne={kernelName:wg,backendName:"cpu",kernelFunc:Wne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hne=gn(vg,n=>Math.atanh(n)),Xne={kernelName:vg,backendName:"cpu",kernelFunc:Hne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fk(n,e,t,s,i,r){const o=i.strideHeight,a=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,u=i.effectiveFilterHeight,h=i.effectiveFilterWidth,d=i.padInfo.top,f=i.padInfo.left,m=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=zt(i.outShape,t),y=x.values,v=i.outShape[1]*i.outShape[2]*i.outShape[3],w=i.outShape[2]*i.outShape[3],b=i.outShape[3];for(let S=0;S<i.batchSize;++S){const C=S*v,E=S*s[0];for(let k=0;k<i.inChannels;++k)for(let I=0;I<i.outHeight;++I){const A=I*o-d,N=Math.max(0,A),L=Math.min(i.inHeight,u+A),V=C+I*w;for(let O=0;O<i.outWidth;++O){const P=O*a-f,W=Math.max(0,P),H=Math.min(i.inWidth,h+P);let Y=m,D=0,$=0;for(let B=N;B<L;B+=l){const X=E+B*s[1];for(let te=W;te<H;te+=c){const oe=X+te*s[2],ue=n[oe+k];r==="max"&&ue>Y?Y=ue:r==="avg"&&(D+=ue,$++)}if(isNaN(Y))break}const U=V+O*b+k;y[U]=r==="avg"?D/$:Y}}}return x}function FV(n,e,t,s,i=!1,r=!1){const o=zt(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,u=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,x=zt(e,t,n);for(let y=0;y<s.batchSize;++y)for(let v=0;v<s.inChannels;++v)for(let w=0;w<s.outHeight;++w){const b=w*a-f;let S=b;for(;S<0;)S+=c;const C=Math.min(s.inHeight,h+b);for(let E=0;E<s.outWidth;++E){const k=E*l-m;let I=k;for(;I<0;)I+=u;const A=Math.min(s.inWidth,d+k);let N=Number.NEGATIVE_INFINITY,L=-1;for(let V=S;V<C;V+=c){const O=V-b;for(let P=I;P<A;P+=u){const W=P-k,H=x.get(y,V,P,v);H>N&&(N=H,i?L=r?((y*s.inHeight+V)*s.inWidth+P)*s.inChannels+v:(V*s.inWidth+P)*s.inChannels+v:L=O*d+W)}}o.set(L,y,w,E,v)}}return o}function OV(n,e,t,s,i,r){const o=i.strideDepth,a=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,u=i.dilationHeight,h=i.dilationWidth,d=i.effectiveFilterDepth,f=i.effectiveFilterHeight,m=i.effectiveFilterWidth,x=i.padInfo.front,y=i.padInfo.top,v=i.padInfo.left,w=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=zt(i.outShape,t),S=b.values,C=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],E=i.outShape[2]*i.outShape[3]*i.outShape[4],k=i.outShape[3]*i.outShape[4],I=i.outShape[4];for(let A=0;A<i.batchSize;++A){const N=A*C,L=A*s[0];for(let V=0;V<i.inChannels;++V)for(let O=0;O<i.outDepth;++O){const P=O*o-x;let W=P;for(;W<0;)W+=c;const H=Math.min(i.inDepth,d+P),Y=N+O*E;for(let D=0;D<i.outHeight;++D){const $=D*a-y;let U=$;for(;U<0;)U+=u;const B=Math.min(i.inHeight,f+$),X=Y+D*k;for(let te=0;te<i.outWidth;++te){const oe=te*l-v;let ue=oe;for(;ue<0;)ue+=h;const Q=Math.min(i.inWidth,m+oe),ke=X+te*I;let Me=w,De=0,Ee=0;for(let ye=W;ye<H;ye+=c){const fe=L+ye*s[1];for(let Re=U;Re<B;Re+=u){const We=fe+Re*s[2];for(let Le=ue;Le<Q;Le+=h){const nt=We+Le*s[3],Ke=n[nt+V];if(r==="max"&&Ke>Me?Me=Ke:r==="avg"&&(De+=Ke,Ee++),isNaN(Me))break}if(isNaN(Me))break}if(isNaN(Me))break}const Be=ke+V;S[Be]=r==="avg"?De/Math.max(Ee,1):Me}}}}return b}function jne(n,e){const t=zt(e.outShape,"int32"),s=e.strideDepth,i=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,f=e.padInfo.top,m=e.padInfo.left;for(let x=0;x<e.batchSize;++x)for(let y=0;y<e.inChannels;++y)for(let v=0;v<e.outDepth;++v){const w=v*s-d;let b=w;for(;b<0;)b+=o;const S=Math.min(e.inDepth,c+w);for(let C=0;C<e.outHeight;++C){const E=C*i-f;let k=E;for(;k<0;)k+=a;const I=Math.min(e.inHeight,u+E);for(let A=0;A<e.outWidth;++A){const N=A*r-m;let L=N;for(;L<0;)L+=l;const V=Math.min(e.inWidth,h+N);let O=Number.NEGATIVE_INFINITY,P=-1;for(let W=b;W<S;W+=o){const H=W-w;for(let Y=k;Y<I;Y+=a){const D=Y-E;for(let $=L;$<V;$+=l){const U=$-N,B=n.get(x,W,Y,$,y);B>=O&&(O=B,P=H*u*h+D*u+U)}}}t.set(P,x,v,C,A,y)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;lt(i,"avgPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;F(ai(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=go(i.shape,r,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&pn(u.inShape,u.outShape))h=Aa({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,f=mt(i.shape),m=Fk(d,i.shape,i.dtype,f,u,"avg");h=t.makeTensorInfo(u.outShape,i.dtype,m.values)}return h}const Kne={kernelName:uw,backendName:"cpu",kernelFunc:qne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;lt(i,"avgPool3d");const u=wl(i.shape,r,o,1,a,l,c),h=t.data.get(i.dataId).values,d=OV(h,i.shape,i.dtype,mt(i.shape),u,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const Zne={kernelName:hw,backendName:"cpu",kernelFunc:Yne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jne(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;lt([i,r],"avgPool3DGrad");const u=wl(r.shape,o,a,1,l,c),h=u.strideDepth,d=u.strideHeight,f=u.strideWidth,m=u.filterDepth,x=u.filterHeight,y=u.filterWidth,v=u.dilationDepth,w=u.dilationHeight,b=u.dilationWidth,S=u.effectiveFilterDepth,C=u.effectiveFilterHeight,E=u.effectiveFilterWidth,k=S-1-u.padInfo.front,I=E-1-u.padInfo.left,A=C-1-u.padInfo.top,N=zt(r.shape,"float32"),L=1/(m*x*y),V=t.bufferSync(i);for(let O=0;O<u.batchSize;++O)for(let P=0;P<u.inChannels;++P)for(let W=0;W<u.inDepth;++W)for(let H=0;H<u.inHeight;++H)for(let Y=0;Y<u.inWidth;++Y){const D=W-k,$=H-A,U=Y-I;let B=0;for(let X=0;X<S;X+=v){const te=(D+X)/h;if(!(te<0||te>=u.outDepth||Math.floor(te)!==te))for(let oe=0;oe<C;oe+=w){const ue=($+oe)/d;if(!(ue<0||ue>=u.outHeight||Math.floor(ue)!==ue))for(let Q=0;Q<E;Q+=b){const ke=(U+Q)/f;if(ke<0||ke>=u.outWidth||Math.floor(ke)!==ke)continue;const Me=V.get(O,te,ue,ke,P);B+=Me}}}N.set(B*L,O,W,H,Y,P)}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const Qne={kernelName:wE,backendName:"cpu",kernelFunc:Jne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ese(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;lt([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=go(o.shape,a,l,1,c),h=u.strideHeight,d=u.strideWidth,f=u.filterHeight,m=u.filterWidth,x=u.dilationHeight,y=u.dilationWidth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,b=w-1-u.padInfo.left,S=v-1-u.padInfo.top,C=zt(o.shape,"float32"),E=1/(f*m),k=t.data.get(i.dataId).values,I=zt(i.shape,"float32",k);for(let A=0;A<u.batchSize;++A)for(let N=0;N<u.inChannels;++N)for(let L=0;L<u.inHeight;++L)for(let V=0;V<u.inWidth;++V){const O=L-S,P=V-b;let W=0;for(let H=0;H<v;H+=x){const Y=(O+H)/h;if(!(Y<0||Y>=u.outHeight||Math.floor(Y)!==Y))for(let D=0;D<w;D+=y){const $=(P+D)/d;if($<0||$>=u.outWidth||Math.floor($)!==$)continue;const U=I.get(A,Y,$,N);W+=U}}C.set(W*E,A,L,V,N)}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const tse={kernelName:vE,backendName:"cpu",kernelFunc:ese};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,scale:r,offset:o,mean:a,variance:l}=e;F(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(r==null||a.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),lt([i,a,l,r,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const u=t.data.get(i.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(l.dataId).values,f=r?t.data.get(r.dataId).values:new Float32Array([1]),m=o?t.data.get(o.dataId).values:new Float32Array([0]),x=new Float32Array(u.length),y=m.length,v=f.length,w=d.length,b=h.length;let S=0,C=0,E=0,k=0;for(let I=0;I<u.length;++I)x[I]=m[S++]+(u[I]-h[C++])*f[E++]/Math.sqrt(d[k++]+c),S>=y&&(S=0),C>=b&&(C=0),E>=v&&(E=0),k>=w&&(k=0);return t.makeTensorInfo(i.shape,i.dtype,x)}const sse={kernelName:Cw,backendName:"cpu",kernelFunc:nse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ise(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;lt([i],"batchToSpaceND");const a=r.reduce((v,w)=>v*w),l=p0(i.shape,r,a),c=m0(l.length,r.length),u=g0(i.shape,r,a),h=XM(o,r.length),d=jM(u,o,r.length),f=Tn({inputs:{x:i},backend:t,attrs:{shape:l}}),m=Vi({inputs:{x:f},backend:t,attrs:{perm:c}}),x=Tn({inputs:{x:m},backend:t,attrs:{shape:u}}),y=dh({inputs:{x},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),y}const rse={kernelName:fw,backendName:"cpu",kernelFunc:ise};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ose(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=Rk(a,l,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,c)}const ase={kernelName:bE,backendName:"cpu",kernelFunc:ose};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lse(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,a=Mt(Array.from(r),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const cse={kernelName:fO,backendName:"cpu",kernelFunc:lse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use=gn(_g,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),hse={kernelName:_g,backendName:"cpu",kernelFunc:use};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(Se(e.shape)),i=t.data.get(e.dataId),r=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],h=l[c];s[c]=Math.hypot(u,h)}return t.makeOutput(s,e.shape,"float32")},fse={kernelName:pw,backendName:"cpu",kernelFunc:dse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pf(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.imag,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const pse={kernelName:FE,backendName:"cpu",kernelFunc:pf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mf(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Ut(i,e[0].shape)[0],o=e.map(x=>x.shape);WM(o,r);let a=Ca(e.map(x=>x.shape),r);if(Se(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(x=>Se(x.shape)>0);if(l.length===1)return Aa({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const x=l.map(S=>hh({inputs:{input:S},backend:t})),y=l.map(S=>pf({inputs:{input:S},backend:t})),v=mf({inputs:x,backend:t,attrs:{axis:r}}),w=mf({inputs:y,backend:t,attrs:{axis:r}}),b=nr({inputs:{real:v,imag:w},backend:t});return x.forEach(S=>t.disposeIntermediateTensorInfo(S)),y.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(w),b}const c=l.map(x=>{const v=[-1,Se(x.shape.slice(r))];return Tn({inputs:{x},backend:t,attrs:{shape:v}})}),u=c.map(x=>({vals:t.data.get(x.dataId).values,shape:x.shape}));a=Ca(c.map(x=>x.shape),1);const h=c[0].shape[0]===1,d=HU(u,a,e[0].dtype,h),f=Ca(l.map(x=>x.shape),r),m=t.makeTensorInfo(f,e[0].dtype,d);return c.forEach(x=>t.disposeIntermediateTensorInfo(x)),m}const mse={kernelName:mw,backendName:"cpu",kernelFunc:mf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s;lt([i,r],"conv2d");const h=bl(l),d=Ys(i.shape,r.shape,o,c,a,u,!1,h),f=d.filterHeight,m=d.filterWidth,x=d.dilationHeight,y=d.dilationWidth,v=d.padInfo.left,w=d.padInfo.top,b=d.dataFormat==="channelsLast",S=new ii(d.outShape,i.dtype),C=mt(i.shape),E=mt(r.shape),k=C[0],I=b?C[1]:C[2],A=b?C[2]:1,N=b?1:C[1],L=S.strides[0],V=b?S.strides[1]:S.strides[2],O=b?S.strides[2]:1,P=b?1:S.strides[1],W=t.data.get(i.dataId).values,H=t.data.get(r.dataId).values,Y=S.values;for(let D=0;D<d.batchSize;++D){const $=D*k,U=D*L;for(let B=0;B<d.outHeight;++B){const X=U+B*V,te=B*d.strideHeight-w;for(let oe=0;oe<f;++oe){const ue=te+oe*x;if(ue<0||ue>=d.inHeight)continue;const Q=oe*E[0],ke=$+ue*I;for(let Me=0;Me<d.outWidth;++Me){const De=X+Me*O,Ee=Me*d.strideWidth-v;for(let Be=0;Be<m;++Be){const ye=Ee+Be*y;if(ye<0||ye>=d.inWidth)continue;const fe=Q+Be*E[1],Re=ke+ye*A;let We=fe;for(let Le=0;Le<d.inChannels;++Le){const nt=W[Re+Le*N];for(let Ke=0;Ke<d.outChannels;++Ke)Y[De+Ke*P]+=nt*H[We+Ke];We+=d.outChannels}}}}}}return t.makeTensorInfo(S.shape,S.dtype,Y)}const gse={kernelName:gw,backendName:"cpu",kernelFunc:zV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s;lt([i,r],"conv2dBackpropFilter");const h=bl(l),d=Ys(i.shape,u,o,1,a,c,!1,h),{strideHeight:f,strideWidth:m,filterHeight:x,filterWidth:y}=d,v=d.dataFormat==="channelsLast",w=new ii(d.filterShape,"float32"),b=d.padInfo.left,S=d.padInfo.top,C=t.data.get(i.dataId).values,E=t.data.get(r.dataId).values,k=new ii(i.shape,i.dtype,C),I=new ii(r.shape,r.dtype,E);for(let A=0;A<x;++A){const N=Math.max(0,Math.ceil((S-A)/f)),L=Math.min(d.outHeight,(d.inHeight+S-A)/f);for(let V=0;V<y;++V){const O=Math.max(0,Math.ceil((b-V)/m)),P=Math.min(d.outWidth,(d.inWidth+b-V)/m);for(let W=0;W<d.inChannels;++W)for(let H=0;H<d.outChannels;++H){let Y=0;for(let D=0;D<d.batchSize;++D)for(let $=N;$<L;++$){const U=A+$*f-S;for(let B=O;B<P;++B){const X=V+B*m-b;v?Y+=k.get(D,U,X,W)*I.get(D,$,B,H):Y+=k.get(D,W,U,X)*I.get(D,H,$,B)}}w.set(Y,A,V,W,H)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const yse={kernelName:_E,backendName:"cpu",kernelFunc:xse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vse(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s;lt([i,r],"conv2dBackpropInput");const h=mt(r.shape),d=mt(i.shape);let f=bl(c);const m=Ys(o,r.shape,a,1,l,u,!1,f),x=new ii(m.inShape,"float32"),y=x.values,v=t.data.get(i.dataId).values,w=t.data.get(r.dataId).values,[b,S,C]=h,{batchSize:E,filterHeight:k,filterWidth:I,inChannels:A,inHeight:N,inWidth:L,outChannels:V,outHeight:O,outWidth:P,strideHeight:W,strideWidth:H}=m;f=m.dataFormat;const Y=k-1-m.padInfo.top,D=I-1-m.padInfo.left,$=f==="channelsLast",U=x.strides[0],B=$?x.strides[1]:x.strides[2],X=$?x.strides[2]:1,te=$?1:x.strides[1],oe=d[0],ue=$?d[1]:d[2],Q=$?d[2]:1,ke=$?1:d[1];for(let Me=0;Me<E;++Me)for(let De=0;De<A;++De)for(let Ee=0;Ee<N;++Ee){const Be=Ee-Y,ye=Math.max(0,Math.ceil(Be/W)),fe=Math.min(O,(k+Be)/W);for(let Re=0;Re<L;++Re){const We=Re-D,Le=Math.max(0,Math.ceil(We/H)),nt=Math.min(P,(I+We)/H);let Ke=0;for(let vt=ye;vt<fe;++vt){const Dt=vt*W-Be;for(let q=Le;q<nt;++q){const z=q*H-We,ge=oe*Me+ue*vt+Q*q,Pe=b*(k-1-Dt)+S*(I-1-z)+C*De;for(let ze=0;ze<V;++ze){const Xe=v[ge+ke*ze],ft=w[Pe+ze];Ke+=Xe*ft}}}const ot=U*Me+B*Ee+X*Re+te*De;y[ot]=Ke}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const wse={kernelName:xw,backendName:"cpu",kernelFunc:vse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s;lt([i,r],"conv3d");const c=$c(i.shape,r.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:f,dilationHeight:m,dilationWidth:x,padInfo:y}=c,v=y.front,w=y.left,b=y.top,S=new ii(c.outShape,i.dtype),C=t.data.get(i.dataId).values,E=t.data.get(r.dataId).values,k=S.values,I=mt(i.shape),A=mt(r.shape);for(let N=0;N<c.batchSize;++N){const L=N*I[0],V=N*S.strides[0];for(let O=0;O<c.outDepth;++O){const P=V+O*S.strides[1],W=O*c.strideDepth-v;for(let H=0;H<u;++H){const Y=W+H*f;if(Y<0||Y>=c.inDepth)continue;const D=H*A[0],$=L+Y*I[1];for(let U=0;U<c.outHeight;++U){const B=P+U*S.strides[2],X=U*c.strideHeight-b;for(let te=0;te<h;++te){const oe=X+te*m;if(oe<0||oe>=c.inHeight)continue;const ue=D+te*A[1],Q=$+oe*I[2];for(let ke=0;ke<c.outWidth;++ke){const Me=B+ke*c.outChannels,De=ke*c.strideWidth-w;for(let Ee=0;Ee<d;++Ee){const Be=De+Ee*x;if(Be<0||Be>=c.inWidth)continue;const ye=ue+Ee*A[2],fe=Q+Be*c.inChannels;let Re=ye;for(let We=0;We<c.inChannels;++We){const Le=C[fe+We];for(let nt=0;nt<c.outChannels;++nt)k[Me+nt]+=Le*E[Re+nt];Re+=c.outChannels}}}}}}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const Sse={kernelName:yw,backendName:"cpu",kernelFunc:bse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _se(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s;lt([i,r],"conv3dBackpropFilterV2");const c=mt(i.shape),u=mt(r.shape),h=$c(i.shape,l,o,1,a),d=h.strideDepth,f=h.strideHeight,m=h.strideWidth,x=h.filterDepth,y=h.filterHeight,v=h.filterWidth,w=new ii(h.filterShape,"float32"),b=w.values,[S,C,E,k]=w.strides,I=t.data.get(r.dataId).values,[A,N,L,V]=u,O=t.data.get(i.dataId).values,[P,W,H,Y]=c,D=h.padInfo.front,$=h.padInfo.left,U=h.padInfo.top;for(let B=0;B<x;++B){const X=Math.max(0,Math.ceil((D-B)/d)),te=Math.min(h.outDepth,(h.inDepth+D-B)/d),oe=B*S;for(let ue=0;ue<y;++ue){const Q=Math.max(0,Math.ceil((U-ue)/f)),ke=Math.min(h.outHeight,(h.inHeight+U-ue)/f),Me=ue*C+oe;for(let De=0;De<v;++De){const Ee=Math.max(0,Math.ceil(($-De)/m)),Be=Math.min(h.outWidth,(h.inWidth+$-De)/m),ye=De*E+Me;for(let fe=0;fe<h.inChannels;++fe){const Re=fe*k+ye;for(let We=0;We<h.outChannels;++We){let Le=0;for(let nt=0;nt<h.batchSize;++nt){const Ke=nt*P,ot=nt*A;for(let vt=X;vt<te;++vt){const q=(B+vt*d-D)*W+Ke,z=vt*N+ot;for(let ge=Q;ge<ke;++ge){const ze=(ue+ge*f-U)*H+q,Xe=ge*L+z;for(let ft=Ee;ft<Be;++ft){const Te=(De+ft*m-$)*Y+ze,ht=ft*V+Xe;Le+=O[Te+fe]*I[ht+We]}}}}b[Re+We]=Le}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const Cse={kernelName:CE,backendName:"cpu",kernelFunc:_se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tse(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:o,strides:a,inputShape:l}=s;lt([i],"conv3dBackpropInputV2");const c=mt(i.shape),u=mt(r.shape),h=$c(l,r.shape,a,1,o),d=new ii(h.inShape,"float32"),f=d.values,[m,x,y,v]=d.strides,w=t.data.get(i.dataId).values,[b,S,C,E]=c,k=t.data.get(r.dataId).values,[I,A,N,L]=u,{batchSize:V,filterDepth:O,filterHeight:P,filterWidth:W,inChannels:H,inDepth:Y,inHeight:D,inWidth:$,outChannels:U,outDepth:B,outHeight:X,outWidth:te,strideDepth:oe,strideHeight:ue,strideWidth:Q}=h,ke=O-1-h.padInfo.front,Me=P-1-h.padInfo.top,De=W-1-h.padInfo.left;for(let Ee=0;Ee<V;++Ee)for(let Be=0;Be<H;++Be)for(let ye=0;ye<Y;++ye){const fe=ye-ke,Re=Math.max(0,Math.ceil(fe/oe)),We=Math.min(B,(O+fe)/oe);for(let Le=0;Le<D;++Le){const nt=Le-Me,Ke=Math.max(0,Math.ceil(nt/ue)),ot=Math.min(X,(P+nt)/ue);for(let vt=0;vt<$;++vt){const Dt=vt-De,q=Math.max(0,Math.ceil(Dt/Q)),z=Math.min(te,(W+Dt)/Q);let ge=0;for(let Pe=Re;Pe<We;++Pe){const ze=Pe*oe-fe;for(let Xe=Ke;Xe<ot;++Xe){const ft=Xe*ue-nt;for(let Ye=q;Ye<z;++Ye){const Te=Ye*Q-Dt,ht=b*Ee+S*Pe+C*Xe+E*Ye,J=I*(O-1-ze)+A*(P-1-ft)+N*(W-1-Te)+L*Be;for(let ve=0;ve<U;++ve){const Oe=w[ht+ve],Ge=k[J+ve];ge+=Oe*Ge}}}}f[m*Ee+x*ye+y*Le+v*vt+Be]=ge}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const Ise={kernelName:TE,backendName:"cpu",kernelFunc:Tse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ese=gn(Cg,n=>Math.cos(n)),Mse={kernelName:Cg,backendName:"cpu",kernelFunc:Ese};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kse=gn(Tg,n=>Math.cosh(n)),Ase={kernelName:Tg,backendName:"cpu",kernelFunc:kse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nse(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,[u,h,d,f]=i.shape,m=r.shape[0],[x,y]=a,v=zt([m,x,y,f],"float32"),w=t.data.get(r.dataId).values,b=t.data.get(o.dataId).values,S=t.data.get(i.dataId).values,C=mt(i.shape),E=mt(v.shape);for(let k=0;k<m;k++){const I=k*4,A=w[I],N=w[I+1],L=w[I+2],V=w[I+3],O=b[k];if(O>=u)continue;const P=x>1?(L-A)*(h-1)/(x-1):0,W=y>1?(V-N)*(d-1)/(y-1):0;for(let H=0;H<x;H++){const Y=x>1?A*(h-1)+H*P:.5*(A+L)*(h-1);if(Y<0||Y>h-1){for(let D=0;D<y;D++)for(let $=0;$<f;$++){const U=$+D*E[2]+H*E[1]+k*E[0];v.values[U]=c}continue}if(l==="bilinear"){const D=Math.floor(Y),$=Math.ceil(Y),U=Y-D;for(let B=0;B<y;B++){const X=y>1?N*(d-1)+B*W:.5*(N+V)*(d-1);if(X<0||X>d-1){for(let Q=0;Q<f;Q++){const ke=Q+B*E[2]+H*E[1]+k*E[0];v.values[ke]=c}continue}const te=Math.floor(X),oe=Math.ceil(X),ue=X-te;for(let Q=0;Q<f;Q++){let ke=Q+te*C[2]+D*C[1]+O*C[0];const Me=S[ke];ke=Q+oe*C[2]+D*C[1]+O*C[0];const De=S[ke];ke=Q+te*C[2]+$*C[1]+O*C[0];const Ee=S[ke];ke=Q+oe*C[2]+$*C[1]+O*C[0];const Be=S[ke],ye=Me+(De-Me)*ue,fe=Ee+(Be-Ee)*ue;ke=Q+B*E[2]+H*E[1]+k*E[0],v.values[ke]=ye+(fe-ye)*U}}}else for(let D=0;D<y;++D){const $=y>1?N*(d-1)+D*W:.5*(N+V)*(d-1);if($<0||$>d-1){for(let X=0;X<f;X++){const te=X+D*E[2]+H*E[1]+k*E[0];v.values[te]=c}continue}const U=Math.round($),B=Math.round(Y);for(let X=0;X<f;X++){const te=X+U*C[2]+B*C[1]+O*C[0],oe=X+D*E[2]+H*E[1]+k*E[0];v.values[oe]=S[te]}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const Rse={kernelName:EE,backendName:"cpu",kernelFunc:Nse};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;lt(i,"cumprod");const l=Wn([r],i.shape.length);let c=i;l!=null&&(c=Vi({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=is(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=lr(c.dtype,"int32"),d=fE(Se(c.shape),h),f=t.data.get(c.dataId).values,m=c.shape[c.shape.length-1],x=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const b=x(v,w);if(w===0)d[b]=o?1:f[b];else{const S=x(v,w-1);d[b]=o?f[S]*d[S]:f[b]*d[S]}}const y=t.makeTensorInfo(c.shape,h,d);if(l!=null){const v=Fc(l),w=Vi({inputs:{x:y},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(c),w}return y}const Lse={kernelName:IE,backendName:"cpu",kernelFunc:Dse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;lt(i,"cumsum");const l=Wn([r],i.shape.length);let c=i;l!=null&&(c=Vi({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=is(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=lr(c.dtype,"int32"),d=oi(Se(c.shape),h),f=t.data.get(c.dataId).values,m=c.shape[c.shape.length-1],x=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const b=x(v,w);if(w===0)d[b]=o?0:f[b];else{const S=x(v,w-1);d[b]=o?f[S]+d[S]:f[b]+d[S]}}const y=t.makeTensorInfo(c.shape,h,d);if(l!=null){const v=Fc(l),w=Vi({inputs:{x:y},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(c),w}return y}const $se={kernelName:vw,backendName:"cpu",kernelFunc:Pse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s;if(i.shape.length===1){const l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=Rk(l,c,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=WU(l,c,o,a);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const Ose={kernelName:ME,backendName:"cpu",kernelFunc:Fse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s;F(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=i.shape[0],l=i.shape[1],c=i.shape[2],u=i.shape[3],h=l*r,d=c*r,f=u/(r*r),m=t.data.get(i.dataId).values,x=new Float32Array(a*h*d*f);let y=0;for(let v=0;v<a;++v)for(let w=0;w<h;++w){const b=Math.floor(w/r),S=w%r;for(let C=0;C<d;++C){const E=Math.floor(C/r),k=C%r,I=(S*r+k)*f;for(let A=0;A<f;++A){const L=A+I+u*(E+c*(b+l*v));x[y++]=m[L]}}}return t.makeTensorInfo([a,h,d,f],i.dtype,x)}const Bse={kernelName:kE,backendName:"cpu",kernelFunc:zse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;lt([i,r],"depthwiseConv2DNative");const u=mt(i.shape),h=mt(r.shape);let d=l;d==null&&(d=[1,1]),F(ai(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const f=Ys(i.shape,r.shape,o,d,a,c,!0),{filterHeight:m,filterWidth:x,dilationHeight:y,dilationWidth:v,padInfo:w}=f,b=w.left,S=w.top,C=f.outChannels/f.inChannels,E=new ii(f.outShape,i.dtype),k=t.data.get(i.dataId).values,I=t.data.get(r.dataId).values,A=E.values;for(let N=0;N<f.batchSize;++N){const L=N*u[0],V=N*E.strides[0];for(let O=0;O<f.outHeight;++O){const P=V+O*E.strides[1],W=O*f.strideHeight-S;for(let H=0;H<m;++H){const Y=W+H*y;if(Y<0||Y>=f.inHeight)continue;const D=H*h[0],$=L+Y*u[1];for(let U=0;U<f.outWidth;++U){const B=P+U*E.strides[2],X=U*f.strideWidth-b;for(let te=0;te<x;++te){const oe=X+te*v;if(oe<0||oe>=f.inWidth)continue;const ue=D+te*h[1],Q=$+oe*f.inChannels;let ke=B,Me=ue;for(let De=0;De<f.inChannels;++De){const Ee=k[Q+De];for(let Be=0;Be<C;++Be)A[ke+Be]+=Ee*I[Me+Be];ke+=C,Me+=C}}}}}}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Use={kernelName:ww,backendName:"cpu",kernelFunc:BV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s;lt([i,r],"depthwiseConv2dNativeBackpropFilter");const h=Ys(i.shape,u,o,a,l,c,!0),{strideHeight:d,strideWidth:f,filterHeight:m,filterWidth:x}=h,y=new ii(h.filterShape,"float32"),v=h.padInfo.left,w=h.padInfo.top,b=h.outChannels/h.inChannels,S=t.data.get(i.dataId).values,C=new ii(i.shape,i.dtype,S),E=t.data.get(r.dataId).values,k=new ii(r.shape,r.dtype,E);for(let I=0;I<m;++I){const A=Math.max(0,Math.ceil((w-I)/d)),N=Math.min(h.outHeight,(h.inHeight+w-I)/d);for(let L=0;L<x;++L){const V=Math.max(0,Math.ceil((v-L)/f)),O=Math.min(h.outWidth,(h.inWidth+v-L)/f);for(let P=0;P<h.outChannels;++P){const W=Math.trunc(P/b),H=P%b;let Y=0;for(let D=0;D<h.batchSize;++D)for(let $=A;$<N;++$){const U=I+$*d-w;for(let B=V;B<O;++B){const X=L+B*f-v;Y+=C.get(D,U,X,W)*k.get(D,$,B,P)}}y.set(Y,I,L,W,H)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const Wse={kernelName:AE,backendName:"cpu",kernelFunc:Vse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gse(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s;lt([i,r],"depthwiseConv2DNativeBackpropInput");const h=mt(i.shape),d=mt(r.shape),f=Ys(u,r.shape,o,a,l,c,!0),m=new ii(f.inShape,"float32"),x=m.values,[y,v,w]=m.strides,b=t.data.get(i.dataId).values,[S,C,E]=h,k=t.data.get(r.dataId).values,[I,A,N]=d,{batchSize:L,filterHeight:V,filterWidth:O,inChannels:P,inHeight:W,inWidth:H,outChannels:Y,outHeight:D,outWidth:$,strideHeight:U,strideWidth:B}=f,X=V-1-f.padInfo.top,te=O-1-f.padInfo.left,oe=Y/P;for(let ue=0;ue<L;++ue)for(let Q=0;Q<P;++Q)for(let ke=0;ke<W;++ke){const Me=ke-X,De=Math.max(0,Math.ceil(Me/U)),Ee=Math.min(D,(V+Me)/U);for(let Be=0;Be<H;++Be){const ye=Be-te,fe=Math.max(0,Math.ceil(ye/B)),Re=Math.min($,(O+ye)/B);let We=0;for(let Le=De;Le<Ee;++Le){const nt=Le*U-Me;for(let Ke=fe;Ke<Re;++Ke){const ot=Ke*B-ye,vt=S*ue+C*Le+E*Ke,Dt=I*(V-1-nt)+A*(O-1-ot)+N*Q;for(let q=0;q<oe;++q){const z=Q*oe+q,ge=b[vt+z],Pe=k[Dt+q];We+=ge*Pe}}}x[y*ue+v*ke+w*Be+Q]=We}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const Hse={kernelName:NE,backendName:"cpu",kernelFunc:Gse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xse(n){const{inputs:e,backend:t}=n,{x:s}=e,i=Se(s.shape),r=t.data.get(s.dataId).values,o=zt([i,i],s.dtype),a=o.values;for(let c=0;c<r.length;c++)a[c*i+c]=r[c];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const jse={kernelName:pO,backendName:"cpu",kernelFunc:Xse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qse={kernelName:bw,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i}=n,{strides:r,pad:o,dilations:a}=t,l=e,c=l.data.get(s.dataId).values,u=s.shape.length,h=l.data.get(i.dataId).values,d=i.shape.length,{batchSize:f,inHeight:m,inWidth:x,inChannels:y,outHeight:v,outWidth:w,padInfo:b,strideHeight:S,strideWidth:C,filterHeight:E,filterWidth:k,dilationHeight:I,dilationWidth:A,outShape:N}=c0(s.shape,i.shape,r,o,"NHWC",a),L=Se(N),V=N.length,O=fs(s.dtype,L);for(let W=0;W<f;++W)for(let H=0;H<v;++H){const Y=H*S-b.top;for(let D=0;D<w;++D){const $=D*C-b.left;for(let U=0;U<y;++U){let B=Number.MIN_SAFE_INTEGER;for(let te=0;te<E;++te){const oe=Y+te*I;if(oe>=0&&oe<m)for(let ue=0;ue<k;++ue){const Q=$+ue*A;if(Q>=0&&Q<x){const ke=Sa([W,oe,Q,U],u,mt(s.shape)),Me=Sa([te,ue,U],d,mt(i.shape)),De=c[ke]+h[Me];De>B&&(B=De)}}}const X=Sa([W,H,D,U],V,mt(N));O[X]=B}}}return{dataId:l.write(bh(O,s.dtype),N,s.dtype),shape:N,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kse={kernelName:G2,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Oo(s.shape,c.data.get(s.dataId).values),h=Oo(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:x,outHeight:y,outWidth:v,padInfo:w,strideHeight:b,strideWidth:S,filterHeight:C,filterWidth:E,dilationHeight:k,dilationWidth:I,outShape:A}=c0(s.shape,i.shape,o,a,"NHWC",l);F(r.rank===A.length,()=>`Error in ${G2}, dy must have the same rank as output ${A.length}, but got ${r.rank}`);const N=Oo(A,c.data.get(r.dataId).values),L=uO(i.shape,i.dtype);for(let O=0;O<d;++O)for(let P=0;P<y;++P){const W=P*b-w.top;for(let H=0;H<v;++H){const Y=H*S-w.left;for(let D=0;D<x;++D){let $=Number.MIN_SAFE_INTEGER,U=0,B=0;for(let X=0;X<C;++X){const te=W+X*k;if(te>=0&&te<f)for(let oe=0;oe<E;++oe){const ue=Y+oe*I;if(ue>=0&&ue<m){const Q=u[O][te][ue][D]+h[X][oe][D];Q>$&&($=Q,U=X,B=oe)}}}L[U][B][D]+=N[O][P][H][D]}}}return{dataId:c.write(bh(L,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yse={kernelName:W2,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Oo(s.shape,c.data.get(s.dataId).values),h=Oo(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:x,outHeight:y,outWidth:v,padInfo:w,strideHeight:b,strideWidth:S,filterHeight:C,filterWidth:E,dilationHeight:k,dilationWidth:I,outShape:A}=c0(s.shape,i.shape,o,a,"NHWC",l);F(r.rank===A.length,()=>`Error in ${W2}, dy must have the same rank as output ${A.length}, but got ${r.rank}`);const N=Oo(A,c.data.get(r.dataId).values),L=uO(s.shape,s.dtype);for(let O=0;O<d;++O)for(let P=0;P<y;++P){const W=P*b-w.top;for(let H=0;H<v;++H){const Y=H*S-w.left;for(let D=0;D<x;++D){let $=Number.MIN_SAFE_INTEGER,U=W<0?0:W,B=Y<0?0:Y;for(let X=0;X<C;++X){const te=W+X*k;if(te>=0&&te<f)for(let oe=0;oe<E;++oe){const ue=Y+oe*I;if(ue>=0&&ue<m){const Q=u[O][te][ue][D]+h[X][oe][D];Q>$&&($=Q,U=te,B=ue)}}}L[O][U][B][D]+=N[O][P][H][D]}}}return{dataId:c.write(bh(L,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;lt(i,"sum");let a;i.dtype==="bool"?a=Ic({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):a=Aa({inputs:{x:i},backend:t});const l=a.shape.length,c=Ut(r,a.shape),u=Wn(c,l);let h=c,d=a;u!=null&&(d=Vi({inputs:{x:a},backend:t,attrs:{perm:u}}),h=is(h.length,l)),Zs("sum",h,d.shape.length);const[f,m]=Fs(d.shape,h),x=lr(d.dtype,"int32");let y=M1(t,f,x);const v=Se(m),w=t.data.get(y.dataId).values,b=t.data.get(d.dataId).values;for(let S=0;S<w.length;++S){const C=S*v;let E=0;for(let k=0;k<v;++k)E+=b[C+k];w[S]=E}if(o){const S=ms(y.shape,c),C=y;y=Tn({inputs:{x:y},backend:t,attrs:{shape:S}}),t.disposeIntermediateTensorInfo(C)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(d),y}const Zse={kernelName:eb,backendName:"cpu",kernelFunc:T0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jse(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=tk(i,r.length);sk(o.length,l,r);const{path:c,steps:u}=ik(a,l),h=u.length;let d=null,f=o.length;const m=[];for(let x=0;x<h;++x){for(const y of u[x]){const{permutationIndices:v,expandDims:w}=nk(f,l[y]);let b;rk(v)?b=r[y]:(b=Vi({inputs:{x:r[y]},backend:t,attrs:{perm:v}}),m.push(b));const S=b.shape.slice();for(let C=0;C<w.length;++C)S.splice(w[C],0,1);pn(b.shape,S)||(b=Tn({inputs:{x:b},backend:t,attrs:{shape:S}}),m.push(b)),d===null?d=b:(d=Rb({inputs:{a:b,b:d},backend:t}),m.push(d))}x<h-1&&(c[x]>=0&&(d=T0({inputs:{x:d},backend:t,attrs:{axis:c[x]-(o.length-f),keepDims:!1}}),m.push(d)),f--)}for(const x of m)x!==d&&t.disposeIntermediateTensorInfo(x);return d}const Qse={kernelName:mO,backendName:"cpu",kernelFunc:Jse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eie(n){const{inputs:e,backend:t}=n,{dy:s,y:i}=e;lt([s,i],"eluGrad");const r=new Float32Array(Se(i.shape)),o=t.data.get(i.dataId).values,a=t.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=1?r[l]=a[l]:r[l]=a[l]*(c+1)}return t.makeTensorInfo(i.shape,"float32",r)}const tie={kernelName:RE,backendName:"cpu",kernelFunc:eie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nie=qM,sie=KM,iie=YM,rie=ZM,oie=JM,aie=QM,lie=gn(Mg,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+nie*t);return e*(1-((((aie*s+oie)*s+rie)*s+iie)*s+sie)*s*Math.exp(-t*t))}),cie={kernelName:Mg,backendName:"cpu",kernelFunc:lie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1(n){const{inputs:e,backend:t,attrs:s}=n,{input:i}=e,{dim:r}=s,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(F(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Tn({inputs:{x:i},backend:t,attrs:{shape:a}})}const uie={kernelName:_w,backendName:"cpu",kernelFunc:N1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hie=gs((n,e)=>n/e),Ok=Os(Ig,hie),vT={kernelName:Ig,backendName:"cpu",kernelFunc:Ok};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UV(n,e,t){const s=n.shape,i=s[0],r=s[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[i,r],u=Se(c),h=Ks("float32",u),d=Ks("float32",u);for(let y=0;y<i;y++){const v=dh({inputs:{x:a},backend:t,attrs:{begin:[y,0],size:[1,r]}}),w=dh({inputs:{x:l},backend:t,attrs:{begin:[y,0],size:[1,r]}}),b=nr({inputs:{real:v,imag:w},backend:t}),{real:S,imag:C}=die(b,e,t),E=ml(S,C);for(let k=0;k<r;k++){const I=ek(E,k);h[y*r+k]=I.real,d[y*r+k]=I.imag}t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(b)}const f=t.makeTensorInfo(c,"float32",h),m=t.makeTensorInfo(c,"float32",d),x=nr({inputs:{real:f,imag:m},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),x}function die(n,e,t){const s=Se(n.shape),i=t.data.get(n.dataId),r=t.data.get(i.complexTensorInfos.real.dataId).values,o=t.data.get(i.complexTensorInfos.imag.dataId).values;if(fie(s)){const a=wT(r,o,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),u=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Pc(s,"float32")),d=Aa({inputs:{x:h},backend:t}),f=vT.kernelFunc({inputs:{a:c,b:h},backend:t}),m=vT.kernelFunc({inputs:{a:u,b:d},backend:t}),x=t.data.get(f.dataId).values,y=t.data.get(m.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),{real:x,imag:y}}return a}else{const a=ml(r,o),l=pie(a,s,e);return c4(l)}}function fie(n){return(n&n-1)===0}function wT(n,e,t,s,i){if(t===1)return{real:n,imag:e};const r=ml(n,e),o=t/2,a=u4(r),l=a.real,c=a.imag,u=[l.length],h=i.makeTensorInfo(u,"float32",l),d=i.makeTensorInfo(u,"float32",c),f=nr({inputs:{real:h,imag:d},backend:i}),m=h4(r),x=m.real,y=m.imag,v=[x.length],w=i.makeTensorInfo(v,"float32",x),b=i.makeTensorInfo(v,"float32",y),S=nr({inputs:{real:w,imag:b},backend:i}),C=wT(l,c,o,s,i),E=C.real,k=C.imag,I=[E.length],A=i.makeTensorInfo(I,"float32",E),N=i.makeTensorInfo(I,"float32",k),L=nr({inputs:{real:A,imag:N},backend:i}),V=wT(x,y,o,s,i),O=V.real,P=V.imag,W=[O.length],H=i.makeTensorInfo(W,"float32",O),Y=i.makeTensorInfo(W,"float32",P),D=nr({inputs:{real:H,imag:Y},backend:i}),$=f4(t,s),U=[$.real.length],B=i.makeTensorInfo(U,"float32",$.real),X=i.makeTensorInfo(U,"float32",$.imag),te=nr({inputs:{real:B,imag:X},backend:i}),oe=Rb({inputs:{a:te,b:D},backend:i}),ue=ff({inputs:{a:L,b:oe},backend:i}),Q=$k({inputs:{a:L,b:oe},backend:i}),ke=hh({inputs:{input:ue},backend:i}),Me=hh({inputs:{input:Q},backend:i}),De=pf({inputs:{input:ue},backend:i}),Ee=pf({inputs:{input:Q},backend:i}),Be=mf({inputs:[ke,Me],backend:i,attrs:{axis:0}}),ye=mf({inputs:[De,Ee],backend:i,attrs:{axis:0}}),fe=i.data.get(Be.dataId).values,Re=i.data.get(ye.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(N),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(Y),i.disposeIntermediateTensorInfo(D),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(X),i.disposeIntermediateTensorInfo(te),i.disposeIntermediateTensorInfo(oe),i.disposeIntermediateTensorInfo(ue),i.disposeIntermediateTensorInfo(Q),i.disposeIntermediateTensorInfo(ke),i.disposeIntermediateTensorInfo(De),i.disposeIntermediateTensorInfo(Me),i.disposeIntermediateTensorInfo(Ee),i.disposeIntermediateTensorInfo(Be),i.disposeIntermediateTensorInfo(ye),{real:fe,imag:Re}}function pie(n,e,t){const s=new Float32Array(e*2);for(let i=0;i<e;i++){let r=0,o=0;for(let a=0;a<e;a++){const l=p4(i*a,e,t),c=ek(n,a);r+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(r/=e,o/=e),d4(s,r,o,i)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mie(n){const{inputs:e,backend:t}=n,{input:s}=e,i=Se(s.shape),r=s.shape[s.shape.length-1],o=i/r,a=Tn({inputs:{x:s},backend:t,attrs:{shape:[o,r]}}),l=UV(a,!1,t),c=Tn({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const gie={kernelName:DE,backendName:"cpu",kernelFunc:mie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zk(n){const{backend:e,attrs:t}=n,{shape:s,value:i,dtype:r}=t,o=r||fg(i),a=fs(o,Se(s));return yie(a,i,o),e.makeTensorInfo(s,o,a)}const xie={kernelName:LE,backendName:"cpu",kernelFunc:zk};function yie(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vie={kernelName:PE,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,i=t,r=Ks(s.dtype,Se(s.shape)),[o,a,l,c]=s.shape,u=i.data.get(s.dataId).values;for(let d=0;d<o;d++){const f=d*l*a*c;for(let m=0;m<a;m++){const x=m*(l*c);for(let y=0;y<l;y++){const v=y*c;for(let w=0;w<c;w++){const b=Math.round(l-y-1),S=f+x+v+w;let C=u[S];if(b>=0&&b<l){const E=b*c,k=f+x+E+w;C=u[k]}r[S]=C}}}}return{dataId:i.write(r,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wie=gs((n,e)=>Math.floor(n/e)),bie=Os(Rg,wie,null,"int32"),Sie={kernelName:Rg,backendName:"cpu",kernelFunc:bie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ie(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=s;let x=zV({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const y=x;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const v=Tn({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});x=ff({inputs:{a:x,b:v},backend:t}),t.disposeIntermediateTensorInfo(v)}else x=ff({inputs:{a:x,b:o},backend:t});t.disposeIntermediateTensorInfo(y)}if(f){const y=x;if(u==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const v=Tn({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});x=A1(t,x,f,v,m),t.disposeIntermediateTensorInfo(v)}else x=A1(t,x,f,a,m);t.disposeIntermediateTensorInfo(y)}return x}const Cie={kernelName:h1,backendName:"cpu",kernelFunc:_ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tie(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=s;let x=BV({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const y=x;x=ff({inputs:{a:x,b:o},backend:t}),t.disposeIntermediateTensorInfo(y)}if(f){const y=x;x=A1(t,x,f,a,m),t.disposeIntermediateTensorInfo(y)}return x}const Iie={kernelName:DO,backendName:"cpu",kernelFunc:Tie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eie(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=Se(s.shape),o=i.shape,a=o[o.length-1],[l,c,u,h]=FM(s,i);if(c===0)return t.makeTensorInfo(l,s.dtype,[]);const d=t.data.get(i.dataId).values,f=t.bufferSync(s),m=JU(d,f,s.dtype,c,a,u,h,s.shape,r);return t.makeTensorInfo(l,s.dtype,m.values)}const Mie={kernelName:gO,backendName:"cpu",kernelFunc:Eie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kie(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s;lt([i,r],"gatherV2");const l=Ut(o,i.shape)[0],c=t.data.get(r.dataId).values,u=i.shape[l];for(let S=0;S<c.length;++S){const C=c[S];F(C<=u-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${u-1}]`)}let h=a;a==null&&(h=0);const d=Se(r.shape),f=ak(i,r,l,h),m=Tn({inputs:{x:i},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),x=Tn({inputs:{x:r},backend:t,attrs:{shape:[f.batchSize,d/f.batchSize]}}),y=[f.batchSize,f.outerSize,d/f.batchSize,f.sliceSize],v=t.bufferSync(x),w=t.bufferSync(m),b=QU(w,v,y);return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),t.makeTensorInfo(f.outputShape,b.dtype,b.values)}const Aie={kernelName:Tw,backendName:"cpu",kernelFunc:kie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(n){const{inputs:e,backend:t}=n,{input:s}=e,i=Se(s.shape),r=s.shape[s.shape.length-1],o=i/r,a=Tn({inputs:{x:s},backend:t,attrs:{shape:[o,r]}}),l=UV(a,!0,t),c=Tn({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const Rie={kernelName:$E,backendName:"cpu",kernelFunc:Nie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Die=gn(Pg,n=>Number.isFinite(n)?1:0,"bool"),Lie={kernelName:Pg,backendName:"cpu",kernelFunc:Die};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pie=gn($g,n=>Math.abs(n)===1/0?1:0,"bool"),$ie={kernelName:$g,backendName:"cpu",kernelFunc:Pie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fie=gn(Fg,n=>Number.isNaN(n)?1:0,"bool"),Oie={kernelName:Fg,backendName:"cpu",kernelFunc:Fie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zie(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=iV(s,i,r);return e.makeTensorInfo([o.length],"float32",o)}const Bie={kernelName:xO,backendName:"cpu",kernelFunc:zie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uie=gn(zg,n=>Math.log1p(n)),Vie={kernelName:zg,backendName:"cpu",kernelFunc:Uie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wie=gs((n,e)=>n&&e),Gie=Os(Aw,Wie,null,"bool"),Hie={kernelName:Aw,backendName:"cpu",kernelFunc:Gie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xie=gn(Nw,n=>n?0:1,"bool"),jie={kernelName:Nw,backendName:"cpu",kernelFunc:Xie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qie=gs((n,e)=>n||e),Kie=Os(Rw,qie,null,"bool"),Yie={kernelName:Rw,backendName:"cpu",kernelFunc:Kie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zie(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s;lt(i,"LRN");const c=i.shape[3],u=c-1,h=t.data.get(i.dataId).values,d=Se(i.shape),f=new Float32Array(d);function m(x){const y=x%c;let v=x-y+Math.max(0,y-r);const w=x-y+Math.min(y+r,u);let b=0;for(;v<=w;v++){const S=h[v];b+=S*S}return b}for(let x=0;x<d;x++){const y=m(x),v=h[x]*Math.pow(o+a*y,-l);f[x]=v}return t.makeTensorInfo(i.shape,i.dtype,f)}const Jie={kernelName:Dw,backendName:"cpu",kernelFunc:Zie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qie(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s;lt(o,"LRNGrad");const h=Se(o.shape),d=o.shape[3],f=t.data.get(o.dataId).values,m=t.data.get(i.dataId).values,x=t.data.get(r.dataId).values,y=new Float32Array(h),v=h;for(let w=0;w<v;w++){const b=w%d,S=w-b+Math.max(0,b-a),C=w-b+Math.min(d,b+a+1);let E=0;for(let k=S;k<C;k++)E+=Math.pow(m[k],2);E=c*E+l;for(let k=S;k<C;k++){let I=-2*c*u*m[k]*x[w]/E;w===k&&(I+=Math.pow(E,-u)),I*=f[w],y[k]+=I}}return t.makeTensorInfo(o.shape,i.dtype,y)}const ere={kernelName:OE,backendName:"cpu",kernelFunc:Qie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s,a=t;let l=i.shape;const c=l.length,u=Ut(r,l);let h=u;const d=Wn(h,c);let f=a.data.get(i.dataId).values;if(d!=null){const S=new Array(c);for(let C=0;C<S.length;C++)S[C]=l[d[C]];f=Lk(f,l,i.dtype,d,S),h=is(h.length,c),l=S}lt(i,"max"),Zs("max",h,c);const[m,x]=Fs(l,h),y=Se(x),v=oV(f,y,m,i.dtype),w=a.write(v,m,i.dtype);let b=m;return o&&(b=ms(m,u)),{dataId:w,shape:b,dtype:i.dtype}}const tre={kernelName:Lw,backendName:"cpu",kernelFunc:VV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nre(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;lt(i,"maxPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;F(ai(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=go(i.shape,r,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&pn(u.inShape,u.outShape))h=Aa({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,f=mt(i.shape),m=Fk(d,i.shape,i.dtype,f,u,"max");h=t.makeTensorInfo(u.outShape,i.dtype,m.values)}return h}const sre={kernelName:Pw,backendName:"cpu",kernelFunc:nre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ire(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;lt(i,"maxPool3d");const u=wl(i.shape,r,o,1,a,l,c),h=t.data.get(i.dataId).values,d=OV(h,i.shape,i.dtype,mt(i.shape),u,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const rre={kernelName:$w,backendName:"cpu",kernelFunc:ire};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ore(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;lt([i,r],"maxPool3DGrad");const u=wl(r.shape,o,a,1,l,c),h=t.bufferSync(r),d=jne(h,u),f=u.strideDepth,m=u.strideHeight,x=u.strideWidth,y=u.dilationDepth,v=u.dilationHeight,w=u.dilationWidth,b=u.effectiveFilterDepth,S=u.effectiveFilterHeight,C=u.effectiveFilterWidth,E=b-1-u.padInfo.front,k=C-1-u.padInfo.left,I=S-1-u.padInfo.top,A=zt(r.shape,"float32"),N=t.bufferSync(i);for(let L=0;L<u.batchSize;++L)for(let V=0;V<u.inChannels;++V)for(let O=0;O<u.inDepth;++O)for(let P=0;P<u.inHeight;++P)for(let W=0;W<u.inWidth;++W){const H=O-E,Y=P-I,D=W-k;let $=0;for(let U=0;U<b;U+=y){const B=(H+U)/f;if(!(B<0||B>=u.outDepth||Math.floor(B)!==B))for(let X=0;X<S;X+=v){const te=(Y+X)/m;if(!(te<0||te>=u.outHeight||Math.floor(te)!==te))for(let oe=0;oe<C;oe+=w){const ue=(D+oe)/x;if(ue<0||ue>=u.outWidth||Math.floor(ue)!==ue)continue;const Q=b*S*C-1-d.get(L,B,te,ue,V),ke=U*S*C+X*C+oe,Me=Q===ke?1:0;if(Me===0)continue;const De=N.get(L,B,te,ue,V);$+=De*Me}}}A.set($,L,O,P,W,V)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const are={kernelName:BE,backendName:"cpu",kernelFunc:ore};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lre(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;lt([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=go(a.shape,l,c,1,u,h),f=t.data.get(a.dataId).values,m=zt(d.outShape,a.dtype,FV(f,a.shape,a.dtype,d).values),x=d.strideHeight,y=d.strideWidth,v=d.dilationHeight,w=d.dilationWidth,b=d.effectiveFilterHeight,S=d.effectiveFilterWidth,C=S-1-d.padInfo.left,E=b-1-d.padInfo.top,k=zt(a.shape,"float32"),I=t.data.get(i.dataId).values,A=zt(i.shape,"float32",I);for(let N=0;N<d.batchSize;++N)for(let L=0;L<d.inChannels;++L)for(let V=0;V<d.inHeight;++V)for(let O=0;O<d.inWidth;++O){const P=V-E,W=O-C;let H=0;for(let Y=0;Y<b;Y+=v){const D=(P+Y)/x;if(!(D<0||D>=d.outHeight||Math.floor(D)!==D))for(let $=0;$<S;$+=w){const U=(W+$)/y;if(U<0||U>=d.outWidth||Math.floor(U)!==U)continue;const B=b*S-1-m.get(N,D,U,L),X=Y*S+$,te=B===X?1:0;if(te===0)continue;const oe=A.get(N,D,U,L);H+=oe*te}}k.set(H,N,V,O,L)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const cre={kernelName:zE,backendName:"cpu",kernelFunc:lre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ure(n,e,t,s,i){const r=mt(e),o=Fk(n,e,t,r,i,"max"),a=FV(n,e,t,i,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hre={kernelName:yO,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=e,l=t;lt(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,u=go(s.shape,i,r,[1,1],o),[h,d]=ure(c,s.shape,s.dtype,a,u),f=l.write(h,u.outShape,s.dtype),m=l.write(d,u.outShape,s.dtype);return[{dataId:f,shape:u.outShape,dtype:s.dtype},{dataId:m,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dre(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=Ut(r,i.shape),c=Fs(i.shape,a)[1],u=Se(c),h=[],d=t.makeTensorInfo([],"float32",new Float32Array([u]));h.push(d);const f=Ic({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});h.push(f);const m=Ok({inputs:{a:f,b:d},backend:t});h.push(m);const x=T0({inputs:{x:m},backend:t,attrs:{axis:r,keepDims:o}});return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),x}const fre={kernelName:Fw,backendName:"cpu",kernelFunc:dre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pre(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;lt(i,"min");const a=Ut(r,i.shape);let l=a;const c=Wn(l,i.shape.length);let u=i;c!=null&&(u=Vi({inputs:{x:i},backend:t,attrs:{perm:c}}),l=is(l.length,i.shape.length)),Zs("min",l,u.shape.length);const[h,d]=Fs(u.shape,l),f=Se(d),m=oi(Se(h),u.dtype),x=t.data.get(u.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let b=x[w];for(let S=0;S<f;++S){const C=x[w+S];(Number.isNaN(C)||C<b)&&(b=C)}m[v]=b}c!=null&&t.disposeIntermediateTensorInfo(u);const y=t.makeTensorInfo(h,u.dtype,m);if(o){const v=ms(h,a),w=Tn({inputs:{x:y},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(y),w}return y}const mre={kernelName:Ow,backendName:"cpu",kernelFunc:pre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gre(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,mode:o}=s;lt(i,"mirrorPad");const a=r.map((b,S)=>b[0]+i.shape[S]+b[1]),l=r.map(b=>b[0]),c=r.map((b,S)=>b[0]+i.shape[S]),u=o==="reflect"?0:1,h=t.data.get(i.dataId).values,d=i.shape.length,f=mt(i.shape),m=Se(a),x=a.length,y=mt(a),v=Ks(i.dtype,m);for(let b=0;b<m;b++){let S=Mf(b,x,y);for(let E=0;E<x;E++)S[E]<l[E]?S[E]=l[E]*2-S[E]-u:S[E]>=c[E]&&(S[E]=(c[E]-1)*2-S[E]+u);S=S.map((E,k)=>E-l[k]);const C=Sa(S,d,f);v[b]=h[C]}return{dataId:t.write(v,a,i.dtype),shape:a,dtype:i.dtype}}const xre={kernelName:zw,backendName:"cpu",kernelFunc:gre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yre=gs((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),vre=Os(Vg,yre),wre={kernelName:Vg,backendName:"cpu",kernelFunc:vre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WV(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=i.shape.length;let a=r;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Ut([a],i.shape),c=VV({inputs:{x:i},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=ms(c.shape,l),h=Tn({inputs:{x:c},backend:t,attrs:{shape:u}}),d=$k({inputs:{a:i,b:h},backend:t}),f=KU({inputs:{x:d},backend:t}),m=T0({inputs:{x:f},backend:t,attrs:{axis:l,keepDims:!1}}),x=Tn({inputs:{x:m},backend:t,attrs:{shape:u}}),y=Ok({inputs:{a:f,b:x},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),y}const bre={kernelName:sb,backendName:"cpu",kernelFunc:WV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sre(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s;lt(i,"multinomial");const l=a?i:WV({inputs:{logits:i},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=t.data.get(l.dataId).values,d=[c,r],f=oi(Se(d),"int32");for(let m=0;m<c;++m){const x=m*u,y=new Float32Array(u-1);y[0]=h[x];for(let b=1;b<y.length;++b)y[b]=y[b-1]+h[x+b];const v=SM.alea(o.toString()),w=m*r;for(let b=0;b<r;++b){const S=v();f[w+b]=y.length;for(let C=0;C<y.length;C++)if(S<y[C]){f[w+b]=C;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",f)}const _re={kernelName:vO,backendName:"cpu",kernelFunc:Sre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cre=NM;function Tre(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;lt(i,"NonMaxSuppression");const c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,{selectedIndices:h}=Cre(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const Ire={kernelName:UE,backendName:"cpu",kernelFunc:Tre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ere=RM;function Mre(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s;lt(i,"NonMaxSuppressionPadded");const u=t.data.get(i.dataId).values,h=t.data.get(r.dataId).values,{selectedIndices:d,validOutputs:f}=Ere(u,h,o,a,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}const kre={kernelName:VE,backendName:"cpu",kernelFunc:Mre};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Are=DM;function Nre(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s;lt(i,"NonMaxSuppressionWithScore");const u=t.data.get(i.dataId).values,h=t.data.get(r.dataId).values,d=o,f=a,m=l,x=c,{selectedIndices:y,selectedScores:v}=Are(u,h,d,f,m,x);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const Rre={kernelName:WE,backendName:"cpu",kernelFunc:Nre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dre(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s;lt(i,"oneHot");const c=Se(i.shape),u=new Float32Array(c*o);u.fill(l);const h=t.data.get(i.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=a);return t.makeTensorInfo([...i.shape,o],r,u)}const Lre={kernelName:Ww,backendName:"cpu",kernelFunc:Dre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=hh({inputs:{input:s},backend:t}),r=R1({inputs:{x:i},backend:t}),o=pf({inputs:{input:s},backend:t}),a=R1({inputs:{x:o},backend:t}),l=nr({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return zk({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Pre={kernelName:ob,backendName:"cpu",kernelFunc:R1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GV(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=hh({inputs:{input:s},backend:t}),r=GV({inputs:{x:i},backend:t}),o=pf({inputs:{input:s},backend:t}),a=R1({inputs:{x:o},backend:t}),l=nr({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return zk({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const $re={kernelName:Vw,backendName:"cpu",kernelFunc:GV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HV(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return N1({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{dE(r,u.shape,"All tensors passed to stack must have matching shapes"),F(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=N1({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=mf({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const Fre={kernelName:Gw,backendName:"cpu",kernelFunc:HV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ore(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;lt(i,"pad");const a=r.map((w,b)=>w[0]+i.shape[b]+w[1]),l=r.map(w=>w[0]),c=t.data.get(i.dataId).values,u=Se(i.shape),h=i.shape.length,d=mt(i.shape),f=Se(a),m=a.length,x=mt(a),y=Ks(i.dtype,f);o!==0&&y.fill(o);for(let w=0;w<u;w++){const S=Mf(w,h,d).map((E,k)=>E+l[k]),C=Sa(S,m,x);y[C]=c[w]}return{dataId:t.write(y,a,i.dtype),shape:a,dtype:i.dtype}}const XV={kernelName:Hw,backendName:"cpu",kernelFunc:Ore};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zre=gs((n,e)=>Math.pow(n,e)),Bre=Os(Gg,zre),Ure={kernelName:Gg,backendName:"cpu",kernelFunc:Bre};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vre(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=e,a=i.map(y=>t.data.get(y.dataId).values),l=i.map(y=>y.shape),c=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,[h,d,f]=dV(a,l,c,r.shape,r.dtype,u,o.shape),m=h.map(y=>t.makeTensorInfo([y.length],"int32",y)),x=t.makeTensorInfo(f,r.dtype,d);return m.concat([x])}const Wre={kernelName:wO,backendName:"cpu",kernelFunc:Vre};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gre(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=fV(o,s.shape,s.dtype,a,i.shape,l,r.shape),h=t.makeTensorInfo([c.length],"int32",c),d=t.makeTensorInfo([u.length],s.dtype,u);return[h,d]}const Hre={kernelName:bO,backendName:"cpu",kernelFunc:Gre};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xre(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,h=t.data.get(o.dataId).values,d=a.map(y=>t.data.get(y.dataId).values),f=a.map(y=>y.shape),[m,x]=pV(c,i.shape,u,r.shape,r.dtype,h,o.shape,d,f,l);return t.makeTensorInfo(m,r.dtype,x)}const jre={kernelName:SO,backendName:"cpu",kernelFunc:Xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qre(n){const{backend:e,attrs:t}=n,{start:s,stop:i,dtype:r,step:o}=t,a=mV(s,i,o,r);return e.makeTensorInfo([a.length],r,a)}const Kre={kernelName:GE,backendName:"cpu",kernelFunc:qre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yre=gn(Hg,n=>1/n),Zre={kernelName:Hg,backendName:"cpu",kernelFunc:Yre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s;lt(i,"resizeBilinear");const l=mt(i.shape),[c,u]=a,[h,d,f,m]=i.shape,x=t.data.get(i.dataId).values,y=new Float32Array(Se([h,c,u,m])),v=[r&&c>1?d-1:d,r&&u>1?f-1:f],w=[r&&c>1?c-1:c,r&&u>1?u-1:u];let b=0;const S=v[0]/w[0],C=v[1]/w[1];for(let E=0;E<h;E++)for(let k=0;k<c;k++){let I;o?I=S*(k+.5)-.5:I=S*k;const A=Math.max(0,Math.floor(I)),N=I-A,L=Math.min(d-1,Math.ceil(I)),V=E*l[0]+A*l[1],O=E*l[0]+L*l[1];for(let P=0;P<u;P++){let W;o?W=C*(P+.5)-.5:W=C*P;const H=Math.max(0,Math.floor(W)),Y=W-H,D=Math.min(f-1,Math.ceil(W)),$=V+H*l[2],U=O+H*l[2],B=V+D*l[2],X=O+D*l[2];for(let te=0;te<m;te++){const oe=x[$+te],ue=x[U+te],Q=x[B+te],ke=x[X+te],Me=oe+(Q-oe)*Y,De=ue+(ke-ue)*Y,Ee=Me+(De-Me)*N;y[b++]=Ee}}}return t.makeTensorInfo([h,c,u,m],"float32",y)}const Qre={kernelName:Yw,backendName:"cpu",kernelFunc:Jre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eoe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s;lt([r,i],"resizeBilinearGrad");const a=mt(i.shape),[l,c,u,h]=i.shape,[,d,f]=r.shape,m=new Float32Array(l*c*u*h),x=[o&&d>1?c-1:c,o&&f>1?u-1:u],y=[o&&d>1?d-1:d,o&&f>1?f-1:f],v=x[0]/y[0],w=x[1]/y[1],b=t.data.get(r.dataId).values;let S=0;for(let C=0;C<l;C++){const E=C*a[0];for(let k=0;k<d;k++){const I=k*v,A=Math.floor(I),N=Math.min(Math.ceil(I),c-1),L=E+A*a[1],V=E+N*a[1],O=I-A,P=1-O;for(let W=0;W<f;W++){const H=W*w,Y=Math.floor(H),D=Math.min(Math.ceil(H),u-1),$=H-Y,U=1-$,B=L+Y*a[2],X=L+D*a[2],te=V+Y*a[2],oe=V+D*a[2],ue=P*U,Q=P*$,ke=O*U,Me=O*$;for(let De=0;De<h;De++){const Ee=b[S++];m[B+De]+=Ee*ue,m[X+De]+=Ee*Q,m[te+De]+=Ee*ke,m[oe+De]+=Ee*Me}}}}return t.makeTensorInfo([l,u,c,h],"float32",m)}const toe={kernelName:jE,backendName:"cpu",kernelFunc:eoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function noe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s;lt(i,"resizeNearestNeighbor");const l=mt(i.shape),[c,u]=a,[h,d,f,m]=i.shape,x=t.data.get(i.dataId).values,y=new Float32Array(h*c*u*m),v=[r&&c>1?d-1:d,r&&u>1?f-1:f],w=[r&&c>1?c-1:c,r&&u>1?u-1:u],b=v[0]/w[0],S=v[1]/w[1];let C=0;for(let E=0;E<h;E++){const k=E*l[0];for(let I=0;I<c;I++){const A=o?b*(I+.5):b*I;let N=Math.min(d-1,r?Math.round(A):Math.floor(A));o&&(N=Math.max(0,N));const L=k+N*l[1];for(let V=0;V<u;V++){const O=o?S*(V+.5):S*V;let P=Math.min(f-1,r?Math.round(O):Math.floor(O));o&&(P=Math.max(0,P));const W=L+P*l[2];for(let H=0;H<m;H++){const Y=x[W+H];y[C++]=Y}}}}return t.makeTensorInfo([h,c,u,m],i.dtype,y)}const soe={kernelName:Kw,backendName:"cpu",kernelFunc:noe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ioe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s;lt([r,i],"resizeNearestNeighborGrad");const a=mt(i.shape),l=mt(r.shape),[c,u,h,d]=i.shape,[,f,m]=r.shape,x=new Float32Array(c*u*h*d),y=t.data.get(r.dataId).values,v=[o&&f>1?u-1:u,o&&m>1?h-1:h],w=[o&&f>1?f-1:f,o&&m>1?m-1:m],b=v[0]/w[0],S=v[1]/w[1],C=1/b,E=1/S,k=Math.ceil(C)*2+2,I=Math.ceil(E)*2+2;for(let A=0;A<c;A++){const N=A*a[0];for(let L=0;L<u;L++){const V=N+L*a[1],O=Math.floor(L*C),P=Math.floor(O-k/2);for(let W=0;W<h;W++){const H=V+W*a[2],Y=Math.floor(W*E),D=Math.floor(Y-I/2);for(let $=0;$<d;$++){let U=0;for(let B=0;B<k;B++){const X=B+P;if(X<0||X>=f)continue;const te=N+X*l[1],oe=X*b,ue=Math.min(u-1,o?Math.round(oe):Math.floor(oe));if(L===ue)for(let Q=0;Q<I;Q++){const ke=Q+D;if(ke<0||ke>=m)continue;const Me=te+ke*l[2],De=ke*S,Ee=Math.min(h-1,o?Math.round(De):Math.floor(De));W===Ee&&(U+=y[Me+$])}}x[H+$]=U}}}}return t.makeTensorInfo(i.shape,i.dtype,x)}const roe={kernelName:XE,backendName:"cpu",kernelFunc:ioe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ooe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s;lt(i,"reverse");const o=i.shape.length,a=Ut(r,i.shape);if(o===0)return Aa({inputs:{x:i},backend:t});const l=new ii(i.shape,i.dtype),c=t.bufferSync(i);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),d=h.slice();a.forEach(f=>d[f]=i.shape[f]-1-d[f]),l.set(c.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const aoe={kernelName:Zw,backendName:"cpu",kernelFunc:ooe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const loe={kernelName:QE,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=Ks(s.dtype,Se(s.shape)),[c,u,h,d]=s.shape,[f,m]=HM(o,u,h),x=255,y=Math.sin(i),v=Math.cos(i),w=a.data.get(s.dataId).values;for(let S=0;S<c;S++){const C=S*h*u*d;for(let E=0;E<u;E++){const k=E*(h*d);for(let I=0;I<h;I++){const A=I*d;for(let N=0;N<d;N++){const L=[c,E,I,N],V=L[2],O=L[1];let P=(V-f)*v-(O-m)*y,W=(V-f)*y+(O-m)*v;P=Math.round(P+f),W=Math.round(W+m);let H=r;if(typeof r!="number"&&(N===3?H=x:H=r[N]),P>=0&&P<h&&W>=0&&W<u){const D=W*(h*d),$=P*d,U=C+D+$+N;H=w[U]}const Y=C+k+A+N;l[Y]=H}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const coe=gn(qg,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),uoe={kernelName:qg,backendName:"cpu",kernelFunc:coe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hoe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=f0(r,i,o),d=!0,f=t.bufferSync(i),m=t.bufferSync(r),x=Dd(f,m,o,h,c,l,a,u,0,d);return t.makeTensorInfo(o,x.dtype,x.values)}const doe={kernelName:_O,backendName:"cpu",kernelFunc:hoe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function foe(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<e?t=i+1:s=i;return s}function poe(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<=e?t=i+1:s=i;return s}function moe(n,e,t,s,i,r){const o=fs("int32",t*i);for(let a=0;a<t;++a){const l=n.slice(a*s,(a+1)*s),c=a*i;for(let u=0;u<i;++u)o[c+u]=r==="left"?foe(l,e[u+c]):poe(l,e[u+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function goe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=moe(a,l,i.shape[0],i.shape[1],r.shape[1],o);return t.makeTensorInfo(r.shape,"int32",c)}const xoe={kernelName:CO,backendName:"cpu",kernelFunc:goe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yoe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e;lt([s,i,r],"select");const o=s.shape.length,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=lr(i.dtype,r.dtype),h=oi(Se(i.shape),u);let d=0;const f=o===0||o>1||i.shape.length===1?1:Se(i.shape.slice(1));for(let m=0;m<a.length;m++)for(let x=0;x<f;x++)a[m]===1?h[d++]=l[m]:h[d++]=c[m];return t.makeTensorInfo(i.shape,u,h)}const voe={kernelName:Jw,backendName:"cpu",kernelFunc:yoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const woe=vb,boe=wb,Soe=gn(Yg,n=>n>=0?boe*n:woe*(Math.exp(n)-1)),_oe={kernelName:Yg,backendName:"cpu",kernelFunc:Soe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Coe=gn(Qg,n=>n<0?-1:n>0?1:0),Toe={kernelName:Qg,backendName:"cpu",kernelFunc:Coe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ioe=gn(Zg,n=>Math.sin(n)),Eoe={kernelName:Zg,backendName:"cpu",kernelFunc:Ioe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Moe=gn(Jg,n=>Math.sinh(n)),koe={kernelName:Jg,backendName:"cpu",kernelFunc:Moe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aoe=11920928955078125e-23,$D=Math.log(Aoe)+2,Noe=gn(t0,n=>{const e=n>-$D,t=n<$D,s=Math.exp(n);let i;return t?i=s:e?i=n:i=Math.log(1+s),i}),Roe={kernelName:t0,backendName:"cpu",kernelFunc:Noe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Doe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;lt([i],"spaceToBatchND");const a=Se(r),l=[[0,0]];l.push(...o);for(let E=1+r.length;E<i.shape.length;++E)l.push([0,0]);const c=XV.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),u=p0(c.shape,r,a,!1),h=m0(u.length,r.length,!1),d=g0(c.shape,r,a,!1),x=Tn({inputs:{x:c},backend:t,attrs:{shape:u}}),w=Vi({inputs:{x},backend:t,attrs:{perm:h}}),C=Tn({inputs:{x:w},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),C}const Loe={kernelName:tb,backendName:"cpu",kernelFunc:Doe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Poe(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values[0],[h,d,f,m,x]=vV(a,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],i.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const $oe={kernelName:TO,backendName:"cpu",kernelFunc:Poe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Foe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(t.data.get(i.dataId).values),a=t.data.get(s.dataId).values,l=Array.from(t.data.get(r.dataId).values),[c,u,h]=wV(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}const Ooe={kernelName:IO,backendName:"cpu",kernelFunc:Foe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zoe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=Pk(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const Boe={kernelName:EO,backendName:"cpu",kernelFunc:zoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uoe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=Pk(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(u,s.dtype,c)}const Voe={kernelName:MO,backendName:"cpu",kernelFunc:Uoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Woe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=f0(r,i,a),f=!1,m=t.bufferSync(i);let x;switch(r.dtype){case"bool":{const y=t.bufferSync(r),v=Boolean(t.data.get(o.dataId).values[0]);x=Dd(m,y,a,d,u,c,l,h,v,f);break}case"float32":{const y=t.bufferSync(r),v=t.data.get(o.dataId).values[0];x=Dd(m,y,a,d,u,c,l,h,v,f);break}case"int32":{const y=t.bufferSync(r),v=t.data.get(o.dataId).values[0];x=Dd(m,y,a,d,u,c,l,h,v,f);break}case"string":{const y=t.bufferSync(r),v=wc(t.data.get(o.dataId).values[0]);x=Dd(m,y,a,d,u,c,l,h,v,f);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return t.makeTensorInfo(a,x.dtype,x.values)}const Goe={kernelName:kO,backendName:"cpu",kernelFunc:Woe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hoe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Ut(o,i.shape)[0],l=ok(i,r,a),c=new Array(i.shape.length).fill(0),u=i.shape.slice();return l.map(h=>{const d=[...u];d[a]=h;const f=dh({inputs:{x:i},backend:t,attrs:{begin:c,size:d}});return c[a]+=h,f})}const Xoe={kernelName:nb,backendName:"cpu",kernelFunc:Hoe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const joe={kernelName:qE,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;lt(t,"square");const i=s.data.get(t.dataId).values,r=new Float32Array(i.length);for(let a=0;a<i.length;++a){const l=i[a];r[a]=l*l}return{dataId:s.write(r,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qoe=gn(l0,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),Koe={kernelName:l0,backendName:"cpu",kernelFunc:qoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yoe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s;lt(i,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:x,sliceDim0:y,isSimpleSlice:v,begin:w,end:b,strides:S}=VM(i.shape,r,o,a,l,c,u,h,d);let C;if(x)C=Tn({inputs:{x:i},backend:t,attrs:{shape:m}});else if(y||v){F(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const E=zM(w,b,S),k=dh({inputs:{x:i},backend:t,attrs:{begin:w,size:E}});C=Tn({inputs:{x:k},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(k)}else{const E=t.bufferSync(i),k=SV(f,E,S,w);C=t.makeTensorInfo(m,k.dtype,k.values)}return C}const Zoe={kernelName:KE,backendName:"cpu",kernelFunc:Yoe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Joe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.data.get(u.dataId).values,f=t.data.get(h.dataId).values,[m,x]=_V(d,f,i,r,o,a,l,c);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(h.shape,"int32",x)]}const Qoe={kernelName:AO,backendName:"cpu",kernelFunc:Joe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eae(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values[0],[c,u,h]=CV(a,l,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const tae={kernelName:NO,backendName:"cpu",kernelFunc:eae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nae(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(r.dataId).values,a=TV(o,i);return t.makeTensorInfo(r.shape,"int32",a)}const sae={kernelName:RO,backendName:"cpu",kernelFunc:nae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iae=gn(r0,n=>Math.tan(n)),rae={kernelName:r0,backendName:"cpu",kernelFunc:iae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oae=gn(o0,n=>Math.tanh(n)),aae={kernelName:o0,backendName:"cpu",kernelFunc:oae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lae(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;lt(i,"tile");const o=EV(t.bufferSync(i),r);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const cae={kernelName:a0,backendName:"cpu",kernelFunc:lae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uae(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s;lt(i,"topk");const a=t.data.get(i.dataId).values,[l,c]=kV(a,i.shape,i.dtype,r,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const hae={kernelName:YE,backendName:"cpu",kernelFunc:uae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dae(n){const{inputs:e,attrs:t,backend:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[u,h,d,f]=i.shape,[m,x]=c!=null?c:[h,d],y=[u,m,x,f],v=mt(i.shape),w=v[0],b=v[1],S=v[2],C=mt(y),E=C[0],k=C[1],I=C[2],A=Ks(i.dtype,Se(y));A.fill(l);const N=s.data.get(i.dataId).values,L=s.data.get(r.dataId).values;for(let O=0;O<u;++O){const P=r.shape[0]===1?L:L.subarray(O*8,O*8+8);for(let W=0;W<m;++W)for(let H=0;H<x;++H)for(let Y=0;Y<f;++Y){let D;const $=P[6]*H+P[7]*W+1;if($===0)continue;const U=(P[0]*H+P[1]*W+P[2])/$,B=(P[3]*H+P[4]*W+P[5])/$,X=FD(U,d,a),te=FD(B,h,a);switch(o){case"nearest":D=yae(N,h,d,w,b,S,O,te,X,Y,l);break;case"bilinear":D=vae(N,h,d,w,b,S,O,te,X,Y,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const oe=O*E+W*k+H*I+Y;A[oe]=D}return s.makeTensorInfo(y,i.dtype,A)}return{dataId:s.write(A,y,i.dtype),shape:i.shape,dtype:i.dtype}}const fae={kernelName:ZE,backendName:"cpu",kernelFunc:dae};function FD(n,e,t){switch(t){case"reflect":return pae(n,e);case"wrap":return mae(n,e);case"nearest":return xae(n,e);case"constant":default:return gae(n)}}function pae(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Qu(0,t,e-1)}function mae(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Qu(0,t,e-1)}function gae(n,e){return n}function xae(n,e){return Qu(0,n,e-1)}function qp(n,e,t,s,i,r,o,a,l,c,u){const h=o*s+a*i+l*r+c;return 0<=a&&a<e&&0<=l&&l<t?n[h]:u}function yae(n,e,t,s,i,r,o,a,l,c,u){const h=Math.round(a),d=Math.round(l);return qp(n,e,t,s,i,r,o,h,d,c,u)}function vae(n,e,t,s,i,r,o,a,l,c,u){const h=Math.floor(a),d=Math.floor(l),f=h+1,m=d+1,x=(m-l)*qp(n,e,t,s,i,r,o,h,d,c,u)+(l-d)*qp(n,e,t,s,i,r,o,h,m,c,u),y=(m-l)*qp(n,e,t,s,i,r,o,f,d,c,u)+(l-d)*qp(n,e,t,s,i,r,o,f,m,c,u);return(f-a)*x+(a-h)*y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wae(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;lt(r,"unique");const o=s.data.get(r.dataId).values,{outputValues:a,outputShape:l,indices:c}=AV(o,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const bae={kernelName:JE,backendName:"cpu",kernelFunc:wae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sae(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i.shape.length,a=i.shape[r],l=new Array(o-1);let c=0;for(let f=0;f<o;f++)f!==r&&(l[c++]=i.shape[f]);const u=new Array(o).fill(0),h=i.shape.slice();h[r]=1;const d=new Array(a);for(let f=0;f<d.length;f++){u[r]=f;const m=dh({inputs:{x:i},backend:t,attrs:{begin:u,size:h}});d[f]=Tn({inputs:{x:m},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(m)}return d}const _ae={kernelName:ib,backendName:"cpu",kernelFunc:Sae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cae(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s;lt(i,"unsortedSegmentSum");const a=i.shape.length,l=r.shape.length,c=[],u=[],h=a-l;let d=r;for(let m=0;m<h;++m){const x=N1({inputs:{input:d},backend:t,attrs:{dim:m+1}});d=x,u.push(x)}for(let m=0;m<o;++m){const x=Pc(m,"int32"),y=t.makeTensorInfo([],"int32",x),v=jU({inputs:{a:y,b:d},backend:t}),w=Ic({inputs:{x:v},backend:t,attrs:{dtype:"float32"}}),b=Rb({inputs:{a:w,b:i},backend:t}),S=T0({inputs:{x:b},backend:t,attrs:{axis:0,keepDims:!1}});c.push(S),u.push(y),u.push(v),u.push(w),u.push(b),u.push(S)}const f=HV({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const Tae={kernelName:rb,backendName:"cpu",kernelFunc:Cae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iae=[bne,ate,_ne,Tne,fte,Ene,kne,Nne,Dne,Pne,Fne,zne,Une,Gne,Xne,Kne,Zne,Qne,tse,vne,sse,rse,ase,cse,hte,mte,hse,lte,fse,mse,gse,yse,wse,Sse,Cse,Ise,Mse,Ase,Rse,Lse,$se,Ose,Bse,Use,Wse,Hse,jse,qse,Kse,Yse,Qse,dne,tie,gte,cie,xte,uie,vte,gie,xie,vie,bte,Sie,Cie,Iie,Mie,Aie,_te,Tte,cte,Rie,pse,Lie,$ie,Oie,fne,Ete,kte,Bie,Nte,Vie,Hie,jie,Yie,Jie,ere,tre,Dte,sre,rre,are,cre,hre,fre,mre,Pte,xre,wre,_re,Fte,zte,Ire,kre,Rre,Ute,Lre,$re,Fre,XV,Ure,mne,Gte,Wre,Hre,jre,Kre,ute,vT,Zre,gne,xne,yne,Qre,toe,soe,roe,aoe,loe,uoe,Jte,doe,xoe,voe,_oe,ene,Toe,Eoe,koe,tne,bre,Roe,Loe,$oe,Ooe,Boe,Voe,Goe,Xoe,ine,joe,one,Koe,Zoe,Qoe,tae,sae,une,Zse,rae,aae,cae,hae,fae,Vte,bae,_ae,Tae,Pre];for(const n of Iae)LO(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bu={},gy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Eae(n,e){bu[n]=e}function Xo(n,e){if(!(n in bu)||e!=null){const s=kae(n,e);if(s!==null)bu[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=bu[n];return t==null||t.isContextLost()?(delete bu[n],Xo(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),bu[n])}function Mae(n){if(typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function kae(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e==null?Mae(n):e;return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete bu[n]},!1),xe().getBool("SOFTWARE_WEBGL_ENABLED")&&(gy.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",gy)||t.getContext("experimental-webgl",gy):t.getContext("webgl2",gy)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Om;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Om||(Om={}));var _r;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(_r||(_r={}));var Xs;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Xs||(Xs={}));function I0(n,e){return[e,n]}function Aae(n,e){return n*e}function xy(n){const e=Se(n),t=Math.ceil(e/4);return z2(t)}function $f(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Nae(n,e){const[t,s]=$f(n,e);return t*s*4}function Bk(n,e){const t=n;let s,i,r,o,a,l,c,u,h,d;return xe().getNumber("WEBGL_VERSION")===2?(s=t.R32F,i=t.R16F,r=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(s=n.RGBA,i=n.RGBA,r=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tt(n,e){const t=e();return xe().getBool("DEBUG")&&Rae(n),t}function Rae(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+$ae(n,e))}const Dae=596e-10,Lae=65504;function Pae(n){return!!(xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Dae<Math.abs(n)&&Math.abs(n)<Lae)}function $ae(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function yy(n,e){return Sl(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Fae(n,e){const t=Sl(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(tt(n,()=>n.shaderSource(t,e)),tt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Oae(n,e){const t=Sl(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(tt(n,()=>n.shaderSource(t,e)),tt(n,()=>n.compileShader(t)),xe().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw jV(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const zae=/ERROR: [0-9]+:([0-9]+):/g;function jV(n,e){const t=zae.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],i=n.split(`
`),r=i.length.toString().length+2,o=i.map((h,d)=>Gd((d+1).toString(),r)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,s-1),c=o.slice(s-1,s),u=o.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Gd(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function Bae(n){return Sl(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function Uae(n,e){if(tt(n,()=>n.linkProgram(e)),!xe().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function j_(n,e){if(tt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Vae(n,e){const t=Sl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return tt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),tt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Wae(n,e){const t=Sl(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return tt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),tt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Gae(n){return Sl(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Hae(n,e){const t=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function Xae(n){return Sl(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function OD(n,e,t,s,i,r,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(tt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),tt(n,()=>n.vertexAttribPointer(a,i,n.FLOAT,!1,r,o)),tt(n,()=>n.enableVertexAttribArray(a)),!0)}function jae(n,e,t){Jae(n,t),tt(n,()=>n.activeTexture(n.TEXTURE0+t)),tt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function qae(n,e,t){return Sl(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Kae(n,e,t){return n.getUniformLocation(e,t)}function Yae(n,e,t,s){tt(n,()=>jae(n,e,s)),tt(n,()=>n.uniform1i(t,s))}function q_(n,e,t){tt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),tt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function zD(n,e){tt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),tt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function vy(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Zae(n,e))}function Zae(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Sl(n,e,t){const s=tt(n,()=>e());if(s==null)throw new Error(t);return s}function Jae(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function gf(n,e=2){return Se(n.slice(0,n.length-e))}function xf(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function wy(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[gf(n),...xf(n)]),e}function Qae(n,e=!1){let t=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=xe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&xe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?hE(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Lc(n).newShape);let i=Se(n),r=null;n.length<=1&&i<=t?r=[1,i]:n.length===2&&n[0]<=t&&n[1]<=t?r=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?r=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?r=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?r=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(r=[n[0],n[1]*n[2]*n[3]]);const o=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(e?2:1)&&Math.min(...r)>0;if(r==null||o)if(e){const a=gf(n);let l=2,c=2;n.length&&([l,c]=xf(n)),i=a*(l/2)*(c/2),r=z2(i).map(u=>u*2)}else r=z2(i);return r}function by(n){return n%2===0}function D1(n,e){if(n=n.slice(-2),e=e.slice(-2),pn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],s=e.slice(-1)[0];if(t===s||by(t)&&by(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&by(n[0])&&by(e[0])}let K_,Y_;function ele(n){if(K_==null){const e=Xo(n);K_=e.getParameter(e.MAX_TEXTURE_SIZE)}return K_}function tle(n){if(Y_==null){const e=Xo(n);Y_=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Y_)}function nle(n){if(n===0)return 0;let e;const t=Xo(n);return co(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:co(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function co(n,e){return n.getExtension(e)!=null}function BD(n){try{if(Xo(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function sle(n){if(n===0)return!1;const e=Xo(n);if(n===1){if(!co(e,"OES_texture_float"))return!1}else if(!co(e,"EXT_color_buffer_float"))return!1;return bT(e)}function ile(n){if(n===0)return!1;const e=Xo(n);if(n===1){if(!co(e,"OES_texture_float")||!co(e,"WEBGL_color_buffer_float"))return!1}else{if(co(e,"EXT_color_buffer_float"))return bT(e);const s="EXT_color_buffer_half_float";if(co(e,s)){const i=e.getExtension(s);return rle(e,i)}return!1}return bT(e)}function bT(n){const e=Bk(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const s=1,i=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,s,i,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(r),o}function rle(n,e){const t=Bk(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s);const i=1,r=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,i,r,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function ole(n){return n!==2?!1:Xo(n).fenceSync!=null}function E0(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&F(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dt=xe();dt.registerFlag("HAS_WEBGL",()=>dt.getNumber("WEBGL_VERSION")>0);dt.registerFlag("WEBGL_VERSION",()=>BD(2)?2:BD(1)?1:0);dt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);dt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>dt.get("WEBGL_VERSION")===2);dt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);dt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);dt.registerFlag("WEBGL_PACK",()=>dt.getBool("HAS_WEBGL"));dt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_CLIP",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_PACK_REDUCE",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_LAZILY_UNPACK",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_CONV_IM2COL",()=>dt.getBool("WEBGL_PACK"));dt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>ele(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>tle(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=dt.getNumber("WEBGL_VERSION");return n===0?0:nle(n)});dt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>dt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!XO());dt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>sle(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>dt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:dt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));dt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ile(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>ole(dt.getNumber("WEBGL_VERSION")));dt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>dt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);dt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});dt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>XO()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});dt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);dt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);dt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);dt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);dt.registerFlag("WEBGL_EXP_CONV",()=>!1);dt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>dt.getBool("IS_TEST"));dt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);dt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);dt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);dt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(){let n,e,t,s,i,r,o,a,l,c;return xe().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",i="texture",r="outputColor",o="out vec4 outputColor;",a=xe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",i="texture2D",r="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:i,output:r,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mh(n,e,t="index"){const s=mt(e);return s.map((i,r)=>{const o=`int ${n[r]} = ${t} / ${i}`,a=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * ${i}`:`index -= ${n[r]} * ${i}`;return`${o}; ${a};`}).join("")}function Db(n,e,t="index"){const s=mt(e);return s.map((i,r)=>{const o=`int ${n[r]} = ${t} / outShapeStrides[${r}]`,a=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * outShapeStrides[${r}]`:`index -= ${n[r]} * outShapeStrides[${r}]`;return`${o}; ${a};`}).join("")}function ale(n,e){const t=n.length,s=n.map(r=>`${e}[${r}]`),i=new Array(t-1);i[t-2]=s[t-1];for(let r=t-3;r>=0;--r)i[r]=`(${i[r+1]} * ${s[r+1]})`;return i}function lle(n,e,t="index"){const s=n.map((r,o)=>o),i=ale(s,e);return i.map((r,o)=>{const a=`int ${n[o]} = ${t} / ${i[o]}`,l=o===i.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${i[o]}`:`index -= ${n[o]} * ${i[o]}`;return`${a}; ${l};`}).join("")}function Uk(n){const e=mt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Vk(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const qV=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:KV}=lZ;function cle(n,e,t){const s=[];if(n.forEach(f=>{const m=Se(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?s.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(s.push(`uniform sampler2D ${f.name};`),s.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){const{uniformShape:x}=Wk(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${f.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${f.name}Shape;`);break}s.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{s.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const i=s.join(`
`),r=n.map(f=>ule(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Ei(),l=fle(a);let c,u,h=gle(a);return e.isPacked?(c=hle(e.logicalShape,o,t.enableShapeUniforms),u=mle(a)):(c=dle(e.logicalShape,o,t.enableShapeUniforms),u=ple(a)),t.packedInputs&&(h+=wle),[h,l,u,i,c,r,t.userCode].join(`
`)}function Ff(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return Rle(n,e);case 1:return Lle(n,e);case 2:return $le(n,e);case 3:return Ole(n,e);case 4:return Ble(n,e);case 5:return Ule(n);case 6:return Vle(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function YV(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Nle(n);case 1:return Dle(n,e);case 2:return Ple(n,e);case 3:return Fle(n,e);default:return zle(n,e)}}function ule(n,e,t=!1,s){let i="";t?i+=YV(n,s):i+=Ff(n,s);const r=n.shapeInfo.logicalShape,o=e.logicalShape;return r.length<=o.length&&(t?i+=Wle(n,e):i+=Gle(n,e)),i}function hle(n,e,t){switch(n.length){case 0:return ZV();case 1:return ble(n,e,t);case 2:return kle(n,e,t);case 3:return _le(n,e,t);default:return Tle(n,e,t)}}function dle(n,e,t){switch(n.length){case 0:return ZV();case 1:return Sle(n,e,t);case 2:return Ale(n,e,t);case 3:return Cle(n,e,t);case 4:return Ile(n,e,t);case 5:return Ele(n,e);case 6:return Mle(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function fle(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function ple(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function mle(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function gle(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${xle}
    ${yle}
    ${vle}
  `}const xle=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,yle=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,vle=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,wle=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function ZV(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ble(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function Sle(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function _le(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[2]/2),r=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function Cle(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Db(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Mh(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function Tle(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[n.length-1]/2),r=i*Math.ceil(n[n.length-2]/2);let o=r,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `}function Ile(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Db(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Mh(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function Ele(n,e){const t=Mh(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Mle(n,e){const t=Mh(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function kle(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(pn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function Ale(n,e,t){return pn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function kh(n){return`offset${n}`}function Nle(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ei();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function Rle(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[i,r]=n.shapeInfo.texShape;if(i===1&&r===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=kh(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function Dle(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n.shapeInfo.texShape,r=Ei();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${r.texture2D}(${t}, uv);
    }
  `}function Lle(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Of(n)}
      }
    `;const i=n.shapeInfo.texShape,r=i[0],o=i[1];if(o===1&&r===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=kh(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);
        return sampleTexture(${t}, uv);
      }
    `:r===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function Ple(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=r[0],a=r[1],l=Ei();if(r!=null&&pn(t,r))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function $le(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape;if(r!=null&&pn(t,r)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=r[0],f=r[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=Lc(t),l=o;if(l.length<t.length){const d=zf(n,l),f=["row","col"];return`
      ${Ff(d,e)}
      float ${i}(int row, int col) {
        return ${i}(${Bf(f,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Of(n)}
      }
    `;const c=r[0],u=r[1],h=kh(s);return u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`}function Fle(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(t[0]===1){const d=t.slice(1),f=[1,2],m=zf(n,d),x=["b","row","col"];return`
        ${YV(m,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Bf(x,f)});
        }
      `}const a=Ei();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function Ole(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Lc(t),c=a;if(c.length<t.length){const x=zf(n,c),y=["row","col","depth"];return`
        ${Ff(x,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Bf(y,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${o}, 1)));
        ${Of(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],d=u[1],f=n.shapeInfo.flatOffset;if(d===r&&f==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===o&&f==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const m=kh(s);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${o} + depth + ${m};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function zle(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=Ei();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const r=n.shapeInfo.logicalShape,o=r.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(r[o-1]/2);let d=h*Math.ceil(r[o-2]/2),f="int b, int row, int col",m=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let x=2;x<o-1;x++)f=`int b${x}, `+f,d*=r[o-x-1],m=`b${x} * ${d} + `+m;return`
    vec4 ${s}(${f}) {
      int index = ${m};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${i.texture2D}(${t}, uv);
    }
  `}function Ble(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[3],o=t[2]*r,a=t[1]*o,{newShape:l,keptDims:c}=Lc(t);if(l.length<t.length){const w=zf(n,l),b=["row","col","depth","depth2"];return`
      ${Ff(w,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Bf(b,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${r}, 1)));
        ${Of(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],f=h[1],m=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,y=`int stride0 = ${s}Shape[1] * stride1;`;if(f===a&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${m}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(f===r&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const v=kh(s);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${x}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${v});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${v});
      return sampleTexture(${s}, uv);
    }
  `}function Ule(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],r=e[3]*i,o=e[2]*r,a=e[1]*o,{newShape:l,keptDims:c}=Lc(e);if(l.length<e.length){const x=zf(n,l),y=["row","col","depth","depth2","depth3"];return`
      ${Ff(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Bf(y,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${r}, ${i})) +
          depth3;
        ${Of(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],f=h[1];if(f===a&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===i&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=kh(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${r} +
          depth2 * ${i} + depth3 + ${m};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Vle(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:r}=Lc(e);if(i.length<e.length){const y=zf(n,i),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ff(y)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Bf(v,r)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Of(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,f=d[0],m=d[1];if(m===u&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(m===o&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=kh(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${x};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Of(n){const e=n.name,t=Se(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Wle(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=KV(n.shapeInfo.logicalShape,e.logicalShape),l=In(o),c=o-r;let u;const h=["x","y","z","w","u","v"];r===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(w=>`coords.${h[w+c]} = 0;`).join(`
`);let d="";o<2&&r>0?d="coords":d=n.shapeInfo.logicalShape.map((w,b)=>`coords.${h[b+c]}`).join(", ");let f="return outputValue;";const x=Se(n.shapeInfo.logicalShape)===1,v=Se(e.logicalShape)===1;if(r===1&&!x&&!v)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!v)o===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){const w=r-2,b=r-1;a.indexOf(w)>-1&&a.indexOf(b)>-1?f="return vec4(outputValue.x);":a.indexOf(w)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(b)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${d});
      ${f}
    }
  `}function Gle(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&pn(o,r))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=In(l),u=KV(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const f=["x","y","z","w","u","v"];a===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(x=>`coords.${f[x+h]} = 0;`).join(`
`);let m="";return l<2&&a>0?m="coords":m=n.shapeInfo.logicalShape.map((x,y)=>`coords.${f[y+h]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${s}(${m});
    }
  `}function In(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Wk(n,e,t){const{newShape:s,keptDims:i}=Lc(e),r=e.length,o=n&&r===3&&e[0]===1,a=o?e.slice(1):s,l=!n&&r>1&&!pn(e,t)&&s.length<r||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:i}}function zf(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Bf(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hle(n,e,t,s){const i=t.map((u,h)=>{const d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),r=i.map(u=>u.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=cle(i,o,e),l=Oae(n.gl,a),c=n.createProgram(l);return xe().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:r,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:r,outShapeInfo:o},JV(n,e,c))}function JV(n,e,t){const s={},i={},r={},o=[];let a,l,c,u=null,h=null;h=n.getUniformLocation(t,"NAN",!1),xe().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(let f=0;f<e.variableNames.length;f++){const m=e.variableNames[f];s[m]=n.getUniformLocation(t,m,d),s[`offset${m}`]=n.getUniformLocation(t,`offset${m}`,d),e.enableShapeUniforms&&(i[`${m}Shape`]=n.getUniformLocation(t,`${m}Shape`,d),r[`${m}TexShape`]=n.getUniformLocation(t,`${m}TexShape`,d))}return e.enableShapeUniforms&&(a=n.getUniformLocation(t,"outShape",d),c=n.getUniformLocation(t,"outShapeStrides",d),l=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms&&e.customUniforms.forEach((f,m)=>{o[m]=n.getUniformLocation(t,f.name,d)}),{uniformLocations:s,customUniformLocations:o,infLoc:u,nanLoc:h,inShapesLocations:i,inTexShapesLocations:r,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function UD(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const i=t.logicalShape,r=e[s],o=r.shape;if(!pn(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(t.isUniform&&r.isUniform)return;const a=t.texShape,l=r.isUniform?null:r.texData.texShape;if(!pn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Xle(n,e,t,s,i){e.program.enableShapeUniforms||(UD(e.inShapeInfos,t),UD([e.outShapeInfo],[s]));const r=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(r.texture,o[0],o[1]):n.setOutputMatrixTexture(r.texture,o[0],o[1]),n.setProgram(e.webGLProgram),xe().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((l,c)=>{const u=e.program.variableNames[c],h=e.uniformLocations[u],d=e.uniformLocations[`offset${u}`],f=e.inShapesLocations[`${u}Shape`],m=e.inTexShapesLocations[`${u}TexShape`];if(f){const{uniformShape:x}=Wk(e.program.packedInputs,l.shape,l.texData.texShape);switch(x.length){case 1:n.gl.uniform1iv(f,new Int32Array(x));break;case 2:n.gl.uniform2iv(f,new Int32Array(x));break;case 3:n.gl.uniform3iv(f,new Int32Array(x));break;case 4:n.gl.uniform4iv(f,new Int32Array(x));break}}if(m&&n.gl.uniform2i(m,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(Se(l.shape)<2)n.gl.uniform1f(h,l.uniformValues[0]);else{let x=l.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),n.gl.uniform1fv(h,x)}return}l.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,h,c)}});const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=mt(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&i&&e.program.customUniforms.forEach((l,c)=>{const u=e.customUniformLocations[c],h=i[c];if(l.type==="float")n.gl.uniform1fv(u,h);else if(l.type==="vec2")n.gl.uniform2fv(u,h);else if(l.type==="vec3")n.gl.uniform3fv(u,h);else if(l.type==="vec4")n.gl.uniform4fv(u,h);else if(l.type==="int")n.gl.uniform1iv(u,h);else if(l.type==="ivec2")n.gl.uniform2iv(u,h);else if(l.type==="ivec3")n.gl.uniform3iv(u,h);else if(l.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${l.type} is not supported yet.`)}),n.executeProgram()}function jle(n,e,t){let s="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=Wk(n.packedInputs,o.shape,l);let d="",f="",m="";if(u.length===1&&n.packedInputs){const C=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${C[0]>1}_${C[1]>1}`}else if(u.length===2&&!n.packedInputs)f=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const C=mt(u);m=`${C[0]===l[1]}_${C[C.length-1]===l[1]}`}const x=o.shape.length,y=u.length===2&&pn(o.shape,l),v=Se(o.shape)===1,w=lf(o.shape,t.shape),b=!n.packedInputs&&x===t.shape.length&&pn(l,t.texData.texShape),S=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${x}_${b}_${c?h:""}_${u.length}_${v}_${w}_${y}_${d}_${f}_${m}_${S}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const i=n.userCode;let r=n.constructor.name;return r+="_"+s+"_"+i+`${xe().getNumber("WEBGL_VERSION")}`,r}function Mi(n){return xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qle{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Om.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ei();this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Db(["r","c","d"],e):Mh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kle{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Om.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ei();this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Db(["r","c","d"],e):Mh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yle{constructor(e){this.variableNames=["A"],this.outTexUsage=_r.DOWNLOAD;const t=Ei();this.outputShape=e,this.userCode=`
      ${qV}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zle{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=_r.DOWNLOAD;const t=Ei();this.outputShape=e,this.userCode=`
      ${qV}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jle={R:0,G:1,B:2,A:3};class VD{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Ei();this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${Jle[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Vk():Uk(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${o}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qle{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ei();this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length);let i="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;i+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Vk():Uk(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${r};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ece(n){const e=Ei(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Fae(n,t)}function tce(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Vae(n,e)}function nce(n){const e=new Uint16Array([0,1,2,2,1,3]);return Wae(n,e)}function M0(n,e,t,s,i,r){Hae(e,t);const o=Gae(n),a=n.TEXTURE_2D;return tt(n,()=>n.bindTexture(a,o)),tt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),tt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),tt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),tt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),xe().getNumber("WEBGL_VERSION")===1?tt(n,()=>n.texImage2D(a,0,s,e,t,0,i,r,null)):tt(n,()=>n.texStorage2D(a,1,s,e,t)),tt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function QV(n){return n.internalFormatFloat}function sce(n,e,t,s){const[i,r]=I0(e,t);return M0(n,i,r,QV(s),s.textureFormatFloat,n.FLOAT)}function eW(n){return n.internalFormatHalfFloat}function ice(n,e,t,s){const[i,r]=I0(e,t);return M0(n,i,r,eW(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function tW(n){return n.downloadTextureFormat}function rce(n,e,t,s){const[i,r]=I0(e,t);return M0(n,i,r,tW(s),n.RGBA,n.UNSIGNED_BYTE)}function nW(n){return n.internalFormatPackedFloat}function oce(n,e,t,s){const[i,r]=$f(e,t);return M0(n,i,r,nW(s),n.RGBA,n.FLOAT)}function sW(n){return n.internalFormatPackedHalfFloat}function ace(n,e,t,s){const[i,r]=$f(e,t);return M0(n,i,r,sW(s),n.RGBA,s.textureTypeHalfFloat)}function lce(n,e,t){return tt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),OD(n,e,"clipSpacePos",t,3,20,0)&&OD(n,e,"uv",t,2,20,12)}function cce(n,e,t,s,i,r){tt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;i instanceof Uint8Array?(o=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*s*4),a=n.FLOAT,l=r.internalFormatPackedFloat),o.set(i),xe().getNumber("WEBGL_VERSION")===2?tt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,o)):tt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,o)),tt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function uce(n,e,t){tt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?xe().getNumber("WEBGL_VERSION")===2?tt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):tt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):xe().getNumber("WEBGL_VERSION")===2?tt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):tt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),tt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function hce(n,e,t,s){const i=n.createBuffer();tt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const a=4*4*e*t;return tt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),tt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),tt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function dce(n,e,t){const s=n,i=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function fce(n,e,t,s){const[i,r]=I0(e,t),o=4,a=new Uint8Array(Aae(e*t,o));return tt(n,()=>n.readPixels(0,0,i,r,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function pce(n,e,t,s,i,r,o,a){const l=n,c=new Float32Array(Nae(r,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function mce(n,e,t){const s=new Float32Array(e*t*4);return tt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z_{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=xe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Eae(t,e)):this.gl=Xo(t),e=this.gl,xe().getNumber("WEBGL_VERSION")===2){const r=e;this.createVertexArray=()=>tt(r,()=>r.createVertexArray()),this.bindVertexArray=o=>tt(r,()=>r.bindVertexArray(o)),this.deleteVertexArray=o=>tt(r,()=>r.deleteVertexArray(o)),this.getVertexArray=()=>tt(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){const r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>tt(e,()=>r.createVertexArrayOES()),this.bindVertexArray=o=>tt(e,()=>r.bindVertexArrayOES(o)),this.deleteVertexArray=o=>tt(e,()=>r.deleteVertexArrayOES(o)),this.getVertexArray=()=>tt(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),xe().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=yy(this.gl,r),co(this.gl,o))this.textureHalfFloatExtension=yy(this.gl,o);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),co(this.gl,i))this.colorBufferHalfFloatExtension=yy(this.gl,i);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",co(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(co(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=tce(this.gl),this.indexBuffer=nce(this.gl),this.framebuffer=Xae(this.gl),this.textureConfig=Bk(this.gl,this.textureHalfFloatExtension)}get debug(){return xe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;tt(e,()=>e.finish()),tt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),tt(e,()=>e.deleteFramebuffer(this.framebuffer)),tt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),tt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),tt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),sce(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),ice(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),rce(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),uce(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,i){this.throwIfDisposed(),cce(this.gl,e,t,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),ace(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),oce(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(zD(this.gl,this.framebuffer),this.outputTexture=null),tt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>fce(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,i,r,o){return pce(this.gl,e,t,s,i,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return dce(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const i=hce(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(xe().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=i.clientWaitSync(r,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},t=r}else xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>mce(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=ece(t));const s=Bae(t);tt(t,()=>t.attachShader(s,this.vertexShader)),tt(t,()=>t.attachShader(s,e)),Uae(t,s);let i;return i=Object.assign(s,{vao:this.createVertexArray()}),this.bindVertexArray(i.vao),tt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(lce(t,i,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&j_(t,i),this.setProgram(i),i}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(tt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&j_(this.gl,this.program)),tt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?qae(this.gl,e,t):Kae(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),tt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),Yae(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[i,r]=$f(t,s);this.setOutputMatrixTextureDriver(e,i,r)}setOutputMatrixWriteRegion(e,t,s,i){this.setOutputMatrixWriteRegionDriver(s,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&j_(this.gl,this.program),vy(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}tt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),tt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=yy(this.gl,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,r),r}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await I3(()=>this.disposed||this.isQueryAvailable(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=gce(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in xe().platform&&(s=xe().platform.setTimeoutCustom.bind(xe().platform)),I3(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),q_(this.gl,e,this.framebuffer),this.debug&&vy(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(q_(this.gl,this.outputTexture,this.framebuffer),this.debug&&vy(this.gl)):zD(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const i=this.gl;q_(i,e,this.framebuffer),this.debug&&vy(i),this.outputTexture=e,tt(i,()=>i.viewport(0,0,t,s)),tt(i,()=>i.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,i){this.throwIfDisposed(),tt(this.gl,()=>this.gl.scissor(e,t,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function gce(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:xce,bincountImpl:iW,bincountReduceImpl:yce,castImpl:vce,ceilImpl:wce,concatImpl:bce,equalImpl:Sce,expImpl:_ce,expm1Impl:Cce,floorImpl:Tce,gatherNdImpl:Ice,gatherV2Impl:Ece,greaterImpl:Mce,greaterEqualImpl:kce,lessImpl:Ace,lessEqualImpl:Nce,linSpaceImpl:Rce,logImpl:Dce,maxImpl:Lce,maximumImpl:Pce,minimumImpl:$ce,multiplyImpl:Fce,negImpl:Oce,notEqualImpl:zce,prodImpl:Bce,raggedGatherImpl:Uce,raggedRangeImpl:Vce,raggedTensorToTensorImpl:Wce,rangeImpl:Gce,rsqrtImpl:Hce,scatterImpl:Xce,sigmoidImpl:jce,simpleAbsImpl:rW,sliceImpl:qce,sparseFillEmptyRowsImpl:Kce,sparseReshapeImpl:Yce,sparseSegmentReductionImpl:oW,sqrtImpl:Zce,stridedSliceImpl:Jce,stringNGramsImpl:Qce,stringSplitImpl:eue,stringToHashBucketFastImpl:tue,subImpl:nue,tileImpl:sue,topKImpl:iue,transposeImpl:Gk,uniqueImpl:rue}=hne;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aW(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function bi(n,e){return e===1?[n]:aW(n,e)}function oue(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aue{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Mi(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=bi("rc",this.rank),s=In(this.rank),i=this.getOutOfBoundsCondition(t),r=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let r=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)r=`${e[e.length-1-o]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lW{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length);let s="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),s+=`
        ${r}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${lue(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Vk():Uk(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function lue(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?lle(["r","c","d"],"inputShape"):Mh(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cue{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,s){const i=GD(t,s),r=HD(e,i,s);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=WD(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[r].shift();return this.usedTextures[r].push(l),l}let a;return i===Xs.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===Xs.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===Xs.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===Xs.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===Xs.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,s,i){if(this.freeTextures==null)return;const r=GD(s,i),o=HD(t,r,i);o in this.freeTextures||(this.freeTextures[o]=[]);const a=WD(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=xe().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function uue(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function WD(n,e,t,s,i){const r=hue(e,s);let o;if(i){const[l,c]=$f(n[0],n[1]);o=l*c}else{const[l,c]=I0(n[0],n[1]);o=l*c}const a=uue(t,r);return o*a}function hue(n,e){switch(n){case Xs.PACKED_2X2_FLOAT32:return nW(e);case Xs.PACKED_2X2_FLOAT16:return sW(e);case Xs.UNPACKED_FLOAT32:return QV(e);case Xs.UNPACKED_FLOAT16:return eW(e);case Xs.PACKED_4X1_UNSIGNED_BYTE:return tW(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function due(n){return xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Xs.PACKED_2X2_FLOAT32:Xs.UNPACKED_FLOAT32:n?Xs.PACKED_2X2_FLOAT16:Xs.UNPACKED_FLOAT16}function GD(n,e){if(n===_r.UPLOAD)return Xs.PACKED_2X2_FLOAT32;if(n===_r.RENDER||n==null)return due(e);if(n===_r.DOWNLOAD||n===_r.PIXELS)return Xs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function HD(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class va{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const yo="if (isnan(x)) return x;",fue="return x;",XD="return abs(x);",pue="return (x >= 0.0) ? x : (exp(x) - 1.0);",mue=yo+`
  return (x < 0.0) ? 0.0 : x;
`,gue=yo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,jl="return x;",xue="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yue="return x;",vue=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,wue=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bue=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Sue="return 1.0 / (1.0 + exp(-1.0 * x));";class nc{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ue{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length);const t=e.length,s=bi("rc",t),i=In(t),r=oue(t,s),o=s.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cue=zz,Tue=1e-7,Iue=1e-4,Sy={};function Eue(n){return n in Sy||(Sy[n]={}),Sy[n]}const Mue=xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),kue=600;function Aue(){return xe().global.screen==null?1024:xe().global.screen.height*xe().global.screen.width*window.devicePixelRatio*kue/1024/1024}class Lb extends uE{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Z_)t=e;else{const s=Xo(xe().getNumber("WEBGL_VERSION"),e);t=new Z_(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Xo(xe().getNumber("WEBGL_VERSION"));t=new Z_(s),this.binaryCache=Eue(xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new cue(this.gpgpu),this.numMBBeforeWarning=Aue(),this.texData=new rO(this,ua())}nextDataId(){return Lb.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,i,r,o){const a=this.makeTensorInfo(t,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,r]},l.texShape=[i,r];const c=wy(t),u=new VD(c,!1,o),h=this.runWebGLProgram(u,[a],s,[[i,r]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,s){if((xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xe().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:s,values:e,usage:_r.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,i,r){if(xe().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:t,usage:_r.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:r,slice:o,shape:a,isPacked:l}=t;if(o!=null){let d;l?d=new nc(a,jl):d=new va(a,jl);const f=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:i}],i),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return s;const c=this.activeTimers!=null;let u;c&&(u=Pi());let h;if(i==="complex64"){const d=this.readSync(r.real.dataId),f=this.readSync(r.imag.dataId);h=ml(d,f)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Pi()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const m=this.pendingRead.get(e);return new Promise(x=>m.push(x))}const t=this.texData.get(e),{values:s,shape:i,slice:r,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(r!=null){let m;l?m=new nc(i,jl):m=new va(i,jl);const x=this.runWebGLProgram(m,[{dataId:e,shape:i,dtype:o}],o),y=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),y}if(s!=null)return this.convertAndCacheOnCPU(e);if(xe().getBool("DEBUG")&&!xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&xe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&xe().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const m=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(m.texture.texture,...xy(i))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const m=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),x=m[0],y=m[1];h=ml(x,y)}else if(c==null)h=this.getValuesFromTexture(e);else{const m=Se(i);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,m)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const m=this.gpgpu.gl;tt(m,()=>m.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(e,h),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(m=>m(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ua().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const s=this.texData.get(e),{values:i,shape:r,slice:o,dtype:a,isPacked:l,texture:c}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let f;l?f=new nc(r,jl):f=new va(r,jl);const m=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:a}],a),x=this.readToGPU(m,t);return this.disposeIntermediateTensorInfo(m),x}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=ua().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>wc(i));return zt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!Pae(s))throw xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:i}=this.texData.get(e),r=Se(t);if(xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),f=this.texData.get(d.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...xy(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(d),m}const o=xe().getBool("WEBGL_PACK")&&i===!0,a=o?wy(t):t,l=o?new Zle(a):new Yle(a),c=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,e();const r=eh(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=eh(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(r);a.kernelMs=M7(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Pi(),endMs:null}}endTimer(e){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Pi(),e)}async getQueryTime(e){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:i,usage:r,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(t,i,r,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Mue){return xe().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Se(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){wr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Cue(e.shape,t)}packedUnaryOp(e,t,s){const i=new nc(e.shape,t),r=this.compileAndRun(i,[e],s);return ua().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=rW(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,XD,e.dtype);const t=new va(e.shape,XD),s=this.compileAndRun(t,[e]);return ua().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&dg(s[0])){const r=s.map(o=>fc(o));i=this.write(r,e,t)}else i=this.write(s,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,s){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new _ue(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new aue(e.shape),s=!0;return this.runWebGLProgram(t,[e],e.dtype,null,s)}packedReshape(e,t){const s=[gf(e.shape),...xf(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},r=[gf(t),...xf(t)],o=new lW(r,s),a=!0,l=[s],c=this.runWebGLProgram(o,[i],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:i,shape:r,dtype:o}=s;if(t!=null){const d=Se(r),f=t[0]*t[1]*4;F(d<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=wy(r);let l;i?l=new Kle(a):l=new qle(a);const c=!0,u=[t!=null?t:xy(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:r,dataId:h.dataId}}runWebGLProgram(e,t,s,i,r=!1,o){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Om.DENSE){const v=o!=null?o:xy(e.outputShape);l.texShape=v.map(w=>w*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Se(a.shape)===0)return l.values=Ks(a.dtype,0),a;const c=[],u=t.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(w.texture==null){if(!e.packedInputs&&Se(v.shape)<=xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!e.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!D1(w.shape,v.shape)){const b=v,S=v.shape;v.shape=w.shape,v=this.packedReshape(v,S),c.push(v),w=this.texData.get(v.dataId),b.shape=S}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=jle(e,u,h),f=this.getAndSaveBinary(d,()=>Hle(this.gpgpu,e,u,h)),m=this.activeTimers!=null;let x;m&&(x=this.startTimer()),xe().get("ENGINE_COMPILE_ONLY")||Xle(this.gpgpu,f,u,h,i),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),m&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const y=xe().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const v=Pi();v-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!xe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&r===!1){const v=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),v}return a}compileAndRun(e,t,s,i,r=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,i,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=de(()=>{if(!xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=xe().getBool("DEBUG");xe().set("DEBUG",!1);const t=this.abs(dn(1e-8)).dataSync()[0];if(xe().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Tue:Iue}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:i,values:r,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=Pi());let h=t.texShape;if(h==null&&(h=Qae(s,l),t.texShape=h),r!=null){const d=wy(s);let f,m=h[1],x=h[0];const y=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(l||!y)&&([m,x]=$f(h[0],h[1])),l?f=new Qle(d,y):f=new VD(d,y);const v=y?[x,m]:h,w=this.makeTensorInfo(v,i),b=this.texData.get(w.dataId);y?b.usage=_r.PIXELS:b.usage=_r.UPLOAD,b.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),m,x,r);const S=[[x,m]],C=!0,E=this.runWebGLProgram(f,[w],i,S,C),k=this.texData.get(E.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(w),c&&(this.uploadWaitMs+=Pi()-u)}else{const d=this.acquireTexture(h,a,i,l);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:i}=s;return t!=null&&(s.values=Nue(t,i)),s.values}acquireTexture(e,t,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*c1(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(r){throw r}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await i4(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(jV(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:s,infLoc:i,nanLoc:r,inShapesLocations:o,inTexShapesLocations:a,outShapeLocation:l,outShapeStridesLocation:c,outTexShapeLocation:u}=JV(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=r,e.inShapesLocations=o,e.inTexShapesLocations=a,e.outShapeLocation=l,e.outShapeStridesLocation=c,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:i,height:r,width:o,channels:a}=e,l=ua().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,t,s,r,o,a);return ua().makeTensorFromDataId(c,t,s,l)}}Lb.nextDataId=0;function Nue(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */jO()&&rz("webgl",()=>new Lb,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hk=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class yf{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Mt(t,s),this.enableShapeUniforms=Mi(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k0=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class A0{constructor(e,t,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Mt(t,s);const r=this.outputShape.length;this.enableShapeUniforms=Mi(r);let o="";if(i)if(r===0||Se(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${In(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=bi("coords",r);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hr(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Rue={kernelName:Lg,backendName:"webgl",kernelFunc:hr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vc(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(r.dataId),a=hr({inputs:{x:s},backend:t}),l=hr({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},r}const Due={kernelName:SE,backendName:"webgl",kernelFunc:Vc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cW="return (a < 0.) ? b * a : a;",uW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Lue(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s,o=t.makeTensorInfo([],"float32",Pc(r,"float32")),a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new A0(uW,i.shape,o.shape):new yf(cW,i.shape,o.shape),l=t.runWebGLProgram(a,[i,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const Pue={kernelName:Ew,backendName:"webgl",kernelFunc:Lue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hW="return (a < 0.) ? b * a : a;",dW=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $ue(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e,r=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new A0(dW,s.shape,i.shape):new yf(hW,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],"float32")}const Fue={kernelName:Xw,backendName:"webgl",kernelFunc:$ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uf="if (isnan(x)) return x;";function en({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:i,backend:r})=>{const{x:o}=i,a=r,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),d=t(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const c=xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new nc(o.shape,e):u=new va(o.shape,n),a.runWebGLProgram(u,[o],l)}}function Js({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:r}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(s&&l.dtype==="complex64"){const m=u.texData.get(l.dataId),x=u.texData.get(c.dataId),[y,v]=[[m.complexTensorInfos.real,x.complexTensorInfos.real],[m.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(b=>{const[S,C]=b,E={dataId:S.dataId,dtype:S.dtype,shape:l.shape},k={dataId:C.dataId,dtype:C.dtype,shape:c.shape},I=new yf(n,l.shape,c.shape);return u.runWebGLProgram(I,[E,k],lr(S.dtype,C.dtype))}),w=Vc({inputs:{real:y,imag:v},backend:u});return u.disposeIntermediateTensorInfo(y),u.disposeIntermediateTensorInfo(v),w}const h=r||lr(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&i!=null){const m=u.texData.get(l.dataId).values,x=u.texData.get(c.dataId).values,y=l.dtype==="string"?ch(m):m,v=l.dtype==="string"?ch(x):x,[w,b]=i(l.shape,c.shape,y,v,h),S=u.makeTensorInfo(b,h),C=u.texData.get(S.dataId);return C.values=w,S}const d=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let f;return d?f=new A0(e,l.shape,c.shape,t):f=new yf(n,l.shape,c.shape),u.runWebGLProgram(f,[l,c],h)}}function zm(n,e=!1){if(n==="linear")return e?yue:fue;if(n==="relu")return e?wue:mue;if(n==="elu")return e?vue:pue;if(n==="relu6")return e?bue:gue;if(n==="prelu")return e?dW:hW;if(n==="leakyrelu")return e?uW:cW;if(n==="sigmoid")return e?Sue:xue;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fW{constructor(e,t,s,i=!1,r=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Mi(this.outputShape.length);const u=i?e[1]:e[2],h=Math.ceil(u/2),d=i?"i * 2, rc.y":"rc.y, i * 2",f=r?"rc.z, i * 2":"i * 2, rc.z",m=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",v="";a&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,v="result = activation(result);");const w=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",S="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(S=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${S};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${x[0]});
          result += (${m[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${v}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class qD{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Mt(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KD="return a * b;";function Xk(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,r=lr(s.dtype,i.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(i.dataId),c=new qD(jD.REAL,s.shape,i.shape),u=new qD(jD.IMAG,s.shape,i.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],d=t.runWebGLProgram(c,h,"float32"),f=t.runWebGLProgram(u,h,"float32"),m=Vc({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}if(t.shouldExecuteOnCPU([s,i])){const a=t.texData.get(s.dataId),l=t.texData.get(i.dataId),[c,u]=Fce(s.shape,i.shape,a.values,l.values,r),h=t.makeTensorInfo(u,r),d=t.texData.get(h.dataId);return d.values=c,h}let o;return xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new A0(KD,s.shape,i.shape):o=new yf(KD,s.shape,i.shape),t.runWebGLProgram(o,[s,i],r)}const Oue={kernelName:Wg,backendName:"webgl",kernelFunc:Xk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zue(n,e,t){const s=[gf(n.shape),...xf(n.shape)],i={dtype:n.dtype,shape:s,dataId:n.dataId},r=[gf(e),...xf(e)],o=new lW(r,s),a=!0,l=[s],c=t.runWebGLProgram(o,[i],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,o=t,a=Se(i.shape),l=aO(r,a),c=Se(l);F(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(i.dataId);return u.isPacked&&!D1(i.shape,l)&&!(u.texture!==null&&D1(u.shape,l))?zue(i,l,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const Bue={kernelName:qw,backendName:"webgl",kernelFunc:Qe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YD{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=e;this.outputShape=[i,o];const a=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${sf(h)?h.toPrecision(2):h}, ones);`}let u="";r%s>0&&(u=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uue{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=e;this.outputShape=[i,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(s/4)*4,h=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let m="";r%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vue(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=yb(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Ah(n,e,t,s){const i=Vue(n.shape);let r=n;for(let o=0;o<i.length;o++){const{inSize:a,windowSize:l,outSize:c}=i[o];let u,h;t==="mean"?u=o===0?new YD({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new YD({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new Uue({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=r,r=s.runWebGLProgram(u,[r],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wue{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const i=In(this.rank),r=Gue(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}}function Gue(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let i=0;i<n.length;i++)s[n[i]]=t[i];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hue{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let u=0;u<s.length;u++)s[u]=e[t[u]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=In(this.rank),r=aW("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=r[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${r[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pb(n,e,t){const s=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hue(n.shape,e):new Wue(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xue(n,e,t,s){const i=e,r=n.shape.length,o=Ut(i,n.shape);let a=o;const l=Wn(a,r),c=l!=null;let u=n;c&&(u=Pb(n,l,s),a=is(a.length,r)),Zs("sum",a,r);const[h,d]=Fs(u.shape,a);let f=h;t&&(f=ms(h,o));const m=Se(d),y=Se(n.shape)/m,v=Qe({inputs:{x:u},attrs:{shape:[y,m]},backend:s}),w=tM(n.dtype),b=Ah(v,w,"sum",s),S=Qe({inputs:{x:b},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(b),c&&s.disposeIntermediateTensorInfo(u),S}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $b(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return Xue(i,r,o,t)}const jue={kernelName:eb,backendName:"webgl",kernelFunc:$b};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ii(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{perm:r}=s,o=t,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[r[u]];let c;if(o.shouldExecuteOnCPU([i])){const h=o.texData.get(i.dataId).values,d=Gk(h,i.shape,i.dtype,r,l);c=o.makeTensorInfo(l,i.dtype);const f=o.texData.get(c.dataId);f.values=d}else c=Pb(i,r,o);return c}const que={kernelName:Hd,backendName:"webgl",kernelFunc:Ii};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pW=1e3;function L1({a:n,b:e,transposeA:t,transposeB:s,backend:i,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],d=s?e.shape[u-1]:e.shape[u-2],f=t?n.shape[c-1]:n.shape[c-2],m=s?e.shape[u-2]:e.shape[u-1],x=n.shape.slice(0,-2),y=e.shape.slice(0,-2),v=Se(x),w=Se(y),S=Mt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,m]);F(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const C=t?[v,h,f]:[v,f,h],E=s?[w,m,d]:[w,d,m],k=Qe({inputs:{x:n},backend:i,attrs:{shape:C}}),I=Qe({inputs:{x:e},backend:i,attrs:{shape:E}}),A=[k,I],N=Math.max(v,w),L=t?k.shape[1]:k.shape[2],V=r!=null,O=o!=null,P=l==="leakyrelu",W=l!=null?zm(l,!0):null,H=V||O||P||W!=null;let Y;if((f===1||m===1)&&L>pW&&H===!1){let $=k,U=I;t&&($=Ii({inputs:{x:k},backend:i,attrs:{perm:[0,2,1]}}),A.push($)),s&&(U=Ii({inputs:{x:I},backend:i,attrs:{perm:[0,2,1]}}),A.push(U));const B=m!==1,X=m===1;let te=$;B&&(te=Qe({inputs:{x:$},backend:i,attrs:{shape:[N,L,1]}}),A.push(te));const oe=m===1?2:1;let ue=U;X&&(ue=Qe({inputs:{x:U},backend:i,attrs:{shape:[N,1,L]}}),A.push(ue));const Q=Xk({inputs:{a:te,b:ue},backend:i});Y=$b({inputs:{x:Q},backend:i,attrs:{axis:oe,keepDims:!0}}),A.push(Q)}else{const $=lr(n.dtype,e.dtype),U=new fW(C,E,[N,f,m],t,s,V,W,O,P),B=[k,I];if(r!=null&&B.push(r),O&&B.push(o),P){const X=i.makeTensorInfo([],"float32",Pc(a,"float32"));B.push(X),A.push(X)}Y=i.runWebGLProgram(U,B,$)}const D=Qe({inputs:{x:Y},backend:i,attrs:{shape:S}});A.push(Y);for(const $ of A)i.disposeIntermediateTensorInfo($);return D}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kue(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;return L1({a:i,b:r,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const Yue={kernelName:u1,backendName:"webgl",kernelFunc:Kue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZD="return abs(x);";function Zue(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const r=t.texData.get(s.dataId),o=rW(r.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let i;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new nc(s.shape,ZD):i=new va(s.shape,ZD),t.runWebGLProgram(i,[s],s.dtype)}const Jue={kernelName:aw,backendName:"webgl",kernelFunc:Zue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Que=yo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,ehe=en({opSnippet:Que}),the={kernelName:pg,backendName:"webgl",kernelFunc:ehe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nhe=yo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,she=en({opSnippet:nhe}),ihe={kernelName:mg,backendName:"webgl",kernelFunc:she};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JD="return a + b;",rhe=Js({opSnippet:JD,packedOpSnippet:JD,supportsComplex:!0,cpuKernelImpl:xce}),ohe={kernelName:kf,backendName:"webgl",kernelFunc:rhe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ahe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`float v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lhe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`vec4 v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return hr({inputs:{x:s[0]},backend:t});if(s.length>xe().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=Av({inputs:s.slice(0,l),backend:t}),u=Av({inputs:s.slice(l),backend:t});return Av({inputs:[c,u],backend:t})}const i=s.map(l=>l.dtype).reduce((l,c)=>lr(l,c)),r=s.map(l=>l.shape),a=xe().getBool("WEBGL_PACK")?new lhe(s[0].shape,r):new ahe(s[0].shape,r);return t.runWebGLProgram(a,s,i)}const che={kernelName:gE,backendName:"webgl",kernelFunc:Av};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Ut(r,i.shape);let c=l;const u=Wn(c,a);let h=i;u!=null&&(h=Ii({inputs:{x:i},backend:t,attrs:{perm:u}}),c=is(c.length,a)),Zs("all",c,a);const[d,f]=Fs(h.shape,c),m=Se(f),x=Qe({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),y=Ah(x,x.dtype,"all",t);let v;if(o){const w=ms(d,l);v=Qe({inputs:{x:y},backend:t,attrs:{shape:w}})}else v=Qe({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),v}const hhe={kernelName:xE,backendName:"webgl",kernelFunc:uhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Ut(r,i.shape);let c=l;const u=Wn(c,a);let h=i;u!=null&&(h=Ii({inputs:{x:i},backend:t,attrs:{perm:u}}),c=is(c.length,a)),Zs("any",c,a);const[d,f]=Fs(h.shape,c),m=Se(f),x=Qe({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),y=Ah(x,x.dtype,"any",t);let v;if(o){const w=ms(d,l);v=Qe({inputs:{x:y},backend:t,attrs:{shape:w}})}else v=Qe({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),v}const fhe={kernelName:yE,backendName:"webgl",kernelFunc:dhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class phe{constructor(e,t,s){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mhe{constructor(e,t,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,F(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=In(l),u=bi("coords",l);let h,d;if(o===1){d=l+1;const I=In(d);h=`
        ${I} sourceLocR = ${I}(${u.join()}, 0);
        ++${u[l-1]};
        ${I} sourceLocG = ${I}(${u.join()}, 0);
        ++${u[l-2]};
        ${I} sourceLocA = ${I}(${u.join()}, 0);
        --${u[l-1]};
        ${I} sourceLocB = ${I}(${u.join()}, 0);
        --${u[l-2]};`}else d=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,d),m="."+f[d-1],x=f.map(I=>"int "+I),y=bi("sourceLocR",d-1).concat("inIdx.r"),v=bi("sourceLocG",d-1).concat("inIdx.g"),w=bi("sourceLocB",d-1).concat("inIdx.b"),b=bi("sourceLocA",d-1).concat("inIdx.a"),S=s==="max"?"greaterThan":"lessThan",C=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${b.join()})));`,E=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=i?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${S}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(n,e,t,s=null){let i=e.shape[0],r=e.shape[1];s!=null&&(i=s.shape[0],r=s.shape[1]);const o=yb(r),a={windowSize:o,inSize:r,batchSize:i,outSize:Math.ceil(r/o)},l=new phe(a,t,s==null),c=[e];s!=null&&c.push(s);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=mW(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function gW(n,e,t,s=null){const i=s!=null?s.shape:e.shape,r=i[i.length-1],o=yb(r),a=new mhe(i,o,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=gW(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function xW(n,e,t,s){const i=[t];if(Zs("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,e.shape.length),!xe().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const r=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),r.push(l));const[c,u]=Fs(l.shape,i),h=Se(u),d=Qe({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});r.push(d);const f=mW(n,d,s);r.push(f);const m=Qe({inputs:{x:f},backend:n,attrs:{shape:c}});return r.forEach(x=>n.disposeIntermediateTensorInfo(x)),m}return gW(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ghe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Ut(r,i.shape);const a=Wn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Ii({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=is(o.length,l.shape.length)),Zs("argMax",[o[0]],l.shape.length);const u=xW(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const xhe={kernelName:lw,backendName:"webgl",kernelFunc:ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Ut(r,i.shape);const a=Wn(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Ii({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=is(o.length,l.shape.length)),Zs("argMin",[o[0]],l.shape.length);const u=xW(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const vhe={kernelName:cw,backendName:"webgl",kernelFunc:yhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const whe=yo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bhe=en({opSnippet:whe}),She={kernelName:gg,backendName:"webgl",kernelFunc:bhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _he=yo+"return log(x + sqrt(x * x + 1.0));",Che=en({opSnippet:_he}),The={kernelName:xg,backendName:"webgl",kernelFunc:Che};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ihe=yo+`
  return atan(x);
`,Ehe=en({opSnippet:Ihe}),Mhe={kernelName:yg,backendName:"webgl",kernelFunc:Ehe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const khe=Hk+`
  return atan(a, b);
`,Ahe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k0+`
  return result;
`,Nhe=Js({opSnippet:khe,packedOpSnippet:Ahe}),Rhe={kernelName:wg,backendName:"webgl",kernelFunc:Nhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dhe=yo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Lhe=en({opSnippet:Dhe}),Phe={kernelName:vg,backendName:"webgl",kernelFunc:Lhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bm{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let w="0.0";if(x||(w="-1.0 / 1e-20"),s){const I=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${f}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?r?y:v:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(S="avgValue / max(count, 1.0)");const C=Math.floor(o/4)*4,E=o%4,k=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${f}, ${m});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${C};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${S});
      }
    `}}class jk{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,x=e.effectiveFilterWidth,y=e.padInfo.front,v=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;const b=t==="avg";let S="0.0";if(b||(S="-1.0 / 1e-20"),s){const N=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${y}, ${v}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${N} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / max(count, 1.0)");const k=Math.floor(o/4)*4,I=o%4,A=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${y}, ${v}, ${w});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${k};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${A}
            }
          }
        }
        setOutput(${E});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $he(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;E0(i,"avgPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;F(ai(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=go(i.shape,r,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&pn(u.inShape,u.outShape))return hr({inputs:{x:i},backend:t});const h=new Bm(u,"avg",!1);return t.runWebGLProgram(h,[i],"float32")}const Fhe={kernelName:uw,backendName:"webgl",kernelFunc:$he};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ohe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s,u=[1,1,1],h=wl(i.shape,r,o,u,a,l,c),d=new jk(h,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const zhe={kernelName:hw,backendName:"webgl",kernelFunc:Ohe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bhe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Uhe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=h-1-e.padInfo.front,x=d-1-e.padInfo.top,y=f-1-e.padInfo.left,v=1/(t*s*i);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${x}, ${y});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vhe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=wl(o.shape,a,l,h,c,u),f=new Uhe(d);return t.runWebGLProgram(f,[i],o.dtype)}const Whe={kernelName:wE,backendName:"webgl",kernelFunc:Vhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ghe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;E0([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=go(o.shape,a,l,1,c),h=new Bhe(u);return t.runWebGLProgram(h,[i],o.dtype)}const Hhe={kernelName:vE,backendName:"webgl",kernelFunc:Ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xhe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;return L1({a:i,b:r,transposeA:o,transposeB:a,backend:t})}const jhe={kernelName:dw,backendName:"webgl",kernelFunc:Xhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qhe{constructor(e,t,s,i,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Mt(e,t),Mt(e,s);let a="0.0";i!=null&&(Mt(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";r!=null&&(Mt(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Khe{constructor(e,t,s,i,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Mt(e,t),Mt(e,s);let a="vec4(0.0)";i!=null&&(Mt(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";r!=null&&(Mt(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yhe=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:i,variance:r,offset:o,scale:a}=n;F(i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,i,r];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const d=xe().getBool("WEBGL_PACK_NORMALIZATION")?new Khe(s.shape,i.shape,r.shape,u,h,l):new qhe(s.shape,i.shape,r.shape,u,h,l);return e.runWebGLProgram(d,c,c[0].dtype)},Zhe={kernelName:Cw,backendName:"webgl",kernelFunc:Yhe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jhe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=In(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Qhe(this.rank);let i;const r=e.map((o,a)=>`sourceLoc.${ST[a]} = start[${a}] + coords.${ST[a]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}}const ST=["x","y","z","w","u","v"];function Qhe(n){if(n===1)return"sourceLoc";if(n<=6)return ST.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ede{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=In(this.rank),s=bi("coords",this.rank),i=bi("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${r})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${o};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${i[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tde(n,e,t,s){const i=s.texData.get(n.dataId),r=s.makeTensorInfo(t,n.dtype),o=s.texData.get(r.dataId);Object.assign(o,i),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=UM(e,mt(n.shape));i.slice&&(a+=i.slice.flatOffset),o.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),r}function Vf(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s,[a,l]=xb(i,r,o);if(OM(i,a,l),Se(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=t.texData.get(i.dataId),d=qce(h.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,d)}const{isPacked:c}=t.texData.get(i.dataId),u=BM(i.shape,a,l);if(c||!u){const h=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ede(l):new Jhe(l),d=[a];return t.runWebGLProgram(h,[i],i.dtype,d)}return t.uploadToGPU(i.dataId),tde(i,a,l,t)}const nde={kernelName:Qw,backendName:"webgl",kernelFunc:Vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sde=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;F(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=r.reduce((w,b)=>w*b),l=p0(i.shape,r,a),c=m0(l.length,r.length),u=g0(i.shape,r,a),h=XM(o,r.length),d=jM(u,o,r.length),f=[],m=Qe({inputs:{x:i},backend:t,attrs:{shape:l}}),x=Ii({inputs:{x:m},backend:t,attrs:{perm:c}}),y=Qe({inputs:{x},backend:t,attrs:{shape:u}}),v=Vf({inputs:{x:y},backend:t,attrs:{begin:h,size:d}});return f.push(m),f.push(x),f.push(y),f.forEach(w=>t.disposeIntermediateTensorInfo(w)),v},ide={kernelName:fw,backendName:"webgl",kernelFunc:sde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=t.readSync(i.dataId),l=t.readSync(r.dataId),c=iW(a,l,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,c)}const ode={kernelName:bE,backendName:"webgl",kernelFunc:rde};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ade(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.readSync(s.dataId),o=t.readSync(i.dataId),a=Mt(Array.from(r),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const lde={kernelName:fO,backendName:"webgl",kernelFunc:ade};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cde="return float(a != b);",yW=Js({opSnippet:cde,cpuKernelImpl:zce,dtype:"bool"}),ude={kernelName:Uw,backendName:"webgl",kernelFunc:yW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return hr({inputs:{x:i.complexTensorInfos.real},backend:t})}const hde={kernelName:HE,backendName:"webgl",kernelFunc:N0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dde="return float(int(x));";function fde(n,e){const t=new va(n.shape,dde),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _T(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return hr({inputs:{x:i},backend:t});const o=Rs(i.shape),a=_T({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=Vc({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(i.dtype==="complex64"){const o=N0({inputs:{input:i},backend:t}),a=_T({inputs:{x:o},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(o),a}if(!lO(i.dtype,r)){const o=hr({inputs:{x:i},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const o=t.texData.get(i.dataId).values,[a,l,c]=vce(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}if(r==="int32")return fde(i,t);if(r==="bool"){const o=t.makeTensorInfo([],"bool",Ks("bool",1)),l=yW({inputs:{a:i,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const pde={kernelName:bg,backendName:"webgl",kernelFunc:_T};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QD="return ceil(x);",mde=en({opSnippet:QD,packedOpSnippet:QD,cpuKernelImpl:wce}),gde={kernelName:Sg,backendName:"webgl",kernelFunc:mde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xde{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yde{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{clipValueMin:r,clipValueMax:o}=s;let a;xe().getBool("WEBGL_PACK_CLIP")?a=new yde(i.shape):a=new xde(i.shape);const l=[[r],[o]];return t.runWebGLProgram(a,[i],i.dtype,l)}const wde={kernelName:_g,backendName:"webgl",kernelFunc:vde};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bde{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eL(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Sde(n){const{inputs:e,backend:t}=n,{x:s}=e,i=t.texData.get(s.dataId),r=new bde(s.shape),o=[eL(s,i.complexTensorInfos.real),eL(s,i.complexTensorInfos.imag)];return t.runWebGLProgram(r,o,o[0].dtype)}const _de={kernelName:pw,backendName:"webgl",kernelFunc:Sde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cde{constructor(e){this.outputShape=[],this.outputShape=Ca(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const i=t.length,r=t[t.length-1];s.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tde{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ca(e,t);const s=this.outputShape,i=s.length,r=In(i),o=bi("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((x,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][t];const c=a[t],u=a.slice(-2),h=a.join();let d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let x=1;x<l.length;x++){const y=l[x-1];d+=`
        if (${c} < ${l[x]}  && ${c} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${_y(a,c,y)}),
            vec2(${_y(u,c,y)}));
        }`}const f=l.length,m=l[l.length-1];d+=`
        return getChannel(
          getT${f}(${_y(a,c,m)}),
          vec2(${_y(u,c,m)}));`,this.userCode=`
      float getValue(${a.map(x=>"int "+x)}) {
        ${d}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i-1]} = ${o[i-1]} + 1;
        if (${o[i-1]} < ${s[i-1]}) {
          result.g = getValue(${o});
        }

        ${o[i-2]} = ${o[i-2]} + 1;
        if (${o[i-2]} < ${s[i-2]}) {
          result.a = getValue(${o});
        }

        ${o[i-1]} = ${o[i-1]} - 1;
        if (${o[i-2]} < ${s[i-2]} &&
            ${o[i-1]} < ${s[i-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function _y(n,e,t){const s=n.indexOf(e);return n.map((r,o)=>o===s?`${r} - ${t}`:r).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fb(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return hr({inputs:{x:i.complexTensorInfos.imag},backend:t})}const Ide={kernelName:FE,backendName:"webgl",kernelFunc:Fb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kp(n,e,t){const s=n[0].dtype;if(s==="complex64"){const f=n.map(w=>N0({inputs:{input:w},backend:t})),m=n.map(w=>Fb({inputs:{input:w},backend:t})),x=Kp(f,e,t),y=Kp(m,e,t),v=Vc({inputs:{real:x,imag:y},backend:t});return f.forEach(w=>t.disposeIntermediateTensorInfo(w)),m.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(y),v}let i=t.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const f=n.map(S=>{const E=[-1,Se(S.shape.slice(e))];return Qe({inputs:{x:S},backend:t,attrs:{shape:E}})}),m=f.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),x=Ca(f.map(S=>S.shape),1),y=f[0].shape[0]===1,v=bce(m,x,s,y),w=Ca(n.map(S=>S.shape),e),b=t.makeTensorInfo(w,s,v);return f.forEach(S=>t.disposeIntermediateTensorInfo(S)),b}const r=n.filter(f=>Se(f.shape)>0),o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const f=o?new va(n[0].shape,jl):new nc(n[0].shape,jl);return t.runWebGLProgram(f,n,s)}const a=xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>a){const f=[];for(let x=0;x<r.length;x+=a){const y=r.slice(x,x+a);f.push(Kp(y,e,t))}const m=Kp(f,e,t);for(const x of f)t.disposeIntermediateTensorInfo(x);return m}if(o){const f=new Tde(r.map(m=>m.shape),e);return t.runWebGLProgram(f,r,s)}const{tensors2D:l,outShape:c}=Ede(r,e,t),u=new Cde(l.map(f=>f.shape)),h=t.runWebGLProgram(u,l,s);l.forEach(f=>t.disposeIntermediateTensorInfo(f));const d=Qe({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),d}function Ede(n,e,t){const s=Ca(n.map(r=>r.shape),e);return{tensors2D:n.map(r=>Qe({inputs:{x:r},attrs:{shape:[-1,Se(r.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Ut(i,e[0].shape)[0],o=e.map(c=>c.shape);WM(o,r);const a=Ca(e.map(c=>c.shape),r);if(Se(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Se(c.shape)>0);return l.length===1?hr({inputs:{x:l[0]},backend:t}):Kp(l,r,t)}const Mde={kernelName:mw,backendName:"webgl",kernelFunc:vW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wW{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,y=e.dataFormat==="channelsLast",v=y?1:2,w=y?2:3,b=y?3:1;let S="",C="";s&&(i?S=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?S=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:S=`
          float activation(float x) {
            ${s}
          }
        `,C="result = activation(result);");const E=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${S}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${C}
        setOutput(result);
      }
    `}}class kde{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bW{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Mi(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<u;y++)d+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;d+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<u;y++)d+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(h+1)/2;y++){const v=y*2;if(d+=`
           xC = xCCorner + ${v*l};
           `,a===1){if(v<u&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,l===1&&v>0?d+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<u)){const w=o%2===0?hE(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:d+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):w===1?d+=`
                     xC${v+1} = xTexelC${v};
                     `:d+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<u&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<u&&(d+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<u&&(d+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<u&&(d+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f="",m="";s&&(i?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:r?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:f=`vec4 activation(vec4 x) {
           ${s}
         }`,m="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${m}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ade{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Mi(this.outputShape.length);const{dataFormat:s}=t,i=Ei(),r=s==="channelsLast",o=r?1:2,a=r?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P1(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function SW({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=s.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,f=t.dataFormat==="channelsLast",m=!1,x=!1;let y;const v=[];if(r!=null){const S=P1(r.shape,f);S!=null&&(r=Qe({inputs:{x:r},backend:s,attrs:{shape:S}}),v.push(r))}if(i!=null){const S=P1(i.shape,f);S!=null&&(i=Qe({inputs:{x:i},backend:s,attrs:{shape:S}}),v.push(i))}if(!((h===1||d===1)&&u>pW)&&c.isPacked&&f&&c.texture!=null&&l[2]%2!==0&&pn(c.shape.slice(-3),l.slice(-3))){const S=l[0]*l[1]*(l[2]+1),C={dataId:n.dataId,shape:[1,S,t.inChannels],dtype:n.dtype},E=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,F(D1(c.shape,C.shape),()=>`packed reshape ${c.shape} to ${C.shape} isn't free`);const k=Qe({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});v.push(k);const I=L1({a:C,b:k,backend:s,transposeA:m,transposeB:x,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o}),A=s.texData.get(I.dataId);F(A.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=E,A.shape=t.outShape,y=hr({inputs:{x:I},backend:s}),y.shape=t.outShape,v.push(I)}else{const S=t.outHeight*t.outWidth,C=Qe({inputs:{x:n},backend:s,attrs:{shape:f?[t.batchSize,S,t.inChannels]:[t.batchSize,t.inChannels,S]}}),E=Qe({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=L1({a:f?C:E,b:f?E:C,transposeA:!f,transposeB:x,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o});y=Qe({inputs:{x:k},backend:s,attrs:{shape:t.outShape}}),v.push(C),v.push(E),v.push(k)}for(const S of v)s.disposeIntermediateTensorInfo(S);return y}function _W({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:f}=t,m=f==="channelsLast",x=l*c*u,y=d*h,v=[t.batchSize,x,y],w=!0,b=!1,S=[];if(r!=null){const D=P1(r.shape,m);D!=null&&(r=Qe({inputs:{x:r},backend:s,attrs:{shape:D}}),S.push(r))}if(i!=null){const D=P1(i.shape,m);D!=null&&(i=Qe({inputs:{x:i},backend:s,attrs:{shape:D}}),S.push(i))}const C=Qe({inputs:{x:e},backend:s,attrs:{shape:[1,x,Se(e.shape)/x]}});S.push(C);const E=new Ade(v,t),k=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],I=s.runWebGLProgram(E,[n],"float32",k),A=Qe({inputs:{x:I},backend:s,attrs:{shape:v}});S.push(I),S.push(A);const N=i!=null,L=r!=null,V=a==="leakyrelu",O=a?zm(a,!0):null,P=new fW(m?A.shape:C.shape,m?C.shape:A.shape,m?[t.batchSize,y,t.outChannels]:[t.batchSize,t.outChannels,y],w,b,N,O,L,V),W=m?[A,C]:[C,A];if(i&&W.push(i),L&&W.push(r),V){const D=s.makeTensorInfo([],"float32",Pc(o,"float32"));W.push(D),S.push(D)}const H=s.runWebGLProgram(P,W,"float32"),Y=Qe({inputs:{x:H},backend:s,attrs:{shape:t.outShape}});S.push(H);for(const D of S)s.disposeIntermediateTensorInfo(D);return Y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s,h=bl(l),d=Ys(i.shape,r.shape,o,c,a,u,!1,h);let f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=SW({x:i,filter:r,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const x=new bW(d),y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];f=t.runWebGLProgram(x,[i,r],"float32",y)}else if(xe().getBool("WEBGL_CONV_IM2COL"))f=_W({x:i,filter:r,convInfo:d,backend:t});else{const x=new wW(d);f=t.runWebGLProgram(x,[i,r],"float32")}const m=Qe({inputs:{x:f},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(f),m}const Rde={kernelName:gw,backendName:"webgl",kernelFunc:Nde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dde{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Lde{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Pde{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $de{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,u=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,h=bl(l),d=Ys(i.shape,u,o,1,a,c,!1,h),f=new Dde(d);return t.runWebGLProgram(f,[i,r],"float32")}const Ode={kernelName:_E,backendName:"webgl",kernelFunc:Fde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s,h=bl(c),d=Ys(o,r.shape,a,1,l,u,!1,h),f=new Lde(d);return t.runWebGLProgram(f,[i,r],"float32")}const Bde={kernelName:xw,backendName:"webgl",kernelFunc:zde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ude(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=$c(i.shape,r.shape,o,l,a),u=new kde(c);return t.runWebGLProgram(u,[i,r],"float32")}const Vde={kernelName:yw,backendName:"webgl",kernelFunc:Ude};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wde(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s,c=$c(i.shape,l,o,1,a),u=new Pde(c);return t.runWebGLProgram(u,[i,r],"float32")}const Gde={kernelName:CE,backendName:"webgl",kernelFunc:Wde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:o,strides:a,inputShape:l}=s,c=$c(l,r.shape,a,1,o),u=new $de(c);return t.runWebGLProgram(u,[i,r],"float32")}const Xde={kernelName:TE,backendName:"webgl",kernelFunc:Hde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jde=Uf+`
  return cos(x);
`,qde=en({opSnippet:jde}),Kde={kernelName:Cg,backendName:"webgl",kernelFunc:qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yde=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Zde=en({opSnippet:Yde}),Jde={kernelName:Tg,backendName:"webgl",kernelFunc:Zde};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qde{constructor(e,t,s,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,d]=s;this.outputShape=[u,h,d,c];const f=i==="bilinear"?1:0,[m,x]=[`${a-1}.0`,`${l-1}.0`],[y,v,w]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[b,S,C]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${S};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const efe=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,u=new Qde(i.shape,r.shape,a,l,c);return t.runWebGLProgram(u,[i,r,o],"float32")},tfe={kernelName:EE,backendName:"webgl",kernelFunc:efe};var Um;(function(n){n.Prod="*",n.Sum="+"})(Um||(Um={}));class tL{constructor(e,t,s,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===Um.Prod?"1.0":"0.0",a=s?o:`getX(${nL(r,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";s?(c=i?`end != ${l-1}`:"end != 0",u=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",u=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${In(r)} coords = getOutputCoords();
        int end = ${sL(r,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${sL(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${nL(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function nL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function sL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CW(n,e,t,s,i,r){const o=e.shape.length,a=Wn([s],o);let l=e;a!=null&&(l=Ii({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=is(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const u=l.shape[c];let h=hr({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const f=new tL(n,l.shape,!1,r),m=[[d]],x=h;h=t.runWebGLProgram(f,[h],h.dtype,m),t.disposeIntermediateTensorInfo(x)}if(i){const d=new tL(n,l.shape,i,r),f=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(f)}if(a!=null){const d=Fc(a),f=Ii({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return CW(Um.Prod,i,t,r,o,a)}const sfe={kernelName:IE,backendName:"webgl",kernelFunc:nfe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ife(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return CW(Um.Sum,i,t,r,o,a)}const rfe={kernelName:vw,backendName:"webgl",kernelFunc:ife};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ofe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s;if(i.shape.length===1){const l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=iW(l,c,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=yce(l,c,o,a);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const afe={kernelName:ME,backendName:"webgl",kernelFunc:ofe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lfe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],h=l*r,d=c*r,f=u/(r*r),m=o==="NHWC"?[a,h,d,f]:[a,f,h,d],x=new lfe(m,r,o);return t.runWebGLProgram(x,[i],i.dtype)}const ufe={kernelName:kE,backendName:"webgl",kernelFunc:cfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TW{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Mi(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";s&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IW{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Mi(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,d=h;let f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<h;v++)f+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;f+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let v=0;v<h;v++)f+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(d+1)/2;v++){const w=v*2;if(f+=`
          xC = xCCorner + ${w*c};
          `,l===1){if(w<h&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,c===1&&w>0?f+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<h)){const b=a%2===0?hE(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,c>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:f+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):b===1?f+=`
                    xC${w+1} = xTexelC${w};
                    `:f+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<h&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<h&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<h&&(f+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<h&&(f+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<h&&(f+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let m="",x="";s&&(i?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:m=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;let u=l;u==null&&(u=[1,1]),F(ai(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=Ys(i.shape,r.shape,o,u,a,c,!0);let d;xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new IW(h):d=new TW(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[i,r],"float32",f)}const dfe={kernelName:ww,backendName:"webgl",kernelFunc:hfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ffe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class pfe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s,h=Ys(i.shape,u,o,a,l,c,!0),d=new ffe(h);return t.runWebGLProgram(d,[i,r],"float32")}const gfe={kernelName:AE,backendName:"webgl",kernelFunc:mfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s,h=Ys(u,r.shape,o,a,l,c,!0),d=new pfe(h);return t.runWebGLProgram(d,[i,r],"float32")}const yfe={kernelName:NE,backendName:"webgl",kernelFunc:xfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vfe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=[...s.shape,...s.shape],r=Se(s.shape),o=Qe({inputs:{x:s},backend:t,attrs:{shape:[r]}}),a=new vfe(r),l=t.runWebGLProgram(a,[o],o.dtype),c=Qe({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const bfe={kernelName:pO,backendName:"webgl",kernelFunc:wfe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sfe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:i,strideHeight:r,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:d}=i;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=c0(i.shape,r.shape,o,a,"NHWC",l);let u;const h=new Sfe(c);u=t.runWebGLProgram(h,[i,r],"float32");const d=Qe({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),d}const Cfe={kernelName:bw,backendName:"webgl",kernelFunc:_fe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tfe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=tk(i,r.length);sk(o.length,l,r);const{path:c,steps:u}=ik(a,l),h=u.length;let d=null,f=o.length;const m=[];for(let x=0;x<h;++x){for(const y of u[x]){const{permutationIndices:v,expandDims:w}=nk(f,l[y]);let b;rk(v)?b=r[y]:(b=Ii({inputs:{x:r[y]},backend:t,attrs:{perm:v}}),m.push(b));const S=b.shape.slice();for(let C=0;C<w.length;++C)S.splice(w[C],0,1);pn(b.shape,S)||(b=Qe({inputs:{x:b},backend:t,attrs:{shape:S}}),m.push(b)),d===null?d=b:(d=Xk({inputs:{a:b,b:d},backend:t}),m.push(d))}x<h-1&&(c[x]>=0&&(d=$b({inputs:{x:d},backend:t,attrs:{axis:c[x]-(o.length-f),keepDims:!1}}),m.push(d)),f--)}for(const x of m)x!==d&&t.disposeIntermediateTensorInfo(x);return d}const Ife={kernelName:mO,backendName:"webgl",kernelFunc:Tfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Efe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Mfe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,kfe=en({opSnippet:Efe,packedOpSnippet:Mfe}),Afe={kernelName:Eg,backendName:"webgl",kernelFunc:kfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nfe="return (b >= 1.0) ? a : a * (b + 1.0);",Rfe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Dfe=n=>{const{inputs:e,backend:t}=n,{dy:s,y:i}=e,r=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new A0(Rfe,s.shape,i.shape):new yf(Nfe,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],s.dtype)},Lfe={kernelName:RE,backendName:"webgl",kernelFunc:Dfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pfe=`
  return vec4(equal(a, b));
`,$fe="return float(a == b);",Ffe=Js({opSnippet:$fe,packedOpSnippet:Pfe,dtype:"bool",cpuKernelImpl:Sce}),Ofe={kernelName:Sw,backendName:"webgl",kernelFunc:Ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zfe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${qM};
  float a1 = ${KM};
  float a2 = ${YM};
  float a3 = ${ZM};
  float a4 = ${JM};
  float a5 = ${QM};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Bfe=en({opSnippet:zfe}),Ufe={kernelName:Mg,backendName:"webgl",kernelFunc:Bfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vfe=Uf+`
  return exp(x);
`,Wfe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,EW=en({opSnippet:Vfe,packedOpSnippet:Wfe,cpuKernelImpl:_ce,dtype:"float32"}),Gfe={kernelName:kg,backendName:"webgl",kernelFunc:EW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CT(n){const{inputs:e,attrs:t,backend:s}=n,{dim:i}=t,{input:r}=e,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(F(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Qe({inputs:{x:r},backend:s,attrs:{shape:a}})}const Hfe={kernelName:_w,backendName:"webgl",kernelFunc:CT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL="return exp(x) - 1.0;",Xfe=en({opSnippet:iL,packedOpSnippet:iL,cpuKernelImpl:Cce}),jfe={kernelName:Ag,backendName:"webgl",kernelFunc:Xfe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rL{constructor(e,t,s){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const r=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${i}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MW(n,e,t){const s=t.texData.get(n.dataId),i=Se(n.shape),r=n.shape[n.shape.length-1],o=i/r,a=Qe({inputs:{x:n},backend:t,attrs:{shape:[o,r]}}),l=a.shape,c=new rL("real",l,e),u=new rL("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(c,h,"float32"),f=t.runWebGLProgram(u,h,"float32"),m=Vc({inputs:{real:d,imag:f},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f);const x=Qe({inputs:{x:m},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(m),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qfe(n){const{inputs:e,backend:t}=n,{input:s}=e;return MW(s,!1,t)}const Kfe={kernelName:DE,backendName:"webgl",kernelFunc:qfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yfe{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0(n){const{backend:e,attrs:t}=n,{shape:s,value:i}=t;let{dtype:r}=t;if(r=r||fg(i),r==="string"){const o=fs(r,Se(s));return o.fill(i),e.makeTensorInfo(s,r,o)}else{const o=new Yfe(s,i),a=[[i]];return e.runWebGLProgram(o,[],r,a)}}const Zfe={kernelName:LE,backendName:"webgl",kernelFunc:R0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jfe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qfe={kernelName:PE,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,i=new Jfe(t.shape);return s.runWebGLProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oL="return floor(x);",epe=en({opSnippet:oL,packedOpSnippet:oL,cpuKernelImpl:Tce}),tpe={kernelName:Ng,backendName:"webgl",kernelFunc:epe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const npe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,spe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,ipe=Js({opSnippet:npe,packedOpSnippet:spe,dtype:"int32"}),rpe={kernelName:Rg,backendName:"webgl",kernelFunc:ipe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ope{constructor(e){this.variableNames=["A"];const t=Ei(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ape{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Ei(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lpe={kernelName:V7,backendName:"webgl",kernelFunc:cpe};let Zh,J_=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function cpe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:i}=e;const{numChannels:r}=s,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],h=[c,l,r];if(a||o){const x=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Zh==null||x!==J_)&&(J_=x,Zh=document.createElement("canvas").getContext("2d",{willReadFrequently:J_})),Zh.canvas.width=l,Zh.canvas.height=c,Zh.drawImage(i,0,0,l,c),i=Zh.canvas}const d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=_r.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),i);const f=xe().getBool("WEBGL_PACK")?new ape(h):new ope(h),m=t.runWebGLProgram(f,[d],"int32");return t.disposeData(d.dataId),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function upe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=s,x=bl(u),y=Ys(i.shape,r.shape,l,h,c,d,!1,x);let v;const w=[],b=o!=null,S=a!=null,C=f==="leakyrelu",E=()=>{const I=[i,r],A=(N,L)=>{if(L==="NCHW"&&N.shape.length===1&&N.shape[0]!==1){const V=Qe({inputs:{x:N},backend:t,attrs:{shape:[N.shape[0],1,1]}});return w.push(V),V}return N};if(b&&I.push(A(o,u)),S&&I.push(A(a,u)),C){const N=t.makeTensorInfo([],"float32",Pc(m,"float32"));I.push(N),w.push(N)}return I};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))v=SW({x:i,filter:r,convInfo:y,backend:t,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else if(y.strideWidth<=2&&x==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){const I=f?zm(f,!0):null,A=new bW(y,b,I,S,C),N=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],L=E();v=t.runWebGLProgram(A,L,"float32",N)}else if(xe().getBool("WEBGL_CONV_IM2COL"))v=_W({x:i,filter:r,convInfo:y,backend:t,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else{const I=f?zm(f,!1):null,A=new wW(y,b,I,S,C),N=E();v=t.runWebGLProgram(A,N,"float32")}const k=Qe({inputs:{x:v},backend:t,attrs:{shape:y.outShape}});return w.push(v),w.forEach(I=>t.disposeIntermediateTensorInfo(I)),k}const hpe={kernelName:h1,backendName:"webgl",kernelFunc:upe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:f}=s,m=[];let x=u;x==null&&(x=[1,1]),F(ai(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const y=Ys(i.shape,r.shape,l,x,c,h,!0),v=xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,w=d?zm(d,v):null,b=[i,r],S=o!=null,C=a!=null,E=d==="leakyrelu";if(S&&b.push(o),C&&b.push(a),E){const N=t.makeTensorInfo([],"float32",Pc(f,"float32"));b.push(N),m.push(N)}let k;v?k=new IW(y,S,w,C,E):k=new TW(y,S,w,C,E);const I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],A=t.runWebGLProgram(k,b,"float32",I);return m.forEach(N=>t.disposeIntermediateTensorInfo(N)),A}const fpe={kernelName:DO,backendName:"webgl",kernelFunc:dpe};class ppe{constructor(e,t,s,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const r=In(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mpe(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=i.shape,o=r[r.length-1],a=Se(s.shape),[l,c,u,h]=FM(s,i),d=Qe({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),f=Qe({inputs:{x:s},backend:t,attrs:{shape:[Se(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const v=t.readSync(i.dataId),w=t.bufferSync(s),b=Ice(v,w,s.dtype,c,o,u,h,s.shape,a);return t.makeTensorInfo(l,s.dtype,b.values)}const m=new ppe(o,h,[c,u],s.shape),x=t.runWebGLProgram(m,[f,d],f.dtype),y=Qe({inputs:{x},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),y}const gpe={kernelName:gO,backendName:"webgl",kernelFunc:mpe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xpe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=In(this.rank),i=ype(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function ype(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n.length;i++)i===2?s.push("index"):s.push(`${t[i]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s,l=Ut(o,i.shape)[0];if(xe().get("DEBUG")){const w=t.readSync(r.dataId),b=i.shape[l];for(let S=0;S<w.length;++S){const C=w[S];F(C<=b-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${b-1}]`)}}const c=ak(i,r,l,a),u=Se(r.shape),h=[],d=Qe({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=Qe({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(f);const m=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const w=t.bufferSync(f),b=t.bufferSync(d),S=Ece(b,w,m);return h.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(c.outputShape,S.dtype,S.values)}const x=new xpe(d.shape,m),y=t.runWebGLProgram(x,[d,f],d.dtype);h.push(y);const v=Qe({inputs:{x:y},backend:t,attrs:{shape:c.outputShape}});return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),v}const vpe={kernelName:Tw,backendName:"webgl",kernelFunc:kW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wpe="return float(a > b);",bpe=`
  return vec4(greaterThan(a, b));
`,Spe=Js({opSnippet:wpe,packedOpSnippet:bpe,cpuKernelImpl:Mce,dtype:"bool"}),_pe={kernelName:Iw,backendName:"webgl",kernelFunc:Spe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cpe="return float(a >= b);",Tpe=`
  return vec4(greaterThanEqual(a, b));
`,Ipe=Js({opSnippet:Cpe,packedOpSnippet:Tpe,dtype:"bool",cpuKernelImpl:kce}),Epe={kernelName:Dg,backendName:"webgl",kernelFunc:Ipe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mpe(n){const{inputs:e,backend:t}=n,{input:s}=e;return MW(s,!0,t)}const kpe={kernelName:$E,backendName:"webgl",kernelFunc:Mpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ape="return float(!isnan(x) && !isinf(x));",Npe=en({opSnippet:Ape,dtype:"bool"}),Rpe={kernelName:Pg,backendName:"webgl",kernelFunc:Npe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dpe="return float(isinf(x));",Lpe=en({opSnippet:Dpe,dtype:"bool"}),Ppe={kernelName:$g,backendName:"webgl",kernelFunc:Lpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $pe="return float(isnan(x));",Fpe=en({opSnippet:$pe,dtype:"bool"}),Ope={kernelName:Fg,backendName:"webgl",kernelFunc:Fpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zpe="return float(a < b);",Bpe=`
  return vec4(lessThan(a, b));
`,Upe=Js({opSnippet:zpe,packedOpSnippet:Bpe,cpuKernelImpl:Ace,dtype:"bool"}),Vpe={kernelName:Mw,backendName:"webgl",kernelFunc:Upe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wpe="return float(a <= b);",Gpe=`
  return vec4(lessThanEqual(a, b));
`,Hpe=Js({opSnippet:Wpe,packedOpSnippet:Gpe,cpuKernelImpl:Nce,dtype:"bool"}),Xpe={kernelName:kw,backendName:"webgl",kernelFunc:Hpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jpe(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=Rce(s,i,r);return e.makeTensorInfo([o.length],"float32",o)}const qpe={kernelName:xO,backendName:"webgl",kernelFunc:jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kpe=Uf+`
  return x < 0.0 ? 0./0. : log(x);
`,Ype=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Zpe=en({opSnippet:Kpe,packedOpSnippet:Ype,cpuKernelImpl:Dce}),Jpe={kernelName:Og,backendName:"webgl",kernelFunc:Zpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qpe=Uf+`
  return log(1.0 + x);
`,eme=en({opSnippet:Qpe}),tme={kernelName:zg,backendName:"webgl",kernelFunc:eme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nme="return float(a >= 1.0 && b >= 1.0);",sme=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,ime=Js({opSnippet:nme,packedOpSnippet:sme,dtype:"bool"}),rme={kernelName:Aw,backendName:"webgl",kernelFunc:ime};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ome="return float(!(x >= 1.0));",ame=en({opSnippet:ome}),lme={kernelName:Nw,backendName:"webgl",kernelFunc:ame};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cme="return float(a >= 1.0 || b >= 1.0);",ume=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,hme=Js({opSnippet:cme,packedOpSnippet:ume,dtype:"bool"}),dme={kernelName:Rw,backendName:"webgl",kernelFunc:hme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fme{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pme{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mme=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s,c=xe().getBool("WEBGL_PACK_NORMALIZATION")?new pme(i.shape,r,o,a,l):new fme(i.shape,r,o,a,l);return t.runWebGLProgram(c,[i],i.dtype)},gme={kernelName:Dw,backendName:"webgl",kernelFunc:mme};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xme{constructor(e,t,s,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=i,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yme=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s,h=new xme(i.shape,a,l,c,u);return t.runWebGLProgram(h,[i,r,o],i.dtype)},vme={kernelName:OE,backendName:"webgl",kernelFunc:yme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wme(n,e,t,s){const i=Se(e),o=Se(n.shape)/i,a=Qe({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),l=Ah(a,n.dtype,"max",s),c=Qe({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AW(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s,a=i.shape.length,l=Ut(r,i.shape);let c=l;const u=Wn(c,a),h=u!=null,d=t.shouldExecuteOnCPU([i]);let f=i;if(h){if(d){const b=t.texData.get(f.dataId).values,S=new Array(a);for(let k=0;k<S.length;k++)S[k]=i.shape[u[k]];const C=Gk(b,i.shape,i.dtype,u,S);f=t.makeTensorInfo(S,i.dtype);const E=t.texData.get(f.dataId);E.values=C}else f=Pb(i,u,t);c=is(c.length,a)}Zs("max",c,a);const[m,x]=Fs(f.shape,c);let y=m;o&&(y=ms(m,l));let v;if(d){const b=t.texData.get(f.dataId).values,S=Lce(b,Se(x),y,i.dtype);v=t.makeTensorInfo(y,i.dtype);const C=t.texData.get(v.dataId);C.values=S}else v=wme(f,x,y,t);return h&&t.disposeIntermediateTensorInfo(f),v}const bme={kernelName:Lw,backendName:"webgl",kernelFunc:AW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sme=Hk+`
  return max(a, b);
`,_me=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k0+`
  return result;
`,Cme=Js({opSnippet:Sme,packedOpSnippet:_me,cpuKernelImpl:Pce}),Tme={kernelName:Bg,backendName:"webgl",kernelFunc:Cme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ime(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;E0(i,"maxPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;F(ai(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=go(i.shape,r,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&pn(u.inShape,u.outShape))return hr({inputs:{x:i},backend:t});const h=new Bm(u,"max",!1);return t.runWebGLProgram(h,[i],i.dtype)}const Eme={kernelName:Pw,backendName:"webgl",kernelFunc:Ime};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mme(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],h=wl(i.shape,r,o,u,a,c,l),d=new jk(h,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const kme={kernelName:$w,backendName:"webgl",kernelFunc:Mme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ame{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=r-1-e.padInfo.top,l=o-1-e.padInfo.left,c=r*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Nme{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=c-1-e.padInfo.top,f=u-1-e.padInfo.left,m=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rme(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=wl(o.shape,a,l,h,c,u),f=new jk(d,"max",!0),m=t.runWebGLProgram(f,[o],o.dtype),x=new Nme(d),y=t.runWebGLProgram(x,[i,m],o.dtype);return t.disposeIntermediateTensorInfo(m),y}const Dme={kernelName:BE,backendName:"webgl",kernelFunc:Rme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lme(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;E0([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=go(a.shape,l,c,1,u,h),f=!0,m=new Bm(d,"max",f),x=t.runWebGLProgram(m,[a],a.dtype),y=new Ame(d),v=t.runWebGLProgram(y,[i,x],a.dtype);return t.disposeIntermediateTensorInfo(x),v}const Pme={kernelName:zE,backendName:"webgl",kernelFunc:Lme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $me(n,e,t,s){let i=new Bm(t,"max",!1);const r=s.runWebGLProgram(i,[n],"float32");i=new Bm(t,"max",!0,!0,e);const o=s.runWebGLProgram(i,[n],"float32");return[r,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fme={kernelName:yO,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=e,l=t;F(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];F(ai(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const u=go(s.shape,i,r,c,o),[h,d]=$me(s,a,u,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ome(n,e,t,s){const i=Se(e),o=Se(n.shape)/i,a=Qe({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),l=Ah(a,"float32","mean",s),c=Qe({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zme={kernelName:Fw,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:i,axis:r}=e,o=t,a=s.shape.length,l=Ut(r,s.shape);let c=l;const u=Wn(c,a),h=u!=null,d=o.shouldExecuteOnCPU([s]),f=[];let m=s;if(h){if(d){const S=o.texData.get(m.dataId).values,C=new Array(a);for(let I=0;I<C.length;I++)C[I]=s.shape[u[I]];const E=Gk(S,s.shape,s.dtype,u,C);m=o.makeTensorInfo(C,s.dtype);const k=o.texData.get(m.dataId);k.values=E}else m=Pb(s,u,o);f.push(m),c=is(c.length,a)}Zs("sum",c,a);const[x,y]=Fs(m.shape,c);let v=x;i&&(v=ms(x,l));const w=Ome(m,y,v,o);for(const b of f)o.disposeIntermediateTensorInfo(b);return w}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bme(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Ut(r,i.shape);let c=l;const u=Wn(c,a);let h=i;u!=null&&(h=Ii({inputs:{x:i},backend:t,attrs:{perm:u}}),c=is(c.length,i.shape.length)),Zs("min",c,a);const[d,f]=Fs(h.shape,c),m=Se(f),x=Qe({inputs:{x:h},backend:t,attrs:{shape:[-1,m]}}),y=Ah(x,x.dtype,"min",t);let v;if(o){const w=ms(d,l);v=Qe({inputs:{x:y},backend:t,attrs:{shape:w}})}else v=Qe({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),v}const Ume={kernelName:Ow,backendName:"webgl",kernelFunc:Bme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vme=Hk+`
  return min(a, b);
`,Wme=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+k0+`
  return result;
`,Gme=Js({opSnippet:Vme,packedOpSnippet:Wme,cpuKernelImpl:$ce}),Hme={kernelName:Ug,backendName:"webgl",kernelFunc:Gme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xme{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const i=e.length,r=In(i),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jme{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((m,x)=>m[0]+e[x]+m[1]);const i=e.length,r=In(i),o=t.map(m=>m[0]).join(","),a=t.map((m,x)=>m[0]+e[x]).join(","),l=bi("rc",i),c=bi("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,d=s==="reflect"?0:1;let f="";if(i===1){const m=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${r} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const m=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${r} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${m}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${m}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[i-1]} += 1;
          if(${u}) {
            ${m}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qme=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:i,mode:r}=t,o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jme(s.shape,i,r):new Xme(s.shape,i,r);return e.runWebGLProgram(o,[s],s.dtype)},Kme={kernelName:zw,backendName:"webgl",kernelFunc:qme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yme=`if (b == 0.0) return NAN;
  return mod(a, b);`,Zme=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+k0+`
  return result;
`,Jme=Js({opSnippet:Yme,packedOpSnippet:Zme}),Qme={kernelName:Vg,backendName:"webgl",kernelFunc:Jme};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ege{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tge=`
if (a == b) {
  return 1.0;
};
return a / b;`,nge=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,NW=Js({opSnippet:tge,packedOpSnippet:nge,checkOutOfBounds:!0}),sge={kernelName:Ig,backendName:"webgl",kernelFunc:NW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aL="return a - b;",RW=Js({opSnippet:aL,packedOpSnippet:aL,supportsComplex:!0,cpuKernelImpl:nue}),ige={kernelName:i0,backendName:"webgl",kernelFunc:RW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DW(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=Ut([r],i.shape),a=AW({inputs:{x:i},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=ms(a.shape,o),c=Qe({inputs:{x:a},backend:t,attrs:{shape:l}}),u=RW({inputs:{a:i,b:c},backend:t}),h=EW({inputs:{x:u},backend:t}),d=$b({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),f=Qe({inputs:{x:d},backend:t,attrs:{shape:l}}),m=NW({inputs:{a:h,b:f},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}const rge={kernelName:sb,backendName:"webgl",kernelFunc:DW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oge(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s,l=a?i:DW({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new ege(c,u,r),d=[[o]],f=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),f}const age={kernelName:vO,backendName:"webgl",kernelFunc:oge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lge=yo+`
  return -x;
`,cge=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function uge(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const r=t.texData.get(s.dataId),[o,a]=Oce(r.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}let i;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new nc(s.shape,cge):i=new va(s.shape,lge),t.runWebGLProgram(i,[s],s.dtype)}const hge={kernelName:Bw,backendName:"webgl",kernelFunc:uge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dge=NM;function fge(n){wr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),{selectedIndices:h}=dge(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const pge={kernelName:UE,backendName:"webgl",kernelFunc:fge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mge=RM;function gge(n){wr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s,u=t.readSync(i.dataId),h=t.readSync(r.dataId),{selectedIndices:d,validOutputs:f}=mge(u,h,o,a,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}const xge={kernelName:VE,backendName:"webgl",kernelFunc:gge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yge=DM;function vge(n){wr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,u=t.readSync(i.dataId),h=t.readSync(r.dataId),d=o,f=a,m=l,x=c,{selectedIndices:y,selectedScores:v}=yge(u,h,d,f,m,x);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const wge={kernelName:WE,backendName:"webgl",kernelFunc:vge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bge{constructor(e,t,s,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sge=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s,c=Se(i.shape),u=new bge(c,o,a,l),h=Qe({inputs:{x:i},backend:t,attrs:{shape:[c]}}),d=t.runWebGLProgram(u,[h],r);t.disposeIntermediateTensorInfo(h);const f=[...i.shape,o],m=Qe({inputs:{x:d},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(d),m},_ge={kernelName:Ww,backendName:"webgl",kernelFunc:Sge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $1(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const i=N0({inputs:{input:s},backend:t}),r=$1({inputs:{x:i},backend:t}),o=Fb({inputs:{input:s},backend:t}),a=$1({inputs:{x:o},backend:t}),l=Vc({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return R0({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const Cge={kernelName:ob,backendName:"webgl",kernelFunc:$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LW(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=N0({inputs:{input:s},backend:t}),r=LW({inputs:{x:i},backend:t}),o=Fb({inputs:{input:s},backend:t}),a=$1({inputs:{x:o},backend:t}),l=Vc({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return R0({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const Tge={kernelName:Vw,backendName:"webgl",kernelFunc:LW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ige(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return CT({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{dE(r,u.shape,"All tensors passed to stack must have matching shapes"),F(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=CT({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=vW({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const Ege={kernelName:Gw,backendName:"webgl",kernelFunc:Ige};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mge{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const i=e.length,r=In(i),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kge{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((x,y)=>x[0]+e[y]+x[1]);const i=e.length,r=In(i),o=t.map(x=>x[0]).join(","),a=t.map((x,y)=>x[0]+e[y]).join(","),l=bi("rc",i),c=bi("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${u}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${u}) {`],f=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let x=0,y=i===1?2:4;x<y;x++)m+=`
        ${d[x]}
        if (${f}) {
          result[${x}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${h});
        }
      `;m+=i===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;if(Se(i.shape)===0){const c=r.map((u,h)=>u[0]+i.shape[h]+u[1]);return R0({backend:t,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kge(i.shape,r,o):new Mge(i.shape,r,o),l=[[o]];return t.runWebGLProgram(a,[i],i.dtype,l)},Age={kernelName:Hw,backendName:"webgl",kernelFunc:PW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nge=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Rge=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+k0+`
  return result;
`,Dge=Js({opSnippet:Nge,packedOpSnippet:Rge}),Lge={kernelName:Gg,backendName:"webgl",kernelFunc:Dge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pge(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=[],c=Ut(r,i.shape);let u=c;const h=Wn(u,a);let d=i;h!=null&&(d=Ii({inputs:{x:i},backend:t,attrs:{perm:h}}),u=is(u.length,a),l.push(d)),Zs("prod",u,a);let f;if(t.shouldExecuteOnCPU([d])){const m=t.texData.get(d.dataId).values,{outVals:x,outShape:y,outDtype:v}=Bce(d.shape,d.dtype,m,u);f=t.makeTensorInfo(y,v,x)}else{const[m,x]=Fs(d.shape,u),y=Se(x),v=Qe({inputs:{x:d},backend:t,attrs:{shape:[-1,y]}}),w=tM(i.dtype),b=Ah(v,w,"prod",t);f=Qe({inputs:{x:b},backend:t,attrs:{shape:m}}),l.push(v),l.push(b)}if(o){l.push(f);const m=ms(f.shape,c);f=Qe({inputs:{x:f},backend:t,attrs:{shape:m}})}return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const $ge={kernelName:jw,backendName:"webgl",kernelFunc:Pge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fge(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=e,{outputRaggedRank:a}=s,l=i.map(v=>t.readSync(v.dataId)),c=i.map(v=>v.shape),u=t.readSync(r.dataId),h=t.readSync(o.dataId),[d,f,m]=Uce(l,c,u,r.shape,r.dtype,h,o.shape,a),x=d.map(v=>t.makeTensorInfo([v.length],"int32",v)),y=t.makeTensorInfo(m,r.dtype,f);return x.concat([y])}const Oge={kernelName:wO,backendName:"webgl",kernelFunc:Fge};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zge(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=Vce(o,s.shape,s.dtype,a,i.shape,l,r.shape),h=t.makeTensorInfo([c.length],"int32",c),d=t.makeTensorInfo([u.length],s.dtype,u);return[h,d]}const Bge={kernelName:bO,backendName:"webgl",kernelFunc:zge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uge(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),h=t.readSync(o.dataId),d=a.map(y=>t.readSync(y.dataId)),f=a.map(y=>y.shape),[m,x]=Wce(c,i.shape,u,r.shape,r.dtype,h,o.shape,d,f,l);return t.makeTensorInfo(m,r.dtype,x)}const Vge={kernelName:SO,backendName:"webgl",kernelFunc:Uge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $W=n=>{const{backend:e,attrs:t}=n,{start:s,stop:i,step:r,dtype:o}=t,a=Gce(s,i,r,o);return e.makeTensorInfo([a.length],o,a)},Wge={kernelName:GE,backendName:"webgl",kernelFunc:$W};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gge="return 1.0 / x;",Hge=en({opSnippet:Gge}),Xge={kernelName:Hg,backendName:"webgl",kernelFunc:Hge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jge=yo+`
  return (x < 0.0) ? 0.0 : x;
`,qge=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Kge=en({opSnippet:jge,packedOpSnippet:qge}),Yge={kernelName:Xg,backendName:"webgl",kernelFunc:Kge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zge=yo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Jge=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qge=en({opSnippet:Zge,packedOpSnippet:Jge}),e0e={kernelName:jg,backendName:"webgl",kernelFunc:Qge};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t0e{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s];let d;r?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n0e{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s];let d;r?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new n0e(i.shape,l,c,r,o):new t0e(i.shape,l,c,r,o);return t.runWebGLProgram(u,[i],"float32")}const i0e={kernelName:Yw,backendName:"webgl",kernelFunc:s0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r0e{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,o,a]=e,l=[s&&o>1?i-1:i,s&&a>1?r-1:r],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,f=1/h,m=Math.ceil(d)*2+2,x=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,a=new r0e(r.shape,i.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const a0e={kernelName:jE,backendName:"webgl",kernelFunc:o0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l0e{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s],d=i?"0.5":"0.0";let f;r?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c0e{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s],d=i?"0.5":"0.0";let f;r?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new c0e(i.shape,l,c,r,o):new l0e(i.shape,l,c,r,o);return t.runWebGLProgram(u,[i],i.dtype)}const h0e={kernelName:Kw,backendName:"webgl",kernelFunc:u0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d0e{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,o,a]=e,l=[s&&o>1?i-1:i,s&&a>1?r-1:r],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,f=1/h,m=Math.ceil(d)*2+2,x=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f0e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,a=new d0e(r.shape,i.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const p0e={kernelName:XE,backendName:"webgl",kernelFunc:f0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m0e{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,r=e.map((a,l)=>i(l)).join(","),o=In(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g0e{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const i=bi("rc",s),r=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,a=In(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${r}){
            result.g = ${c(i.slice())};
          }
          if(${o}) {
            result.b = ${u(i.slice())};
            if(${r}) {
              result.a = ${h(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(m){return d(m)}function c(m){return m[s-1]="("+m[s-1]+" + 1)",d(m)}function u(m){return m[s-2]="("+m[s-2]+" + 1)",d(m)}function h(m){return m[s-1]="("+m[s-1]+" + 1)",m[s-2]="("+m[s-2]+" + 1)",d(m)}function d(m){const x=e.map((w,b)=>f(b,m)),y=x.join(","),v=x.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${v}))`}function f(m,x){return t.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${x[m]} - 1`:`${x[m]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s,o=i.shape.length,a=Ut(r,i.shape);if(o===0)return hr({inputs:{x:i},backend:t});const l=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new g0e(i.shape,a):new m0e(i.shape,a);return t.runWebGLProgram(l,[i],i.dtype)}const y0e={kernelName:Zw,backendName:"webgl",kernelFunc:x0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v0e{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],i=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0e={kernelName:QE,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=new v0e(s.shape,r),[c,u]=HM(o,s.shape[1],s.shape[2]),h=[[c,u,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,S0e=en({opSnippet:b0e}),_0e={kernelName:qg,backendName:"webgl",kernelFunc:S0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C0e="return inversesqrt(x);",T0e=en({opSnippet:C0e,cpuKernelImpl:Hce}),I0e={kernelName:Kg,backendName:"webgl",kernelFunc:T0e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FW{constructor(e,t,s,i,r,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=In(r.length),c=In(o.length);let u="";s===1?u="i":s===2&&(u="i, j");const h=`getIndices(${u})`;let d="";i===1?d="i":i===2&&(d="i, coords[1]");const f=`getUpdates(${d})`,m=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${r});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${m};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0e(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=f0(r,i,o),d=[h/c,c];if(h===0)return t.makeTensorInfo(o,i.dtype);const f=Qe({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),m=Qe({inputs:{x:r},backend:t,attrs:{shape:[l,c]}}),x=t.makeTensorInfo([],"float32",new Float32Array([0])),y=new FW(l,a,f.shape.length,m.shape.length,u,d),v=t.runWebGLProgram(y,[m,f,x],m.dtype),w=Qe({inputs:{x:v},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(x),w}const M0e={kernelName:_O,backendName:"webgl",kernelFunc:E0e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k0e{constructor(e,t,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const r="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=xe().getNumber("WEBGL_VERSION")===2?r:o,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=new k0e(i.shape[0],i.shape[1],r.shape[1],o),l=[[i.shape[1]]];return t.runWebGLProgram(a,[i,r],"int32",l)}const N0e={kernelName:CO,backendName:"webgl",kernelFunc:A0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R0e{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let i,r;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)r="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);i=l.join(),r=c.join()}const o=In(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e,o=new R0e(s.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(o,[s,i,r],lr(i.dtype,r.dtype))}const L0e={kernelName:Jw,backendName:"webgl",kernelFunc:D0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P0e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${vb};
  float scale = ${wb};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,$0e=en({opSnippet:P0e}),F0e={kernelName:Yg,backendName:"webgl",kernelFunc:$0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O0e=Uf+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,z0e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,B0e=en({opSnippet:O0e,packedOpSnippet:z0e,cpuKernelImpl:jce}),U0e={kernelName:e0,backendName:"webgl",kernelFunc:B0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V0e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,W0e=en({opSnippet:V0e}),G0e={kernelName:Qg,backendName:"webgl",kernelFunc:W0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H0e=Uf+`
  return sin(x);
`,X0e=en({opSnippet:H0e}),j0e={kernelName:Zg,backendName:"webgl",kernelFunc:X0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q0e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,K0e=en({opSnippet:q0e}),Y0e={kernelName:Jg,backendName:"webgl",kernelFunc:K0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,J0e=en({opSnippet:Z0e}),Q0e={kernelName:t0,backendName:"webgl",kernelFunc:J0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const exe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;F(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=r.reduce((v,w)=>v*w),l=[[0,0]];l.push(...o);for(let v=1+r.length;v<i.shape.length;++v)l.push([0,0]);const c=[],u=PW({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),h=p0(u.shape,r,a,!1),d=m0(h.length,r.length,!1),f=g0(u.shape,r,a,!1),m=Qe({inputs:{x:u},backend:t,attrs:{shape:h}}),x=Ii({inputs:{x:m},backend:t,attrs:{perm:d}}),y=Qe({inputs:{x},backend:t,attrs:{shape:f}});return c.push(u),c.push(m),c.push(x),c.forEach(v=>t.disposeIntermediateTensorInfo(v)),y},txe={kernelName:tb,backendName:"webgl",kernelFunc:exe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nxe(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=t.readSync(o.dataId)[0],[h,d,f,m,x]=Kce(a,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],i.dtype,f),t.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(y=>Number(y)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const sxe={kernelName:TO,backendName:"webgl",kernelFunc:nxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ixe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(t.readSync(i.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(r.dataId)),[c,u,h]=Yce(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}const rxe={kernelName:IO,backendName:"webgl",kernelFunc:ixe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);const o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=oW(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const axe={kernelName:EO,backendName:"webgl",kernelFunc:oxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lxe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);const o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=oW(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(u,s.dtype,c)}const cxe={kernelName:MO,backendName:"webgl",kernelFunc:lxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uxe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=f0(r,i,a),f=!1;if(r.dtype==="string"){const v=t.bufferSync(i),w=t.bufferSync(r),b=wc(t.readSync(o.dataId)[0]),S=Xce(v,w,a,d,u,c,l,h,b,f);return t.makeTensorInfo(a,S.dtype,S.values)}const m=new FW(c,l,i.shape.length,r.shape.length,h,[d,1],f),x=t.runWebGLProgram(m,[r,i,o],r.dtype),y=Qe({inputs:{x},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(x),y}const hxe={kernelName:kO,backendName:"webgl",kernelFunc:uxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Ut(o,i.shape)[0],l=ok(i,r,a),c=i.shape.length,u=new Array(c).fill(0),h=i.shape.slice();return l.map(d=>{const f=[...h];f[a]=d;const m=Vf({inputs:{x:i},backend:t,attrs:{begin:u,size:f}});return u[a]+=d,m})}const fxe={kernelName:nb,backendName:"webgl",kernelFunc:dxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lL="return sqrt(x);",pxe=en({opSnippet:lL,packedOpSnippet:lL,cpuKernelImpl:Zce}),mxe={kernelName:n0,backendName:"webgl",kernelFunc:pxe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gxe="return x * x;",xxe=en({opSnippet:gxe}),yxe={kernelName:qE,backendName:"webgl",kernelFunc:xxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cL="return (a - b) * (a - b);",vxe=Js({opSnippet:cL,packedOpSnippet:cL}),wxe={kernelName:s0,backendName:"webgl",kernelFunc:vxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bxe({inputs:n,attrs:e,backend:t}){const{x:s}=n,i=yo+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,r=new va(s.shape,i);return t.runWebGLProgram(r,[s],s.dtype)}const Sxe={kernelName:l0,backendName:"webgl",kernelFunc:bxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _xe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,r=In(s.length),o=In(s.length);let a="";if(i===1)a="coords * strides + begin";else{let l=0;a=s.map((c,u)=>(l++,s.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:f,finalShape:m,isIdentity:x,sliceDim0:y,isSimpleSlice:v,begin:w,end:b,strides:S}=VM(i.shape,r,o,a,l,c,u,h,d);let C;if(x)C=Qe({inputs:{x:i},backend:t,attrs:{shape:m}});else if(y||v){F(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const k=zM(w,b,S),I=Vf({inputs:{x:i},backend:t,attrs:{begin:w,size:k}});C=Qe({inputs:{x:I},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(I)}else if(t.shouldExecuteOnCPU([i])){const I=t.readSync(i.dataId),A=zt(i.shape,i.dtype,I),N=Jce(f,A,S,w);C=t.makeTensorInfo(m,i.dtype,N.values)}else{const I=new _xe(w,S,f);C=t.runWebGLProgram(I,[i],i.dtype)}const E=Qe({inputs:{x:C},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(C),E}const Txe={kernelName:KE,backendName:"webgl",kernelFunc:Cxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ixe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.readSync(u.dataId),f=t.readSync(h.dataId),[m,x]=Qce(d,f,i,r,o,a,l,c);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(h.shape,"int32",x)]}const Exe={kernelName:AO,backendName:"webgl",kernelFunc:Ixe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mxe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=eue(a,l,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const kxe={kernelName:NO,backendName:"webgl",kernelFunc:Mxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(r.dataId),a=tue(o,i);return t.makeTensorInfo(r.shape,"int32",a)}const Nxe={kernelName:RO,backendName:"webgl",kernelFunc:Axe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rxe="return tan(x);",Dxe=en({opSnippet:Rxe}),Lxe={kernelName:r0,backendName:"webgl",kernelFunc:Dxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pxe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,$xe=en({opSnippet:Pxe}),Fxe={kernelName:o0,backendName:"webgl",kernelFunc:$xe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oxe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const i=In(this.rank),r=zxe(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function zxe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<n.length;i++)s.push(`imod(${t[i]}, ${n[i]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OW(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;if(i.dtype==="string"||i.shape.length>5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(d=>wc(d)):l,u=zt(i.shape,i.dtype,c),h=sue(u,r);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new Oxe(i.shape,r);return t.runWebGLProgram(o,[i],i.dtype)}const Bxe={kernelName:a0,backendName:"webgl",kernelFunc:OW};class Uxe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Vxe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function su(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function uL(n){let e=1;for(;e<n;)e*=2;return e}function Wxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s,a=xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([i])||u<a||r>l){const N=t.readSync(i.dataId),[L,V]=iue(N,c,i.dtype,r,o);return[t.makeTensorInfo(L.shape,L.dtype,L.values),t.makeTensorInfo(V.shape,V.dtype,V.values)]}if(r===0)return c[c.length-1]=0,[t.makeTensorInfo(c,i.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[i,R0({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(i.dataId),d=h!==null&&h.isPacked,f=d?t.unpackTensor(i):i,x=Se(c)/u,y=Qe({inputs:{x:f},attrs:{shape:[x,u]},backend:t});d&&su(t,f);const v=uL(r),w=uL(u);let b=null;const S=()=>b===null?[y,y]:[y,b],C=(N,L,V)=>{const O=S(),P=new Uxe(V),H=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[N],[L]],Y=b;b=t.runWebGLProgram(P,O,"int32",H),su(t,Y)};for(let N=1;N<v;N*=2){const L=N*2;for(let V=N;V>=1;V/=2)C(L,V,[x,w])}for(let N=w;N>v;N/=2){const L=S(),V=new Vxe([x,N/2]),P=[[u],[b===null?1:0],[v]],W=b;b=t.runWebGLProgram(V,L,"int32",P),su(t,W);const H=v/2,Y=H*2;for(let D=H;D>=1;D/=2)C(Y,D,b.shape)}let E=b;b=Vf({inputs:{x:b},backend:t,attrs:{begin:0,size:[x,r]}}),su(t,E);let k=kW({inputs:{x:y,indices:b},backend:t,attrs:{axis:1,batchDims:1}});su(t,y);const I=c.slice(0,-1);I.push(r),E=b,b=Qe({inputs:{x:b},attrs:{shape:I},backend:t}),su(t,E);const A=k;return k=Qe({inputs:{x:k},attrs:{shape:I},backend:t}),su(t,A),[k,b]}const Gxe={kernelName:YE,backendName:"webgl",kernelFunc:Wxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hxe{constructor(e,t,s,i,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xxe(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[u,h,d,f]=i.shape,[m,x]=c!=null?c:[h,d],y=[u,m,x,f],v=new Hxe(h,d,o,a,l,y);return t.runWebGLProgram(v,[i,r],"float32")}const jxe={kernelName:ZE,backendName:"webgl",kernelFunc:Xxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qxe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;E0(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(r.dataId),{outputValues:a,outputShape:l,indices:c}=rue(o,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const Kxe={kernelName:JE,backendName:"webgl",kernelFunc:qxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yxe(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[r],c=new Array(a-1);let u=0;for(let x=0;x<a;x++)x!==r&&(c[u++]=o.shape[x]);const h=[],d=new Array(a).fill(0),f=o.shape.slice();f[r]=1;const m=new Array(l);for(let x=0;x<m.length;x++){d[r]=x;const y=Vf({inputs:{x:o},backend:t,attrs:{begin:d,size:f}}),v=Qe({inputs:{x:y},backend:t,attrs:{shape:c}});m[x]=v,h.push(y)}return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),m}const Zxe={kernelName:ib,backendName:"webgl",kernelFunc:Yxe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jxe{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,i=e.batchSize,r=e.inSize,o=e.numSegments,a=o*Math.ceil(r/s);this.outputShape=[i,a];const l="0.0",c="sumValue",u=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let f="";r%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let m="";r%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s,a=i.shape.length,l=[];let c=0;const u=Wn([c],a);let h=i;u!=null&&(h=Ii({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(h),c=is(1,a)[0]);const d=E4(h.shape,c,o),f=Se([h.shape[c]]),m=Qe({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}});l.push(m);const x=tM(i.dtype),y=(S,C,E,k,I)=>{const A=S.shape[0],N=S.shape[1],L=I4(N,I),V={windowSize:L,inSize:N,batchSize:A,numSegments:I},O=new Jxe(V,C),P=t.compileAndRun(O,[S,E],k);if(l.push(P),P.shape[1]===I)return P;const W=$W({backend:t,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),H=OW({inputs:{x:W},backend:t,attrs:{reps:[N/L]}});return l.push(W),l.push(H),y(P,C,H,k,I)},v=y(m,"unsortedSegmentSum",r,x,o),w=Qe({inputs:{x:v},backend:t,attrs:{shape:d}});let b=w;if(u!=null){l.push(w);const S=Fc(u);b=Ii({inputs:{x:b},backend:t,attrs:{perm:S}})}return l.forEach(S=>t.disposeIntermediateTensorInfo(S)),b}const eye={kernelName:rb,backendName:"webgl",kernelFunc:Qxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tye=[Yue,Jue,the,ihe,ohe,che,hhe,fhe,xhe,vhe,She,The,Mhe,Rhe,Phe,Fhe,zhe,Whe,Hhe,jhe,Zhe,ide,ode,lde,pde,gde,wde,Due,_de,Mde,Rde,Ode,Bde,Vde,Gde,Xde,Kde,Jde,tfe,sfe,rfe,afe,ufe,dfe,gfe,yfe,bfe,Cfe,Ife,Afe,Lfe,Ofe,Ufe,Gfe,Hfe,jfe,Kfe,Zfe,Qfe,tpe,rpe,lpe,hpe,fpe,gpe,vpe,_pe,Epe,Rue,kpe,Ide,Rpe,Ppe,Ope,Pue,Vpe,Xpe,qpe,Jpe,tme,rme,lme,dme,gme,vme,bme,Tme,Eme,kme,Dme,Pme,Fme,zme,Ume,Hme,Kme,Qme,age,Oue,hge,pge,xge,wge,ude,_ge,Tge,Ege,Age,Lge,Fue,$ge,Oge,Bge,Vge,Wge,hde,sge,Xge,Yge,e0e,Bue,i0e,a0e,h0e,p0e,y0e,w0e,_0e,I0e,M0e,N0e,L0e,F0e,U0e,G0e,j0e,Y0e,nde,rge,Q0e,txe,sxe,rxe,axe,cxe,hxe,fxe,mxe,yxe,wxe,Sxe,Txe,Exe,kxe,Nxe,ige,jue,Lxe,Fxe,Bxe,Gxe,jxe,que,Kxe,Zxe,eye,Cge];for(const n of tye)LO(n);/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zW={inputSize:28*28,nClasses:10,hiddenLayerSizes:[16,16]},nye=(n=zW)=>{const e=Uee();return e.add(X_({inputShape:[n.inputSize],units:n.hiddenLayerSizes[0],activation:"relu"})),n.hiddenLayerSizes.slice(1).forEach(t=>{e.add(X_({units:t,kernelInitializer:"varianceScaling",activation:"relu"}))}),e.add(X_({units:n.nClasses,kernelInitializer:"varianceScaling",activation:"softmax"})),e},sye=()=>{const n=Math.floor(Math.random()*Zp.outputs.length),e=Zp.inputs[n],t=Zp.outputs[n];return[lm([e],[1,e.length]),Oi([t],"int32")]},iye=async(n,e,t)=>{const s=Zp.inputs,i=Zp.outputs;E7(s,i);const r=lm(s),o=yM(Oi(i,"int32"),10),a=mu.adam();n.compile({optimizer:a,loss:"categoricalCrossentropy",metrics:["accuracy"]});let l=await n.fit(r,o,{shuffle:!0,validationSplit:.2,batchSize:512,epochs:e,callbacks:{onEpochEnd:t}});return r.dispose(),o.dispose(),l};/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Ob="147",gu={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},xu={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},BW=0,TT=1,UW=2,rye=3,VW=0,zb=1,um=2,Au=3,fh=0,Er=1,sl=2,ll=0,Uu=1,IT=2,ET=3,MT=4,WW=5,Su=100,GW=101,HW=102,kT=103,AT=104,XW=200,jW=201,qW=202,KW=203,qk=204,Kk=205,YW=206,ZW=207,JW=208,QW=209,eG=210,tG=0,nG=1,sG=2,F1=3,iG=4,rG=5,oG=6,aG=7,D0=0,lG=1,cG=2,Uo=0,uG=1,hG=2,dG=3,Yk=4,fG=5,Bb=300,Ec=301,Mc=302,Vm=303,Wm=304,Wf=306,Gm=1e3,Si=1001,Hm=1002,ws=1003,O1=1004,oye=1004,z1=1005,aye=1005,us=1006,Zk=1007,lye=1007,Nh=1008,cye=1008,kc=1009,pG=1010,mG=1011,Jk=1012,gG=1013,sc=1014,il=1015,vf=1016,xG=1017,yG=1018,Vu=1020,vG=1021,wG=1022,br=1023,bG=1024,SG=1025,gc=1026,ph=1027,_G=1028,CG=1029,TG=1030,IG=1031,EG=1033,Nv=33776,Rv=33777,Dv=33778,Lv=33779,NT=35840,RT=35841,DT=35842,LT=35843,MG=36196,PT=37492,$T=37496,FT=37808,OT=37809,zT=37810,BT=37811,UT=37812,VT=37813,WT=37814,GT=37815,HT=37816,XT=37817,jT=37818,qT=37819,KT=37820,YT=37821,ZT=36492,kG=2200,AG=2201,NG=2202,Xm=2300,jm=2301,Pv=2302,Nu=2400,Ru=2401,qm=2402,Ub=2500,Qk=2501,uye=0,hye=1,dye=2,gl=3e3,En=3001,RG=3200,DG=3201,Wc=0,LG=1,fye="",No="srgb",wf="srgb-linear",pye=0,$v=7680,mye=7681,gye=7682,xye=7683,yye=34055,vye=34056,wye=5386,bye=512,Sye=513,_ye=514,Cye=515,Tye=516,Iye=517,Eye=518,PG=519,Km=35044,Mye=35048,kye=35040,Aye=35045,Nye=35049,Rye=35041,Dye=35046,Lye=35050,Pye=35042,$ye="100",JT="300 es",B1=1035;class Na{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,e);e.target=null}}}const mi=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let hL=1234567;const Wu=Math.PI/180,Ym=180/Math.PI;function Mr(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(mi[n&255]+mi[n>>8&255]+mi[n>>16&255]+mi[n>>24&255]+"-"+mi[e&255]+mi[e>>8&255]+"-"+mi[e>>16&15|64]+mi[e>>24&255]+"-"+mi[t&63|128]+mi[t>>8&255]+"-"+mi[t>>16&255]+mi[t>>24&255]+mi[s&255]+mi[s>>8&255]+mi[s>>16&255]+mi[s>>24&255]).toLowerCase()}function hs(n,e,t){return Math.max(e,Math.min(t,n))}function eA(n,e){return(n%e+e)%e}function Fye(n,e,t,s,i){return s+(n-e)*(i-s)/(t-e)}function Oye(n,e,t){return n!==e?(t-n)/(e-n):0}function hm(n,e,t){return(1-t)*n+t*e}function zye(n,e,t,s){return hm(n,e,1-Math.exp(-t*s))}function Bye(n,e=1){return e-Math.abs(eA(n,e*2)-e)}function Uye(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function Vye(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function Wye(n,e){return n+Math.floor(Math.random()*(e-n+1))}function Gye(n,e){return n+Math.random()*(e-n)}function Hye(n){return n*(.5-Math.random())}function Xye(n){n!==void 0&&(hL=n);let e=hL+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function jye(n){return n*Wu}function qye(n){return n*Ym}function QT(n){return(n&n-1)===0&&n!==0}function $G(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function U1(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function Kye(n,e,t,s,i){const r=Math.cos,o=Math.sin,a=r(t/2),l=o(t/2),c=r((e+s)/2),u=o((e+s)/2),h=r((e-s)/2),d=o((e-s)/2),f=r((s-e)/2),m=o((s-e)/2);switch(i){case"XYX":n.set(a*u,l*h,l*d,a*c);break;case"YZY":n.set(l*d,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*d,a*u,a*c);break;case"XZX":n.set(a*u,l*m,l*f,a*c);break;case"YXY":n.set(l*f,a*u,l*m,a*c);break;case"ZYZ":n.set(l*m,l*f,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function rl(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function bn(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}var tA=Object.freeze({__proto__:null,DEG2RAD:Wu,RAD2DEG:Ym,generateUUID:Mr,clamp:hs,euclideanModulo:eA,mapLinear:Fye,inverseLerp:Oye,lerp:hm,damp:zye,pingpong:Bye,smoothstep:Uye,smootherstep:Vye,randInt:Wye,randFloat:Gye,randFloatSpread:Hye,seededRandom:Xye,degToRad:jye,radToDeg:qye,isPowerOfTwo:QT,ceilPowerOfTwo:$G,floorPowerOfTwo:U1,setQuaternionFromProperEuler:Kye,normalize:bn,denormalize:rl});class Ae{constructor(e=0,t=0){Ae.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6],this.y=i[1]*t+i[4]*s+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),i=Math.sin(t),r=this.x-e.x,o=this.y-e.y;return this.x=r*s-o*i+e.x,this.y=r*i+o*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class zi{constructor(){zi.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(e,t,s,i,r,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=a,u[3]=t,u[4]=r,u[5]=l,u[6]=s,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,o=s[0],a=s[3],l=s[6],c=s[1],u=s[4],h=s[7],d=s[2],f=s[5],m=s[8],x=i[0],y=i[3],v=i[6],w=i[1],b=i[4],S=i[7],C=i[2],E=i[5],k=i[8];return r[0]=o*x+a*w+l*C,r[3]=o*y+a*b+l*E,r[6]=o*v+a*S+l*k,r[1]=c*x+u*w+h*C,r[4]=c*y+u*b+h*E,r[7]=c*v+u*S+h*k,r[2]=d*x+f*w+m*C,r[5]=d*y+f*b+m*E,r[8]=d*v+f*S+m*k,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-s*r*u+s*a*l+i*r*c-i*o*l}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,d=a*l-u*r,f=c*r-o*l,m=t*h+s*d+i*f;if(m===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/m;return e[0]=h*x,e[1]=(i*c-u*s)*x,e[2]=(a*s-i*o)*x,e[3]=d*x,e[4]=(u*t-i*l)*x,e[5]=(i*r-a*t)*x,e[6]=f*x,e[7]=(s*l-c*t)*x,e[8]=(o*t-s*r)*x,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,i,r,o,a){const l=Math.cos(r),c=Math.sin(r);return this.set(s*l,s*c,-s*(l*o+c*a)+o+e,-i*c,i*l,-i*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(Q_.makeScale(e,t)),this}rotate(e){return this.premultiply(Q_.makeRotation(-e)),this}translate(e,t){return this.premultiply(Q_.makeTranslation(e,t)),this}makeTranslation(e,t){return this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<9;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const Q_=new zi;function FG(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const Yye={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Ld(n,e){return new Yye[n](e)}function Zm(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function Gu(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Fv(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}const eC={[No]:{[wf]:Gu},[wf]:{[No]:Fv}},gi={legacyMode:!0,get workingColorSpace(){return wf},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(eC[e]&&eC[e][t]!==void 0){const s=eC[e][t];return n.r=s(n.r),n.g=s(n.g),n.b=s(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},OG={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ms={r:0,g:0,b:0},To={h:0,s:0,l:0},Cy={h:0,s:0,l:0};function tC(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function Ty(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}class Je{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,t===void 0&&s===void 0?this.set(e):this.setRGB(e,t,s)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=No){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,gi.toWorkingColorSpace(this,t),this}setRGB(e,t,s,i=gi.workingColorSpace){return this.r=e,this.g=t,this.b=s,gi.toWorkingColorSpace(this,i),this}setHSL(e,t,s,i=gi.workingColorSpace){if(e=eA(e,1),t=hs(t,0,1),s=hs(s,0,1),t===0)this.r=this.g=this.b=s;else{const r=s<=.5?s*(1+t):s+t-s*t,o=2*s-r;this.r=tC(o,r,e+1/3),this.g=tC(o,r,e),this.b=tC(o,r,e-1/3)}return gi.toWorkingColorSpace(this,i),this}setStyle(e,t=No){function s(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,gi.toWorkingColorSpace(this,t),s(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,gi.toWorkingColorSpace(this,t),s(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(r[1])/360,c=parseFloat(r[2])/100,u=parseFloat(r[3])/100;return s(r[4]),this.setHSL(l,c,u,t)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],o=r.length;if(o===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,gi.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,gi.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=No){const s=OG[e.toLowerCase()];return s!==void 0?this.setHex(s,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Gu(e.r),this.g=Gu(e.g),this.b=Gu(e.b),this}copyLinearToSRGB(e){return this.r=Fv(e.r),this.g=Fv(e.g),this.b=Fv(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=No){return gi.fromWorkingColorSpace(Ty(this,Ms),e),hs(Ms.r*255,0,255)<<16^hs(Ms.g*255,0,255)<<8^hs(Ms.b*255,0,255)<<0}getHexString(e=No){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=gi.workingColorSpace){gi.fromWorkingColorSpace(Ty(this,Ms),t);const s=Ms.r,i=Ms.g,r=Ms.b,o=Math.max(s,i,r),a=Math.min(s,i,r);let l,c;const u=(a+o)/2;if(a===o)l=0,c=0;else{const h=o-a;switch(c=u<=.5?h/(o+a):h/(2-o-a),o){case s:l=(i-r)/h+(i<r?6:0);break;case i:l=(r-s)/h+2;break;case r:l=(s-i)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=gi.workingColorSpace){return gi.fromWorkingColorSpace(Ty(this,Ms),t),e.r=Ms.r,e.g=Ms.g,e.b=Ms.b,e}getStyle(e=No){return gi.fromWorkingColorSpace(Ty(this,Ms),e),e!==No?`color(${e} ${Ms.r} ${Ms.g} ${Ms.b})`:`rgb(${Ms.r*255|0},${Ms.g*255|0},${Ms.b*255|0})`}offsetHSL(e,t,s){return this.getHSL(To),To.h+=e,To.s+=t,To.l+=s,this.setHSL(To.h,To.s,To.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(To),e.getHSL(Cy);const s=hm(To.h,Cy.h,t),i=hm(To.s,Cy.s,t),r=hm(To.l,Cy.l,t);return this.setHSL(s,i,r),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}Je.NAMES=OG;let Jh;class nA{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Jh===void 0&&(Jh=Zm("canvas")),Jh.width=e.width,Jh.height=e.height;const s=Jh.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),t=Jh}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=Zm("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const i=s.getImageData(0,0,e.width,e.height),r=i.data;for(let o=0;o<r.length;o++)r[o]=Gu(r[o]/255)*255;return s.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(Gu(t[s]/255)*255):t[s]=Gu(t[s]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class Du{constructor(e=null){this.isSource=!0,this.uuid=Mr(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?r.push(nC(i[o].image)):r.push(nC(i[o]))}else r=nC(i);s.url=r}return t||(e.images[this.uuid]=s),s}}function nC(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?nA.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Zye=0;class ns extends Na{constructor(e=ns.DEFAULT_IMAGE,t=ns.DEFAULT_MAPPING,s=Si,i=Si,r=us,o=Nh,a=br,l=kc,c=ns.DEFAULT_ANISOTROPY,u=gl){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Zye++}),this.uuid=Mr(),this.name="",this.source=new Du(e),this.mipmaps=[],this.mapping=t,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Ae(0,0),this.repeat=new Ae(1,1),this.center=new Ae(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new zi,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Bb)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Gm:e.x=e.x-Math.floor(e.x);break;case Si:e.x=e.x<0?0:1;break;case Hm:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Gm:e.y=e.y-Math.floor(e.y);break;case Si:e.y=e.y<0?0:1;break;case Hm:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}ns.DEFAULT_IMAGE=null;ns.DEFAULT_MAPPING=Bb;ns.DEFAULT_ANISOTROPY=1;class rn{constructor(e=0,t=0,s=0,i=1){rn.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=this.w,o=e.elements;return this.x=o[0]*t+o[4]*s+o[8]*i+o[12]*r,this.y=o[1]*t+o[5]*s+o[9]*i+o[13]*r,this.z=o[2]*t+o[6]*s+o[10]*i+o[14]*r,this.w=o[3]*t+o[7]*s+o[11]*i+o[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,i,r;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],f=l[5],m=l[9],x=l[2],y=l[6],v=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-x)<.01&&Math.abs(m-y)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+x)<.1&&Math.abs(m+y)<.1&&Math.abs(c+f+v-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const b=(c+1)/2,S=(f+1)/2,C=(v+1)/2,E=(u+d)/4,k=(h+x)/4,I=(m+y)/4;return b>S&&b>C?b<.01?(s=0,i=.707106781,r=.707106781):(s=Math.sqrt(b),i=E/s,r=k/s):S>C?S<.01?(s=.707106781,i=0,r=.707106781):(i=Math.sqrt(S),s=E/i,r=I/i):C<.01?(s=.707106781,i=.707106781,r=0):(r=Math.sqrt(C),s=k/r,i=I/r),this.set(s,i,r,t),this}let w=Math.sqrt((y-m)*(y-m)+(h-x)*(h-x)+(d-u)*(d-u));return Math.abs(w)<.001&&(w=1),this.x=(y-m)/w,this.y=(h-x)/w,this.z=(d-u)/w,this.w=Math.acos((c+f+v-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class mo extends Na{constructor(e=1,t=1,s={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new rn(0,0,e,t),this.scissorTest=!1,this.viewport=new rn(0,0,e,t);const i={width:e,height:t,depth:1};this.texture=new ns(i,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=s.generateMipmaps!==void 0?s.generateMipmaps:!1,this.texture.internalFormat=s.internalFormat!==void 0?s.internalFormat:null,this.texture.minFilter=s.minFilter!==void 0?s.minFilter:us,this.depthBuffer=s.depthBuffer!==void 0?s.depthBuffer:!0,this.stencilBuffer=s.stencilBuffer!==void 0?s.stencilBuffer:!1,this.depthTexture=s.depthTexture!==void 0?s.depthTexture:null,this.samples=s.samples!==void 0?s.samples:0}setSize(e,t,s=1){(this.width!==e||this.height!==t||this.depth!==s)&&(this.width=e,this.height=t,this.depth=s,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=s,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Du(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class L0 extends ns{constructor(e=null,t=1,s=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=ws,this.minFilter=ws,this.wrapR=Si,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Jye extends mo{constructor(e=1,t=1,s=1){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=s,this.texture=new L0(null,e,t,s),this.texture.isRenderTargetTexture=!0}}class Vb extends ns{constructor(e=null,t=1,s=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=ws,this.minFilter=ws,this.wrapR=Si,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Qye extends mo{constructor(e=1,t=1,s=1){super(e,t),this.isWebGL3DRenderTarget=!0,this.depth=s,this.texture=new Vb(null,e,t,s),this.texture.isRenderTargetTexture=!0}}class eve extends mo{constructor(e=1,t=1,s=1,i={}){super(e,t,i),this.isWebGLMultipleRenderTargets=!0;const r=this.texture;this.texture=[];for(let o=0;o<s;o++)this.texture[o]=r.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){this.width=e,this.height=t,this.depth=s;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=s;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,s=e.texture.length;t<s;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class _i{constructor(e=0,t=0,s=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=i}static slerpFlat(e,t,s,i,r,o,a){let l=s[i+0],c=s[i+1],u=s[i+2],h=s[i+3];const d=r[o+0],f=r[o+1],m=r[o+2],x=r[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=f,e[t+2]=m,e[t+3]=x;return}if(h!==x||l!==d||c!==f||u!==m){let y=1-a;const v=l*d+c*f+u*m+h*x,w=v>=0?1:-1,b=1-v*v;if(b>Number.EPSILON){const C=Math.sqrt(b),E=Math.atan2(C,v*w);y=Math.sin(y*E)/C,a=Math.sin(a*E)/C}const S=a*w;if(l=l*y+d*S,c=c*y+f*S,u=u*y+m*S,h=h*y+x*S,y===1-a){const C=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=C,c*=C,u*=C,h*=C}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,s,i,r,o){const a=s[i],l=s[i+1],c=s[i+2],u=s[i+3],h=r[o],d=r[o+1],f=r[o+2],m=r[o+3];return e[t]=a*m+u*h+l*f-c*d,e[t+1]=l*m+u*d+c*h-a*f,e[t+2]=c*m+u*f+a*d-l*h,e[t+3]=u*m-a*h-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,i){return this._x=e,this._y=t,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const s=e._x,i=e._y,r=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(s/2),u=a(i/2),h=a(r/2),d=l(s/2),f=l(i/2),m=l(r/2);switch(o){case"XYZ":this._x=d*u*h+c*f*m,this._y=c*f*h-d*u*m,this._z=c*u*m+d*f*h,this._w=c*u*h-d*f*m;break;case"YXZ":this._x=d*u*h+c*f*m,this._y=c*f*h-d*u*m,this._z=c*u*m-d*f*h,this._w=c*u*h+d*f*m;break;case"ZXY":this._x=d*u*h-c*f*m,this._y=c*f*h+d*u*m,this._z=c*u*m+d*f*h,this._w=c*u*h-d*f*m;break;case"ZYX":this._x=d*u*h-c*f*m,this._y=c*f*h+d*u*m,this._z=c*u*m-d*f*h,this._w=c*u*h+d*f*m;break;case"YZX":this._x=d*u*h+c*f*m,this._y=c*f*h+d*u*m,this._z=c*u*m-d*f*h,this._w=c*u*h-d*f*m;break;case"XZY":this._x=d*u*h-c*f*m,this._y=c*f*h-d*u*m,this._z=c*u*m+d*f*h,this._w=c*u*h+d*f*m;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,i=Math.sin(s);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],i=t[4],r=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=s+a+h;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(u-l)*f,this._y=(r-c)*f,this._z=(o-i)*f}else if(s>a&&s>h){const f=2*Math.sqrt(1+s-a-h);this._w=(u-l)/f,this._x=.25*f,this._y=(i+o)/f,this._z=(r+c)/f}else if(a>h){const f=2*Math.sqrt(1+a-s-h);this._w=(r-c)/f,this._x=(i+o)/f,this._y=.25*f,this._z=(l+u)/f}else{const f=2*Math.sqrt(1+h-s-a);this._w=(o-i)/f,this._x=(r+c)/f,this._y=(l+u)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(hs(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const i=Math.min(1,t/s);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,i=e._y,r=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=s*u+o*a+i*c-r*l,this._y=i*u+o*l+r*a-s*c,this._z=r*u+o*c+s*l-i*a,this._w=o*u-s*a-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,i=this._y,r=this._z,o=this._w;let a=o*e._w+s*e._x+i*e._y+r*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=s,this._y=i,this._z=r,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-t;return this._w=f*o+t*this._w,this._x=f*s+t*this._x,this._y=f*i+t*this._y,this._z=f*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*h+this._w*d,this._x=s*h+this._x*d,this._y=i*h+this._y*d,this._z=r*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=Math.random(),t=Math.sqrt(1-e),s=Math.sqrt(e),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(i),s*Math.sin(r),s*Math.cos(r),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class G{constructor(e=0,t=0,s=0){G.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(dL.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(dL.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6]*i,this.y=r[1]*t+r[4]*s+r[7]*i,this.z=r[2]*t+r[5]*s+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=e.elements,o=1/(r[3]*t+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*s+r[8]*i+r[12])*o,this.y=(r[1]*t+r[5]*s+r[9]*i+r[13])*o,this.z=(r[2]*t+r[6]*s+r[10]*i+r[14])*o,this}applyQuaternion(e){const t=this.x,s=this.y,i=this.z,r=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*i-a*s,u=l*s+a*t-r*i,h=l*i+r*s-o*t,d=-r*t-o*s-a*i;return this.x=c*l+d*-r+u*-a-h*-o,this.y=u*l+d*-o+h*-r-c*-a,this.z=h*l+d*-a+c*-o-u*-r,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*s+r[8]*i,this.y=r[1]*t+r[5]*s+r[9]*i,this.z=r[2]*t+r[6]*s+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,i=e.y,r=e.z,o=t.x,a=t.y,l=t.z;return this.x=i*l-r*a,this.y=r*o-s*l,this.z=s*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return sC.copy(this).projectOnVector(e),this.sub(sC)}reflect(e){return this.sub(sC.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(hs(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,i=this.z-e.z;return t*t+s*s+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const i=Math.sin(t)*e;return this.x=i*Math.sin(s),this.y=Math.cos(t)*e,this.z=i*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,s=Math.sqrt(1-e**2);return this.x=s*Math.cos(t),this.y=s*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const sC=new G,dL=new _i;class Ra{constructor(e=new G(1/0,1/0,1/0),t=new G(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,s=1/0,i=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],d=e[l+2];u<t&&(t=u),h<s&&(s=h),d<i&&(i=d),u>r&&(r=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,s,i),this.max.set(r,o,a),this}setFromBufferAttribute(e){let t=1/0,s=1/0,i=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),d=e.getZ(l);u<t&&(t=u),h<s&&(s=h),d<i&&(i=d),u>r&&(r=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,s,i),this.max.set(r,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=iu.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0)if(t&&s.attributes!=null&&s.attributes.position!==void 0){const r=s.attributes.position;for(let o=0,a=r.count;o<a;o++)iu.fromBufferAttribute(r,o).applyMatrix4(e.matrixWorld),this.expandByPoint(iu)}else s.boundingBox===null&&s.computeBoundingBox(),iC.copy(s.boundingBox),iC.applyMatrix4(e.matrixWorld),this.union(iC);const i=e.children;for(let r=0,o=i.length;r<o;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,iu),iu.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Mp),Iy.subVectors(this.max,Mp),Qh.subVectors(e.a,Mp),ed.subVectors(e.b,Mp),td.subVectors(e.c,Mp),$l.subVectors(ed,Qh),Fl.subVectors(td,ed),ru.subVectors(Qh,td);let t=[0,-$l.z,$l.y,0,-Fl.z,Fl.y,0,-ru.z,ru.y,$l.z,0,-$l.x,Fl.z,0,-Fl.x,ru.z,0,-ru.x,-$l.y,$l.x,0,-Fl.y,Fl.x,0,-ru.y,ru.x,0];return!rC(t,Qh,ed,td,Iy)||(t=[1,0,0,0,1,0,0,0,1],!rC(t,Qh,ed,td,Iy))?!1:(Ey.crossVectors($l,Fl),t=[Ey.x,Ey.y,Ey.z],rC(t,Qh,ed,td,Iy))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return iu.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(iu).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Ga[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Ga[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Ga[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Ga[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Ga[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Ga[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Ga[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Ga[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Ga),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Ga=[new G,new G,new G,new G,new G,new G,new G,new G],iu=new G,iC=new Ra,Qh=new G,ed=new G,td=new G,$l=new G,Fl=new G,ru=new G,Mp=new G,Iy=new G,Ey=new G,ou=new G;function rC(n,e,t,s,i){for(let r=0,o=n.length-3;r<=o;r+=3){ou.fromArray(n,r);const a=i.x*Math.abs(ou.x)+i.y*Math.abs(ou.y)+i.z*Math.abs(ou.z),l=e.dot(ou),c=t.dot(ou),u=s.dot(ou);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const tve=new Ra,kp=new G,oC=new G;class _l{constructor(e=new G,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):tve.setFromPoints(e).getCenter(s);let i=0;for(let r=0,o=e.length;r<o;r++)i=Math.max(i,s.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;kp.subVectors(e,this.center);const t=kp.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),i=(s-this.radius)*.5;this.center.addScaledVector(kp,i/s),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(oC.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(kp.copy(e.center).add(oC)),this.expandByPoint(kp.copy(e.center).sub(oC))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Ha=new G,aC=new G,My=new G,Ol=new G,lC=new G,ky=new G,cC=new G;class P0{constructor(e=new G,t=new G(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Ha)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(s).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Ha.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Ha.copy(this.direction).multiplyScalar(t).add(this.origin),Ha.distanceToSquared(e))}distanceSqToSegment(e,t,s,i){aC.copy(e).add(t).multiplyScalar(.5),My.copy(t).sub(e).normalize(),Ol.copy(this.origin).sub(aC);const r=e.distanceTo(t)*.5,o=-this.direction.dot(My),a=Ol.dot(this.direction),l=-Ol.dot(My),c=Ol.lengthSq(),u=Math.abs(1-o*o);let h,d,f,m;if(u>0)if(h=o*l-a,d=o*a-l,m=r*u,h>=0)if(d>=-m)if(d<=m){const x=1/u;h*=x,d*=x,f=h*(h+o*d+2*a)+d*(o*h+d+2*l)+c}else d=r,h=Math.max(0,-(o*d+a)),f=-h*h+d*(d+2*l)+c;else d=-r,h=Math.max(0,-(o*d+a)),f=-h*h+d*(d+2*l)+c;else d<=-m?(h=Math.max(0,-(-o*r+a)),d=h>0?-r:Math.min(Math.max(-r,-l),r),f=-h*h+d*(d+2*l)+c):d<=m?(h=0,d=Math.min(Math.max(-r,-l),r),f=d*(d+2*l)+c):(h=Math.max(0,-(o*r+a)),d=h>0?r:Math.min(Math.max(-r,-l),r),f=-h*h+d*(d+2*l)+c);else d=o>0?-r:r,h=Math.max(0,-(o*d+a)),f=-h*h+d*(d+2*l)+c;return s&&s.copy(this.direction).multiplyScalar(h).add(this.origin),i&&i.copy(My).multiplyScalar(d).add(aC),f}intersectSphere(e,t){Ha.subVectors(e.center,this.origin);const s=Ha.dot(this.direction),i=Ha.dot(Ha)-s*s,r=e.radius*e.radius;if(i>r)return null;const o=Math.sqrt(r-i),a=s-o,l=s+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,i,r,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(s=(e.min.x-d.x)*c,i=(e.max.x-d.x)*c):(s=(e.max.x-d.x)*c,i=(e.min.x-d.x)*c),u>=0?(r=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(r=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),s>o||r>i||((r>s||isNaN(s))&&(s=r),(o<i||isNaN(i))&&(i=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),s>l||a>i)||((a>s||s!==s)&&(s=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(s>=0?s:i,t)}intersectsBox(e){return this.intersectBox(e,Ha)!==null}intersectTriangle(e,t,s,i,r){lC.subVectors(t,e),ky.subVectors(s,e),cC.crossVectors(lC,ky);let o=this.direction.dot(cC),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Ol.subVectors(this.origin,e);const l=a*this.direction.dot(ky.crossVectors(Ol,ky));if(l<0)return null;const c=a*this.direction.dot(lC.cross(Ol));if(c<0||l+c>o)return null;const u=-a*Ol.dot(cC);return u<0?null:this.at(u/o,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class kt{constructor(){kt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(e,t,s,i,r,o,a,l,c,u,h,d,f,m,x,y){const v=this.elements;return v[0]=e,v[4]=t,v[8]=s,v[12]=i,v[1]=r,v[5]=o,v[9]=a,v[13]=l,v[2]=c,v[6]=u,v[10]=h,v[14]=d,v[3]=f,v[7]=m,v[11]=x,v[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new kt().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,i=1/nd.setFromMatrixColumn(e,0).length(),r=1/nd.setFromMatrixColumn(e,1).length(),o=1/nd.setFromMatrixColumn(e,2).length();return t[0]=s[0]*i,t[1]=s[1]*i,t[2]=s[2]*i,t[3]=0,t[4]=s[4]*r,t[5]=s[5]*r,t[6]=s[6]*r,t[7]=0,t[8]=s[8]*o,t[9]=s[9]*o,t[10]=s[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,i=e.y,r=e.z,o=Math.cos(s),a=Math.sin(s),l=Math.cos(i),c=Math.sin(i),u=Math.cos(r),h=Math.sin(r);if(e.order==="XYZ"){const d=o*u,f=o*h,m=a*u,x=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=f+m*c,t[5]=d-x*c,t[9]=-a*l,t[2]=x-d*c,t[6]=m+f*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*u,f=l*h,m=c*u,x=c*h;t[0]=d+x*a,t[4]=m*a-f,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=f*a-m,t[6]=x+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*u,f=l*h,m=c*u,x=c*h;t[0]=d-x*a,t[4]=-o*h,t[8]=m+f*a,t[1]=f+m*a,t[5]=o*u,t[9]=x-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*u,f=o*h,m=a*u,x=a*h;t[0]=l*u,t[4]=m*c-f,t[8]=d*c+x,t[1]=l*h,t[5]=x*c+d,t[9]=f*c-m,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,f=o*c,m=a*l,x=a*c;t[0]=l*u,t[4]=x-d*h,t[8]=m*h+f,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=f*h+m,t[10]=d-x*h}else if(e.order==="XZY"){const d=o*l,f=o*c,m=a*l,x=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+x,t[5]=o*u,t[9]=f*h-m,t[2]=m*h-f,t[6]=a*u,t[10]=x*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(nve,e,sve)}lookAt(e,t,s){const i=this.elements;return xr.subVectors(e,t),xr.lengthSq()===0&&(xr.z=1),xr.normalize(),zl.crossVectors(s,xr),zl.lengthSq()===0&&(Math.abs(s.z)===1?xr.x+=1e-4:xr.z+=1e-4,xr.normalize(),zl.crossVectors(s,xr)),zl.normalize(),Ay.crossVectors(xr,zl),i[0]=zl.x,i[4]=Ay.x,i[8]=xr.x,i[1]=zl.y,i[5]=Ay.y,i[9]=xr.y,i[2]=zl.z,i[6]=Ay.z,i[10]=xr.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,o=s[0],a=s[4],l=s[8],c=s[12],u=s[1],h=s[5],d=s[9],f=s[13],m=s[2],x=s[6],y=s[10],v=s[14],w=s[3],b=s[7],S=s[11],C=s[15],E=i[0],k=i[4],I=i[8],A=i[12],N=i[1],L=i[5],V=i[9],O=i[13],P=i[2],W=i[6],H=i[10],Y=i[14],D=i[3],$=i[7],U=i[11],B=i[15];return r[0]=o*E+a*N+l*P+c*D,r[4]=o*k+a*L+l*W+c*$,r[8]=o*I+a*V+l*H+c*U,r[12]=o*A+a*O+l*Y+c*B,r[1]=u*E+h*N+d*P+f*D,r[5]=u*k+h*L+d*W+f*$,r[9]=u*I+h*V+d*H+f*U,r[13]=u*A+h*O+d*Y+f*B,r[2]=m*E+x*N+y*P+v*D,r[6]=m*k+x*L+y*W+v*$,r[10]=m*I+x*V+y*H+v*U,r[14]=m*A+x*O+y*Y+v*B,r[3]=w*E+b*N+S*P+C*D,r[7]=w*k+b*L+S*W+C*$,r[11]=w*I+b*V+S*H+C*U,r[15]=w*A+b*O+S*Y+C*B,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],i=e[8],r=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],f=e[14],m=e[3],x=e[7],y=e[11],v=e[15];return m*(+r*l*h-i*c*h-r*a*d+s*c*d+i*a*f-s*l*f)+x*(+t*l*f-t*c*d+r*o*d-i*o*f+i*c*u-r*l*u)+y*(+t*c*h-t*a*f-r*o*h+s*o*f+r*a*u-s*c*u)+v*(-i*a*u-t*l*h+t*a*d+i*o*h-s*o*d+s*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],f=e[11],m=e[12],x=e[13],y=e[14],v=e[15],w=h*y*c-x*d*c+x*l*f-a*y*f-h*l*v+a*d*v,b=m*d*c-u*y*c-m*l*f+o*y*f+u*l*v-o*d*v,S=u*x*c-m*h*c+m*a*f-o*x*f-u*a*v+o*h*v,C=m*h*l-u*x*l-m*a*d+o*x*d+u*a*y-o*h*y,E=t*w+s*b+i*S+r*C;if(E===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const k=1/E;return e[0]=w*k,e[1]=(x*d*r-h*y*r-x*i*f+s*y*f+h*i*v-s*d*v)*k,e[2]=(a*y*r-x*l*r+x*i*c-s*y*c-a*i*v+s*l*v)*k,e[3]=(h*l*r-a*d*r-h*i*c+s*d*c+a*i*f-s*l*f)*k,e[4]=b*k,e[5]=(u*y*r-m*d*r+m*i*f-t*y*f-u*i*v+t*d*v)*k,e[6]=(m*l*r-o*y*r-m*i*c+t*y*c+o*i*v-t*l*v)*k,e[7]=(o*d*r-u*l*r+u*i*c-t*d*c-o*i*f+t*l*f)*k,e[8]=S*k,e[9]=(m*h*r-u*x*r-m*s*f+t*x*f+u*s*v-t*h*v)*k,e[10]=(o*x*r-m*a*r+m*s*c-t*x*c-o*s*v+t*a*v)*k,e[11]=(u*a*r-o*h*r-u*s*c+t*h*c+o*s*f-t*a*f)*k,e[12]=C*k,e[13]=(u*x*i-m*h*i+m*s*d-t*x*d-u*s*y+t*h*y)*k,e[14]=(m*a*i-o*x*i-m*s*l+t*x*l+o*s*y-t*a*y)*k,e[15]=(o*h*i-u*a*i+u*s*l-t*h*l-o*s*d+t*a*d)*k,this}scale(e){const t=this.elements,s=e.x,i=e.y,r=e.z;return t[0]*=s,t[4]*=i,t[8]*=r,t[1]*=s,t[5]*=i,t[9]*=r,t[2]*=s,t[6]*=i,t[10]*=r,t[3]*=s,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,i))}makeTranslation(e,t,s){return this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),i=Math.sin(t),r=1-s,o=e.x,a=e.y,l=e.z,c=r*o,u=r*a;return this.set(c*o+s,c*a-i*l,c*l+i*a,0,c*a+i*l,u*a+s,u*l-i*o,0,c*l-i*a,u*l+i*o,r*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,i,r,o){return this.set(1,s,r,0,e,1,o,0,t,i,1,0,0,0,0,1),this}compose(e,t,s){const i=this.elements,r=t._x,o=t._y,a=t._z,l=t._w,c=r+r,u=o+o,h=a+a,d=r*c,f=r*u,m=r*h,x=o*u,y=o*h,v=a*h,w=l*c,b=l*u,S=l*h,C=s.x,E=s.y,k=s.z;return i[0]=(1-(x+v))*C,i[1]=(f+S)*C,i[2]=(m-b)*C,i[3]=0,i[4]=(f-S)*E,i[5]=(1-(d+v))*E,i[6]=(y+w)*E,i[7]=0,i[8]=(m+b)*k,i[9]=(y-w)*k,i[10]=(1-(d+x))*k,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,s){const i=this.elements;let r=nd.set(i[0],i[1],i[2]).length();const o=nd.set(i[4],i[5],i[6]).length(),a=nd.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Io.copy(this);const c=1/r,u=1/o,h=1/a;return Io.elements[0]*=c,Io.elements[1]*=c,Io.elements[2]*=c,Io.elements[4]*=u,Io.elements[5]*=u,Io.elements[6]*=u,Io.elements[8]*=h,Io.elements[9]*=h,Io.elements[10]*=h,t.setFromRotationMatrix(Io),s.x=r,s.y=o,s.z=a,this}makePerspective(e,t,s,i,r,o){const a=this.elements,l=2*r/(t-e),c=2*r/(s-i),u=(t+e)/(t-e),h=(s+i)/(s-i),d=-(o+r)/(o-r),f=-2*o*r/(o-r);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,s,i,r,o){const a=this.elements,l=1/(t-e),c=1/(s-i),u=1/(o-r),h=(t+e)*l,d=(s+i)*c,f=(o+r)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<16;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const nd=new G,Io=new kt,nve=new G(0,0,0),sve=new G(1,1,1),zl=new G,Ay=new G,xr=new G,fL=new kt,pL=new _i;class Gf{constructor(e=0,t=0,s=0,i=Gf.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,i=this._order){return this._x=e,this._y=t,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const i=e.elements,r=i[0],o=i[4],a=i[8],l=i[1],c=i[5],u=i[9],h=i[2],d=i[6],f=i[10];switch(t){case"XYZ":this._y=Math.asin(hs(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,f),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-hs(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(hs(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-hs(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(hs(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(a,f));break;case"XZY":this._z=Math.asin(-hs(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-u,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return fL.makeRotationFromQuaternion(e),this.setFromRotationMatrix(fL,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return pL.setFromEuler(this),this.setFromQuaternion(pL,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Gf.DefaultOrder="XYZ";Gf.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Hu{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let ive=0;const mL=new G,sd=new _i,Xa=new kt,Ny=new G,Ap=new G,rve=new G,ove=new _i,gL=new G(1,0,0),xL=new G(0,1,0),yL=new G(0,0,1),ave={type:"added"},vL={type:"removed"};class fn extends Na{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:ive++}),this.uuid=Mr(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=fn.DefaultUp.clone();const e=new G,t=new Gf,s=new _i,i=new G(1,1,1);function r(){s.setFromEuler(t,!1)}function o(){t.setFromQuaternion(s,void 0,!1)}t._onChange(r),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new kt},normalMatrix:{value:new zi}}),this.matrix=new kt,this.matrixWorld=new kt,this.matrixAutoUpdate=fn.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=fn.DefaultMatrixWorldAutoUpdate,this.layers=new Hu,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return sd.setFromAxisAngle(e,t),this.quaternion.multiply(sd),this}rotateOnWorldAxis(e,t){return sd.setFromAxisAngle(e,t),this.quaternion.premultiply(sd),this}rotateX(e){return this.rotateOnAxis(gL,e)}rotateY(e){return this.rotateOnAxis(xL,e)}rotateZ(e){return this.rotateOnAxis(yL,e)}translateOnAxis(e,t){return mL.copy(e).applyQuaternion(this.quaternion),this.position.add(mL.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(gL,e)}translateY(e){return this.translateOnAxis(xL,e)}translateZ(e){return this.translateOnAxis(yL,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(Xa.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?Ny.copy(e):Ny.set(e,t,s);const i=this.parent;this.updateWorldMatrix(!0,!1),Ap.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Xa.lookAt(Ap,Ny,this.up):Xa.lookAt(Ny,Ap,this.up),this.quaternion.setFromRotationMatrix(Xa),i&&(Xa.extractRotation(i.matrixWorld),sd.setFromRotationMatrix(Xa),this.quaternion.premultiply(sd.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(ave)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(vL)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(vL)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),Xa.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Xa.multiply(e.parent.matrixWorld)),e.applyMatrix4(Xa),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,i=this.children.length;s<i;s++){const o=this.children[s].getObjectByProperty(e,t);if(o!==void 0)return o}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ap,e,rve),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Ap,ove,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,i=t.length;s<i;s++){const r=t[s];(r.matrixWorldAutoUpdate===!0||e===!0)&&r.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,o=i.length;r<o;r++){const a=i[r];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];r(e.shapes,h)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(r(e.materials,this.material[l]));i.material=a}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];i.animations.push(r(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),h=o(e.shapes),d=o(e.skeletons),f=o(e.animations),m=o(e.nodes);a.length>0&&(s.geometries=a),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),u.length>0&&(s.images=u),h.length>0&&(s.shapes=h),d.length>0&&(s.skeletons=d),f.length>0&&(s.animations=f),m.length>0&&(s.nodes=m)}return s.object=i,s;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const i=e.children[s];this.add(i.clone())}return this}}fn.DefaultUp=new G(0,1,0);fn.DefaultMatrixAutoUpdate=!0;fn.DefaultMatrixWorldAutoUpdate=!0;const Eo=new G,ja=new G,uC=new G,qa=new G,id=new G,rd=new G,wL=new G,hC=new G,dC=new G,fC=new G;class so{constructor(e=new G,t=new G,s=new G){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,i){i.subVectors(s,t),Eo.subVectors(e,t),i.cross(Eo);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,s,i,r){Eo.subVectors(i,t),ja.subVectors(s,t),uC.subVectors(e,t);const o=Eo.dot(Eo),a=Eo.dot(ja),l=Eo.dot(uC),c=ja.dot(ja),u=ja.dot(uC),h=o*c-a*a;if(h===0)return r.set(-2,-1,-1);const d=1/h,f=(c*l-a*u)*d,m=(o*u-a*l)*d;return r.set(1-f-m,m,f)}static containsPoint(e,t,s,i){return this.getBarycoord(e,t,s,i,qa),qa.x>=0&&qa.y>=0&&qa.x+qa.y<=1}static getUV(e,t,s,i,r,o,a,l){return this.getBarycoord(e,t,s,i,qa),l.set(0,0),l.addScaledVector(r,qa.x),l.addScaledVector(o,qa.y),l.addScaledVector(a,qa.z),l}static isFrontFacing(e,t,s,i){return Eo.subVectors(s,t),ja.subVectors(e,t),Eo.cross(ja).dot(i)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,i){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,s,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Eo.subVectors(this.c,this.b),ja.subVectors(this.a,this.b),Eo.cross(ja).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return so.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return so.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,s,i,r){return so.getUV(e,this.a,this.b,this.c,t,s,i,r)}containsPoint(e){return so.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return so.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,i=this.b,r=this.c;let o,a;id.subVectors(i,s),rd.subVectors(r,s),hC.subVectors(e,s);const l=id.dot(hC),c=rd.dot(hC);if(l<=0&&c<=0)return t.copy(s);dC.subVectors(e,i);const u=id.dot(dC),h=rd.dot(dC);if(u>=0&&h<=u)return t.copy(i);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(s).addScaledVector(id,o);fC.subVectors(e,r);const f=id.dot(fC),m=rd.dot(fC);if(m>=0&&f<=m)return t.copy(r);const x=f*c-l*m;if(x<=0&&c>=0&&m<=0)return a=c/(c-m),t.copy(s).addScaledVector(rd,a);const y=u*m-f*h;if(y<=0&&h-u>=0&&f-m>=0)return wL.subVectors(r,i),a=(h-u)/(h-u+(f-m)),t.copy(i).addScaledVector(wL,a);const v=1/(y+x+d);return o=x*v,a=d*v,t.copy(s).addScaledVector(id,o).addScaledVector(rd,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let lve=0;class li extends Na{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:lve++}),this.uuid=Mr(),this.name="",this.type="Material",this.blending=Uu,this.side=fh,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=qk,this.blendDst=Kk,this.blendEquation=Su,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=F1,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=PG,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=$v,this.stencilZFail=$v,this.stencilZPass=$v,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}const i=this[t];if(i===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==Uu&&(s.blending=this.blending),this.side!==fh&&(s.side=this.side),this.vertexColors&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=this.transparent),s.depthFunc=this.depthFunc,s.depthTest=this.depthTest,s.depthWrite=this.depthWrite,s.colorWrite=this.colorWrite,s.stencilWrite=this.stencilWrite,s.stencilWriteMask=this.stencilWriteMask,s.stencilFunc=this.stencilFunc,s.stencilRef=this.stencilRef,s.stencilFuncMask=this.stencilFuncMask,s.stencilFail=this.stencilFail,s.stencilZFail=this.stencilZFail,s.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(s.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(s.wireframe=this.wireframe),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=this.flatShading),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData);function i(r){const o=[];for(const a in r){const l=r[a];delete l.metadata,o.push(l)}return o}if(t){const r=i(e.textures),o=i(e.images);r.length>0&&(s.textures=r),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const i=t.length;s=new Array(i);for(let r=0;r!==i;++r)s[r]=t[r].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class Cl extends li{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Je(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=D0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const vs=new G,Ry=new Ae;class Cn{constructor(e,t,s){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s===!0,this.usage=Km,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[s+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)Ry.fromBufferAttribute(this,t),Ry.applyMatrix3(e),this.setXY(t,Ry.x,Ry.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)vs.fromBufferAttribute(this,t),vs.applyMatrix3(e),this.setXYZ(t,vs.x,vs.y,vs.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)vs.fromBufferAttribute(this,t),vs.applyMatrix4(e),this.setXYZ(t,vs.x,vs.y,vs.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)vs.fromBufferAttribute(this,t),vs.applyNormalMatrix(e),this.setXYZ(t,vs.x,vs.y,vs.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)vs.fromBufferAttribute(this,t),vs.transformDirection(e),this.setXYZ(t,vs.x,vs.y,vs.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=rl(t,this.array)),t}setX(e,t){return this.normalized&&(t=bn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=rl(t,this.array)),t}setY(e,t){return this.normalized&&(t=bn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=rl(t,this.array)),t}setZ(e,t){return this.normalized&&(t=bn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=rl(t,this.array)),t}setW(e,t){return this.normalized&&(t=bn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=bn(t,this.array),s=bn(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,i){return e*=this.itemSize,this.normalized&&(t=bn(t,this.array),s=bn(s,this.array),i=bn(i,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e*=this.itemSize,this.normalized&&(t=bn(t,this.array),s=bn(s,this.array),i=bn(i,this.array),r=bn(r,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Km&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class cve extends Cn{constructor(e,t,s){super(new Int8Array(e),t,s)}}class uve extends Cn{constructor(e,t,s){super(new Uint8Array(e),t,s)}}class hve extends Cn{constructor(e,t,s){super(new Uint8ClampedArray(e),t,s)}}class dve extends Cn{constructor(e,t,s){super(new Int16Array(e),t,s)}}class sA extends Cn{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class fve extends Cn{constructor(e,t,s){super(new Int32Array(e),t,s)}}class iA extends Cn{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class pve extends Cn{constructor(e,t,s){super(new Uint16Array(e),t,s),this.isFloat16BufferAttribute=!0}}class ut extends Cn{constructor(e,t,s){super(new Float32Array(e),t,s)}}class mve extends Cn{constructor(e,t,s){super(new Float64Array(e),t,s)}}let gve=0;const Zr=new kt,pC=new fn,od=new G,yr=new Ra,Np=new Ra,Gs=new G;class Bt extends Na{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:gve++}),this.uuid=Mr(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(FG(e)?iA:sA)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const r=new zi().getNormalMatrix(e);s.applyNormalMatrix(r),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Zr.makeRotationFromQuaternion(e),this.applyMatrix4(Zr),this}rotateX(e){return Zr.makeRotationX(e),this.applyMatrix4(Zr),this}rotateY(e){return Zr.makeRotationY(e),this.applyMatrix4(Zr),this}rotateZ(e){return Zr.makeRotationZ(e),this.applyMatrix4(Zr),this}translate(e,t,s){return Zr.makeTranslation(e,t,s),this.applyMatrix4(Zr),this}scale(e,t,s){return Zr.makeScale(e,t,s),this.applyMatrix4(Zr),this}lookAt(e){return pC.lookAt(e),pC.updateMatrix(),this.applyMatrix4(pC.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(od).negate(),this.translate(od.x,od.y,od.z),this}setFromPoints(e){const t=[];for(let s=0,i=e.length;s<i;s++){const r=e[s];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new ut(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ra);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new G(-1/0,-1/0,-1/0),new G(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,i=t.length;s<i;s++){const r=t[s];yr.setFromBufferAttribute(r),this.morphTargetsRelative?(Gs.addVectors(this.boundingBox.min,yr.min),this.boundingBox.expandByPoint(Gs),Gs.addVectors(this.boundingBox.max,yr.max),this.boundingBox.expandByPoint(Gs)):(this.boundingBox.expandByPoint(yr.min),this.boundingBox.expandByPoint(yr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new _l);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new G,1/0);return}if(e){const s=this.boundingSphere.center;if(yr.setFromBufferAttribute(e),t)for(let r=0,o=t.length;r<o;r++){const a=t[r];Np.setFromBufferAttribute(a),this.morphTargetsRelative?(Gs.addVectors(yr.min,Np.min),yr.expandByPoint(Gs),Gs.addVectors(yr.max,Np.max),yr.expandByPoint(Gs)):(yr.expandByPoint(Np.min),yr.expandByPoint(Np.max))}yr.getCenter(s);let i=0;for(let r=0,o=e.count;r<o;r++)Gs.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(Gs));if(t)for(let r=0,o=t.length;r<o;r++){const a=t[r],l=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)Gs.fromBufferAttribute(a,c),l&&(od.fromBufferAttribute(e,c),Gs.add(od)),i=Math.max(i,s.distanceToSquared(Gs))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.array,i=t.position.array,r=t.normal.array,o=t.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Cn(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let N=0;N<a;N++)c[N]=new G,u[N]=new G;const h=new G,d=new G,f=new G,m=new Ae,x=new Ae,y=new Ae,v=new G,w=new G;function b(N,L,V){h.fromArray(i,N*3),d.fromArray(i,L*3),f.fromArray(i,V*3),m.fromArray(o,N*2),x.fromArray(o,L*2),y.fromArray(o,V*2),d.sub(h),f.sub(h),x.sub(m),y.sub(m);const O=1/(x.x*y.y-y.x*x.y);!isFinite(O)||(v.copy(d).multiplyScalar(y.y).addScaledVector(f,-x.y).multiplyScalar(O),w.copy(f).multiplyScalar(x.x).addScaledVector(d,-y.x).multiplyScalar(O),c[N].add(v),c[L].add(v),c[V].add(v),u[N].add(w),u[L].add(w),u[V].add(w))}let S=this.groups;S.length===0&&(S=[{start:0,count:s.length}]);for(let N=0,L=S.length;N<L;++N){const V=S[N],O=V.start,P=V.count;for(let W=O,H=O+P;W<H;W+=3)b(s[W+0],s[W+1],s[W+2])}const C=new G,E=new G,k=new G,I=new G;function A(N){k.fromArray(r,N*3),I.copy(k);const L=c[N];C.copy(L),C.sub(k.multiplyScalar(k.dot(L))).normalize(),E.crossVectors(I,L);const O=E.dot(u[N])<0?-1:1;l[N*4]=C.x,l[N*4+1]=C.y,l[N*4+2]=C.z,l[N*4+3]=O}for(let N=0,L=S.length;N<L;++N){const V=S[N],O=V.start,P=V.count;for(let W=O,H=O+P;W<H;W+=3)A(s[W+0]),A(s[W+1]),A(s[W+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Cn(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let d=0,f=s.count;d<f;d++)s.setXYZ(d,0,0,0);const i=new G,r=new G,o=new G,a=new G,l=new G,c=new G,u=new G,h=new G;if(e)for(let d=0,f=e.count;d<f;d+=3){const m=e.getX(d+0),x=e.getX(d+1),y=e.getX(d+2);i.fromBufferAttribute(t,m),r.fromBufferAttribute(t,x),o.fromBufferAttribute(t,y),u.subVectors(o,r),h.subVectors(i,r),u.cross(h),a.fromBufferAttribute(s,m),l.fromBufferAttribute(s,x),c.fromBufferAttribute(s,y),a.add(u),l.add(u),c.add(u),s.setXYZ(m,a.x,a.y,a.z),s.setXYZ(x,l.x,l.y,l.z),s.setXYZ(y,c.x,c.y,c.z)}else for(let d=0,f=t.count;d<f;d+=3)i.fromBufferAttribute(t,d+0),r.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),u.subVectors(o,r),h.subVectors(i,r),u.cross(h),s.setXYZ(d+0,u.x,u.y,u.z),s.setXYZ(d+1,u.x,u.y,u.z),s.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),s.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)Gs.fromBufferAttribute(e,t),Gs.normalize(),e.setXYZ(t,Gs.x,Gs.y,Gs.z)}toNonIndexed(){function e(a,l){const c=a.array,u=a.itemSize,h=a.normalized,d=new c.constructor(l.length*u);let f=0,m=0;for(let x=0,y=l.length;x<y;x++){a.isInterleavedBufferAttribute?f=l[x]*a.data.stride+a.offset:f=l[x]*u;for(let v=0;v<u;v++)d[m++]=c[f++]}return new Cn(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Bt,s=this.index.array,i=this.attributes;for(const a in i){const l=i[a],c=e(l,s);t.setAttribute(a,c)}const r=this.morphAttributes;for(const a in r){const l=[],c=r[a];for(let u=0,h=c.length;u<h;u++){const d=c[u],f=e(d,s);l.push(f)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const c=s[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const f=c[h];u.push(f.toJSON(e.data))}u.length>0&&(i[l]=u,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone(t));const i=e.attributes;for(const c in i){const u=i[c];this.setAttribute(c,u.clone(t))}const r=e.morphAttributes;for(const c in r){const u=[],h=r[c];for(let d=0,f=h.length;d<f;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const h=o[c];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const bL=new kt,ad=new P0,mC=new _l,Bl=new G,Ul=new G,Vl=new G,gC=new G,xC=new G,yC=new G,Dy=new G,Ly=new G,Py=new G,$y=new Ae,Fy=new Ae,Oy=new Ae,vC=new G,zy=new G;class js extends fn{constructor(e=new Bt,t=new Cl){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}raycast(e,t){const s=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(s.boundingSphere===null&&s.computeBoundingSphere(),mC.copy(s.boundingSphere),mC.applyMatrix4(r),e.ray.intersectsSphere(mC)===!1)||(bL.copy(r).invert(),ad.copy(e.ray).applyMatrix4(bL),s.boundingBox!==null&&ad.intersectsBox(s.boundingBox)===!1))return;let o;const a=s.index,l=s.attributes.position,c=s.morphAttributes.position,u=s.morphTargetsRelative,h=s.attributes.uv,d=s.attributes.uv2,f=s.groups,m=s.drawRange;if(a!==null)if(Array.isArray(i))for(let x=0,y=f.length;x<y;x++){const v=f[x],w=i[v.materialIndex],b=Math.max(v.start,m.start),S=Math.min(a.count,Math.min(v.start+v.count,m.start+m.count));for(let C=b,E=S;C<E;C+=3){const k=a.getX(C),I=a.getX(C+1),A=a.getX(C+2);o=By(this,w,e,ad,l,c,u,h,d,k,I,A),o&&(o.faceIndex=Math.floor(C/3),o.face.materialIndex=v.materialIndex,t.push(o))}}else{const x=Math.max(0,m.start),y=Math.min(a.count,m.start+m.count);for(let v=x,w=y;v<w;v+=3){const b=a.getX(v),S=a.getX(v+1),C=a.getX(v+2);o=By(this,i,e,ad,l,c,u,h,d,b,S,C),o&&(o.faceIndex=Math.floor(v/3),t.push(o))}}else if(l!==void 0)if(Array.isArray(i))for(let x=0,y=f.length;x<y;x++){const v=f[x],w=i[v.materialIndex],b=Math.max(v.start,m.start),S=Math.min(l.count,Math.min(v.start+v.count,m.start+m.count));for(let C=b,E=S;C<E;C+=3){const k=C,I=C+1,A=C+2;o=By(this,w,e,ad,l,c,u,h,d,k,I,A),o&&(o.faceIndex=Math.floor(C/3),o.face.materialIndex=v.materialIndex,t.push(o))}}else{const x=Math.max(0,m.start),y=Math.min(l.count,m.start+m.count);for(let v=x,w=y;v<w;v+=3){const b=v,S=v+1,C=v+2;o=By(this,i,e,ad,l,c,u,h,d,b,S,C),o&&(o.faceIndex=Math.floor(v/3),t.push(o))}}}}function xve(n,e,t,s,i,r,o,a){let l;if(e.side===Er?l=s.intersectTriangle(o,r,i,!0,a):l=s.intersectTriangle(i,r,o,e.side!==sl,a),l===null)return null;zy.copy(a),zy.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(zy);return c<t.near||c>t.far?null:{distance:c,point:zy.clone(),object:n}}function By(n,e,t,s,i,r,o,a,l,c,u,h){Bl.fromBufferAttribute(i,c),Ul.fromBufferAttribute(i,u),Vl.fromBufferAttribute(i,h);const d=n.morphTargetInfluences;if(r&&d){Dy.set(0,0,0),Ly.set(0,0,0),Py.set(0,0,0);for(let m=0,x=r.length;m<x;m++){const y=d[m],v=r[m];y!==0&&(gC.fromBufferAttribute(v,c),xC.fromBufferAttribute(v,u),yC.fromBufferAttribute(v,h),o?(Dy.addScaledVector(gC,y),Ly.addScaledVector(xC,y),Py.addScaledVector(yC,y)):(Dy.addScaledVector(gC.sub(Bl),y),Ly.addScaledVector(xC.sub(Ul),y),Py.addScaledVector(yC.sub(Vl),y)))}Bl.add(Dy),Ul.add(Ly),Vl.add(Py)}n.isSkinnedMesh&&(n.boneTransform(c,Bl),n.boneTransform(u,Ul),n.boneTransform(h,Vl));const f=xve(n,e,t,s,Bl,Ul,Vl,vC);if(f){a&&($y.fromBufferAttribute(a,c),Fy.fromBufferAttribute(a,u),Oy.fromBufferAttribute(a,h),f.uv=so.getUV(vC,Bl,Ul,Vl,$y,Fy,Oy,new Ae)),l&&($y.fromBufferAttribute(l,c),Fy.fromBufferAttribute(l,u),Oy.fromBufferAttribute(l,h),f.uv2=so.getUV(vC,Bl,Ul,Vl,$y,Fy,Oy,new Ae));const m={a:c,b:u,c:h,normal:new G,materialIndex:0};so.getNormal(Bl,Ul,Vl,m.normal),f.face=m}return f}class Tl extends Bt{constructor(e=1,t=1,s=1,i=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:i,heightSegments:r,depthSegments:o};const a=this;i=Math.floor(i),r=Math.floor(r),o=Math.floor(o);const l=[],c=[],u=[],h=[];let d=0,f=0;m("z","y","x",-1,-1,s,t,e,o,r,0),m("z","y","x",1,-1,s,t,-e,o,r,1),m("x","z","y",1,1,e,s,t,i,o,2),m("x","z","y",1,-1,e,s,-t,i,o,3),m("x","y","z",1,-1,e,t,s,i,r,4),m("x","y","z",-1,-1,e,t,-s,i,r,5),this.setIndex(l),this.setAttribute("position",new ut(c,3)),this.setAttribute("normal",new ut(u,3)),this.setAttribute("uv",new ut(h,2));function m(x,y,v,w,b,S,C,E,k,I,A){const N=S/k,L=C/I,V=S/2,O=C/2,P=E/2,W=k+1,H=I+1;let Y=0,D=0;const $=new G;for(let U=0;U<H;U++){const B=U*L-O;for(let X=0;X<W;X++){const te=X*N-V;$[x]=te*w,$[y]=B*b,$[v]=P,c.push($.x,$.y,$.z),$[x]=0,$[y]=0,$[v]=E>0?1:-1,u.push($.x,$.y,$.z),h.push(X/k),h.push(1-U/I),Y+=1}}for(let U=0;U<I;U++)for(let B=0;B<k;B++){const X=d+B+W*U,te=d+B+W*(U+1),oe=d+(B+1)+W*(U+1),ue=d+(B+1)+W*U;l.push(X,te,ue),l.push(te,oe,ue),D+=6}a.addGroup(f,D,A),f+=D,d+=Y}}static fromJSON(e){return new Tl(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function bf(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const i=n[t][s];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?e[t][s]=i.clone():Array.isArray(i)?e[t][s]=i.slice():e[t][s]=i}}return e}function Di(n){const e={};for(let t=0;t<n.length;t++){const s=bf(n[t]);for(const i in s)e[i]=s[i]}return e}function yve(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function zG(n){return n.getRenderTarget()===null&&n.outputEncoding===En?No:wf}const Wb={clone:bf,merge:Di};var vve=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,wve=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class jo extends li{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=vve,this.fragmentShader=wve,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=bf(e.uniforms),this.uniformsGroups=yve(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const s={};for(const i in this.extensions)this.extensions[i]===!0&&(s[i]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class $0 extends fn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new kt,this.projectionMatrix=new kt,this.projectionMatrixInverse=new kt}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Un extends $0{constructor(e=50,t=1,s=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Ym*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Wu*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Ym*2*Math.atan(Math.tan(Wu*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,s,i,r,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Wu*.5*this.fov)/this.zoom,s=2*t,i=this.aspect*s,r=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;r+=o.offsetX*i/l,t-=o.offsetY*s/c,i*=o.width/l,s*=o.height/c}const a=this.filmOffset;a!==0&&(r+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-s,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const ld=-90,cd=1;class BG extends fn{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s;const i=new Un(ld,cd,e,t);i.layers=this.layers,i.up.set(0,1,0),i.lookAt(1,0,0),this.add(i);const r=new Un(ld,cd,e,t);r.layers=this.layers,r.up.set(0,1,0),r.lookAt(-1,0,0),this.add(r);const o=new Un(ld,cd,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(0,1,0),this.add(o);const a=new Un(ld,cd,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(0,-1,0),this.add(a);const l=new Un(ld,cd,e,t);l.layers=this.layers,l.up.set(0,1,0),l.lookAt(0,0,1),this.add(l);const c=new Un(ld,cd,e,t);c.layers=this.layers,c.up.set(0,1,0),c.lookAt(0,0,-1),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const s=this.renderTarget,[i,r,o,a,l,c]=this.children,u=e.getRenderTarget(),h=e.toneMapping,d=e.xr.enabled;e.toneMapping=Uo,e.xr.enabled=!1;const f=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0),e.render(t,i),e.setRenderTarget(s,1),e.render(t,r),e.setRenderTarget(s,2),e.render(t,o),e.setRenderTarget(s,3),e.render(t,a),e.setRenderTarget(s,4),e.render(t,l),s.texture.generateMipmaps=f,e.setRenderTarget(s,5),e.render(t,c),e.setRenderTarget(u),e.toneMapping=h,e.xr.enabled=d,s.texture.needsPMREMUpdate=!0}}class F0 extends ns{constructor(e,t,s,i,r,o,a,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:Ec,super(e,t,s,i,r,o,a,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class UG extends mo{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},i=[s,s,s,s,s,s];this.texture=new F0(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:us}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Tl(5,5,5),r=new jo({name:"CubemapFromEquirect",uniforms:bf(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:Er,blending:ll});r.uniforms.tEquirect.value=t;const o=new js(i,r),a=t.minFilter;return t.minFilter===Nh&&(t.minFilter=us),new BG(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,s,i){const r=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,s,i);e.setRenderTarget(r)}}const wC=new G,bve=new G,Sve=new zi;class ql{constructor(e=new G(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,i){return this.normal.set(e,t,s),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const i=wC.subVectors(s,t).cross(bve.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const s=e.delta(wC),i=this.normal.dot(s);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(s).multiplyScalar(r).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||Sve.getNormalMatrix(e),i=this.coplanarPoint(wC).applyMatrix4(e),r=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const ud=new _l,Uy=new G;class Gb{constructor(e=new ql,t=new ql,s=new ql,i=new ql,r=new ql,o=new ql){this.planes=[e,t,s,i,r,o]}set(e,t,s,i,r,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(s),a[3].copy(i),a[4].copy(r),a[5].copy(o),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e){const t=this.planes,s=e.elements,i=s[0],r=s[1],o=s[2],a=s[3],l=s[4],c=s[5],u=s[6],h=s[7],d=s[8],f=s[9],m=s[10],x=s[11],y=s[12],v=s[13],w=s[14],b=s[15];return t[0].setComponents(a-i,h-l,x-d,b-y).normalize(),t[1].setComponents(a+i,h+l,x+d,b+y).normalize(),t[2].setComponents(a+r,h+c,x+f,b+v).normalize(),t[3].setComponents(a-r,h-c,x-f,b-v).normalize(),t[4].setComponents(a-o,h-u,x-m,b-w).normalize(),t[5].setComponents(a+o,h+u,x+m,b+w).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),ud.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(ud)}intersectsSprite(e){return ud.center.set(0,0,0),ud.radius=.7071067811865476,ud.applyMatrix4(e.matrixWorld),this.intersectsSphere(ud)}intersectsSphere(e){const t=this.planes,s=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(s)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const i=t[s];if(Uy.x=i.normal.x>0?e.max.x:e.min.x,Uy.y=i.normal.y>0?e.max.y:e.min.y,Uy.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Uy)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function VG(){let n=null,e=!1,t=null,s=null;function i(r,o){t(r,o),s=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){n=r}}}function _ve(n,e){const t=e.isWebGL2,s=new WeakMap;function i(c,u){const h=c.array,d=c.usage,f=n.createBuffer();n.bindBuffer(u,f),n.bufferData(u,h,d),c.onUploadCallback();let m;if(h instanceof Float32Array)m=5126;else if(h instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)m=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else m=5123;else if(h instanceof Int16Array)m=5122;else if(h instanceof Uint32Array)m=5125;else if(h instanceof Int32Array)m=5124;else if(h instanceof Int8Array)m=5120;else if(h instanceof Uint8Array)m=5121;else if(h instanceof Uint8ClampedArray)m=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:f,type:m,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function r(c,u,h){const d=u.array,f=u.updateRange;n.bindBuffer(h,c),f.count===-1?n.bufferSubData(h,0,d):(t?n.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):n.bufferSubData(h,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1),u.onUploadCallback()}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),s.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=s.get(c);u&&(n.deleteBuffer(u.buffer),s.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=s.get(c);(!d||d.version<c.version)&&s.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=s.get(c);h===void 0?s.set(c,i(c,u)):h.version<c.version&&(r(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class Hf extends Bt{constructor(e=1,t=1,s=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:i};const r=e/2,o=t/2,a=Math.floor(s),l=Math.floor(i),c=a+1,u=l+1,h=e/a,d=t/l,f=[],m=[],x=[],y=[];for(let v=0;v<u;v++){const w=v*d-o;for(let b=0;b<c;b++){const S=b*h-r;m.push(S,-w,0),x.push(0,0,1),y.push(b/a),y.push(1-v/l)}}for(let v=0;v<l;v++)for(let w=0;w<a;w++){const b=w+c*v,S=w+c*(v+1),C=w+1+c*(v+1),E=w+1+c*v;f.push(b,S,E),f.push(S,C,E)}this.setIndex(f),this.setAttribute("position",new ut(m,3)),this.setAttribute("normal",new ut(x,3)),this.setAttribute("uv",new ut(y,2))}static fromJSON(e){return new Hf(e.width,e.height,e.widthSegments,e.heightSegments)}}var Cve=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Tve=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Ive=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,Eve=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,Mve=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,kve=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Ave="vec3 transformed = vec3( position );",Nve=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Rve=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,Dve=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,Lve=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Pve=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,$ve=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Fve=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Ove=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,zve=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Bve=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Uve=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Vve=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Wve=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Gve=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Hve=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Xve=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,jve=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,qve=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Kve=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Yve="gl_FragColor = linearToOutputTexel( gl_FragColor );",Zve=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Jve=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Qve=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,e1e=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,t1e=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,n1e=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,s1e=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,i1e=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,r1e=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,o1e=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,a1e=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,l1e=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,c1e=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,u1e=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,h1e=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,d1e=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,f1e=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,p1e=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,m1e=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,g1e=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,x1e=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,y1e=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,v1e=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,w1e=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,b1e=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,S1e=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,_1e=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,C1e=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,T1e=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,I1e=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,E1e=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,M1e=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,k1e=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,A1e=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,N1e=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,R1e=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,D1e=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,L1e=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,P1e=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,$1e=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,F1e=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,O1e=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,z1e=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,B1e=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,U1e=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,V1e=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,W1e=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,G1e=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,H1e=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,X1e=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,j1e=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,q1e=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,K1e=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Y1e=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Z1e=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,J1e=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Q1e=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,ewe=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,twe=`#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,nwe=`#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,swe=`#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,iwe=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,rwe=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,owe=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,awe=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,lwe=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,cwe=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,uwe=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,hwe=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,dwe=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,fwe=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,pwe=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,mwe=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,gwe=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,xwe=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,ywe=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,vwe=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,wwe=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,bwe=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Swe=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,_we=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Cwe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Twe=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Iwe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Ewe=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Mwe=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,kwe=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Awe=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Nwe=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Rwe=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Dwe=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Lwe=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Pwe=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,$we=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Fwe=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Owe=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,zwe=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Bwe=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Uwe=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Vwe=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Wwe=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Gwe=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Hwe=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Xwe=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,jwe=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,qwe=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Kwe=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Ywe=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Zwe=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Jwe=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Qwe=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ebe=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,tbe=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Ot={alphamap_fragment:Cve,alphamap_pars_fragment:Tve,alphatest_fragment:Ive,alphatest_pars_fragment:Eve,aomap_fragment:Mve,aomap_pars_fragment:kve,begin_vertex:Ave,beginnormal_vertex:Nve,bsdfs:Rve,iridescence_fragment:Dve,bumpmap_pars_fragment:Lve,clipping_planes_fragment:Pve,clipping_planes_pars_fragment:$ve,clipping_planes_pars_vertex:Fve,clipping_planes_vertex:Ove,color_fragment:zve,color_pars_fragment:Bve,color_pars_vertex:Uve,color_vertex:Vve,common:Wve,cube_uv_reflection_fragment:Gve,defaultnormal_vertex:Hve,displacementmap_pars_vertex:Xve,displacementmap_vertex:jve,emissivemap_fragment:qve,emissivemap_pars_fragment:Kve,encodings_fragment:Yve,encodings_pars_fragment:Zve,envmap_fragment:Jve,envmap_common_pars_fragment:Qve,envmap_pars_fragment:e1e,envmap_pars_vertex:t1e,envmap_physical_pars_fragment:f1e,envmap_vertex:n1e,fog_vertex:s1e,fog_pars_vertex:i1e,fog_fragment:r1e,fog_pars_fragment:o1e,gradientmap_pars_fragment:a1e,lightmap_fragment:l1e,lightmap_pars_fragment:c1e,lights_lambert_fragment:u1e,lights_lambert_pars_fragment:h1e,lights_pars_begin:d1e,lights_toon_fragment:p1e,lights_toon_pars_fragment:m1e,lights_phong_fragment:g1e,lights_phong_pars_fragment:x1e,lights_physical_fragment:y1e,lights_physical_pars_fragment:v1e,lights_fragment_begin:w1e,lights_fragment_maps:b1e,lights_fragment_end:S1e,logdepthbuf_fragment:_1e,logdepthbuf_pars_fragment:C1e,logdepthbuf_pars_vertex:T1e,logdepthbuf_vertex:I1e,map_fragment:E1e,map_pars_fragment:M1e,map_particle_fragment:k1e,map_particle_pars_fragment:A1e,metalnessmap_fragment:N1e,metalnessmap_pars_fragment:R1e,morphcolor_vertex:D1e,morphnormal_vertex:L1e,morphtarget_pars_vertex:P1e,morphtarget_vertex:$1e,normal_fragment_begin:F1e,normal_fragment_maps:O1e,normal_pars_fragment:z1e,normal_pars_vertex:B1e,normal_vertex:U1e,normalmap_pars_fragment:V1e,clearcoat_normal_fragment_begin:W1e,clearcoat_normal_fragment_maps:G1e,clearcoat_pars_fragment:H1e,iridescence_pars_fragment:X1e,output_fragment:j1e,packing:q1e,premultiplied_alpha_fragment:K1e,project_vertex:Y1e,dithering_fragment:Z1e,dithering_pars_fragment:J1e,roughnessmap_fragment:Q1e,roughnessmap_pars_fragment:ewe,shadowmap_pars_fragment:twe,shadowmap_pars_vertex:nwe,shadowmap_vertex:swe,shadowmask_pars_fragment:iwe,skinbase_vertex:rwe,skinning_pars_vertex:owe,skinning_vertex:awe,skinnormal_vertex:lwe,specularmap_fragment:cwe,specularmap_pars_fragment:uwe,tonemapping_fragment:hwe,tonemapping_pars_fragment:dwe,transmission_fragment:fwe,transmission_pars_fragment:pwe,uv_pars_fragment:mwe,uv_pars_vertex:gwe,uv_vertex:xwe,uv2_pars_fragment:ywe,uv2_pars_vertex:vwe,uv2_vertex:wwe,worldpos_vertex:bwe,background_vert:Swe,background_frag:_we,backgroundCube_vert:Cwe,backgroundCube_frag:Twe,cube_vert:Iwe,cube_frag:Ewe,depth_vert:Mwe,depth_frag:kwe,distanceRGBA_vert:Awe,distanceRGBA_frag:Nwe,equirect_vert:Rwe,equirect_frag:Dwe,linedashed_vert:Lwe,linedashed_frag:Pwe,meshbasic_vert:$we,meshbasic_frag:Fwe,meshlambert_vert:Owe,meshlambert_frag:zwe,meshmatcap_vert:Bwe,meshmatcap_frag:Uwe,meshnormal_vert:Vwe,meshnormal_frag:Wwe,meshphong_vert:Gwe,meshphong_frag:Hwe,meshphysical_vert:Xwe,meshphysical_frag:jwe,meshtoon_vert:qwe,meshtoon_frag:Kwe,points_vert:Ywe,points_frag:Zwe,shadow_vert:Jwe,shadow_frag:Qwe,sprite_vert:ebe,sprite_frag:tbe},je={common:{diffuse:{value:new Je(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new zi},uv2Transform:{value:new zi},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Ae(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Je(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Je(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new zi}},sprite:{diffuse:{value:new Je(16777215)},opacity:{value:1},center:{value:new Ae(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new zi}}},Fi={basic:{uniforms:Di([je.common,je.specularmap,je.envmap,je.aomap,je.lightmap,je.fog]),vertexShader:Ot.meshbasic_vert,fragmentShader:Ot.meshbasic_frag},lambert:{uniforms:Di([je.common,je.specularmap,je.envmap,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.fog,je.lights,{emissive:{value:new Je(0)}}]),vertexShader:Ot.meshlambert_vert,fragmentShader:Ot.meshlambert_frag},phong:{uniforms:Di([je.common,je.specularmap,je.envmap,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.fog,je.lights,{emissive:{value:new Je(0)},specular:{value:new Je(1118481)},shininess:{value:30}}]),vertexShader:Ot.meshphong_vert,fragmentShader:Ot.meshphong_frag},standard:{uniforms:Di([je.common,je.envmap,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.roughnessmap,je.metalnessmap,je.fog,je.lights,{emissive:{value:new Je(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ot.meshphysical_vert,fragmentShader:Ot.meshphysical_frag},toon:{uniforms:Di([je.common,je.aomap,je.lightmap,je.emissivemap,je.bumpmap,je.normalmap,je.displacementmap,je.gradientmap,je.fog,je.lights,{emissive:{value:new Je(0)}}]),vertexShader:Ot.meshtoon_vert,fragmentShader:Ot.meshtoon_frag},matcap:{uniforms:Di([je.common,je.bumpmap,je.normalmap,je.displacementmap,je.fog,{matcap:{value:null}}]),vertexShader:Ot.meshmatcap_vert,fragmentShader:Ot.meshmatcap_frag},points:{uniforms:Di([je.points,je.fog]),vertexShader:Ot.points_vert,fragmentShader:Ot.points_frag},dashed:{uniforms:Di([je.common,je.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ot.linedashed_vert,fragmentShader:Ot.linedashed_frag},depth:{uniforms:Di([je.common,je.displacementmap]),vertexShader:Ot.depth_vert,fragmentShader:Ot.depth_frag},normal:{uniforms:Di([je.common,je.bumpmap,je.normalmap,je.displacementmap,{opacity:{value:1}}]),vertexShader:Ot.meshnormal_vert,fragmentShader:Ot.meshnormal_frag},sprite:{uniforms:Di([je.sprite,je.fog]),vertexShader:Ot.sprite_vert,fragmentShader:Ot.sprite_frag},background:{uniforms:{uvTransform:{value:new zi},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Ot.background_vert,fragmentShader:Ot.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:Ot.backgroundCube_vert,fragmentShader:Ot.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Ot.cube_vert,fragmentShader:Ot.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ot.equirect_vert,fragmentShader:Ot.equirect_frag},distanceRGBA:{uniforms:Di([je.common,je.displacementmap,{referencePosition:{value:new G},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ot.distanceRGBA_vert,fragmentShader:Ot.distanceRGBA_frag},shadow:{uniforms:Di([je.lights,je.fog,{color:{value:new Je(0)},opacity:{value:1}}]),vertexShader:Ot.shadow_vert,fragmentShader:Ot.shadow_frag}};Fi.physical={uniforms:Di([Fi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Ae(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new Je(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Ae},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Je(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Je(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Ot.meshphysical_vert,fragmentShader:Ot.meshphysical_frag};const Vy={r:0,b:0,g:0};function nbe(n,e,t,s,i,r,o){const a=new Je(0);let l=r===!0?0:1,c,u,h=null,d=0,f=null;function m(y,v){let w=!1,b=v.isScene===!0?v.background:null;b&&b.isTexture&&(b=(v.backgroundBlurriness>0?t:e).get(b));const S=n.xr,C=S.getSession&&S.getSession();C&&C.environmentBlendMode==="additive"&&(b=null),b===null?x(a,l):b&&b.isColor&&(x(b,1),w=!0),(n.autoClear||w)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),b&&(b.isCubeTexture||b.mapping===Wf)?(u===void 0&&(u=new js(new Tl(1,1,1),new jo({name:"BackgroundCubeMaterial",uniforms:bf(Fi.backgroundCube.uniforms),vertexShader:Fi.backgroundCube.vertexShader,fragmentShader:Fi.backgroundCube.fragmentShader,side:Er,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(E,k,I){this.matrixWorld.copyPosition(I.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),u.material.uniforms.envMap.value=b,u.material.uniforms.flipEnvMap.value=b.isCubeTexture&&b.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=v.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=v.backgroundIntensity,(h!==b||d!==b.version||f!==n.toneMapping)&&(u.material.needsUpdate=!0,h=b,d=b.version,f=n.toneMapping),u.layers.enableAll(),y.unshift(u,u.geometry,u.material,0,0,null)):b&&b.isTexture&&(c===void 0&&(c=new js(new Hf(2,2),new jo({name:"BackgroundMaterial",uniforms:bf(Fi.background.uniforms),vertexShader:Fi.background.vertexShader,fragmentShader:Fi.background.fragmentShader,side:fh,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=b,c.material.uniforms.backgroundIntensity.value=v.backgroundIntensity,b.matrixAutoUpdate===!0&&b.updateMatrix(),c.material.uniforms.uvTransform.value.copy(b.matrix),(h!==b||d!==b.version||f!==n.toneMapping)&&(c.material.needsUpdate=!0,h=b,d=b.version,f=n.toneMapping),c.layers.enableAll(),y.unshift(c,c.geometry,c.material,0,0,null))}function x(y,v){y.getRGB(Vy,zG(n)),s.buffers.color.setClear(Vy.r,Vy.g,Vy.b,v,o)}return{getClearColor:function(){return a},setClearColor:function(y,v=1){a.set(y),l=v,x(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(y){l=y,x(a,l)},render:m}}function sbe(n,e,t,s){const i=n.getParameter(34921),r=s.isWebGL2?null:e.get("OES_vertex_array_object"),o=s.isWebGL2||r!==null,a={},l=y(null);let c=l,u=!1;function h(P,W,H,Y,D){let $=!1;if(o){const U=x(Y,H,W);c!==U&&(c=U,f(c.object)),$=v(P,Y,H,D),$&&w(P,Y,H,D)}else{const U=W.wireframe===!0;(c.geometry!==Y.id||c.program!==H.id||c.wireframe!==U)&&(c.geometry=Y.id,c.program=H.id,c.wireframe=U,$=!0)}D!==null&&t.update(D,34963),($||u)&&(u=!1,I(P,W,H,Y),D!==null&&n.bindBuffer(34963,t.get(D).buffer))}function d(){return s.isWebGL2?n.createVertexArray():r.createVertexArrayOES()}function f(P){return s.isWebGL2?n.bindVertexArray(P):r.bindVertexArrayOES(P)}function m(P){return s.isWebGL2?n.deleteVertexArray(P):r.deleteVertexArrayOES(P)}function x(P,W,H){const Y=H.wireframe===!0;let D=a[P.id];D===void 0&&(D={},a[P.id]=D);let $=D[W.id];$===void 0&&($={},D[W.id]=$);let U=$[Y];return U===void 0&&(U=y(d()),$[Y]=U),U}function y(P){const W=[],H=[],Y=[];for(let D=0;D<i;D++)W[D]=0,H[D]=0,Y[D]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:W,enabledAttributes:H,attributeDivisors:Y,object:P,attributes:{},index:null}}function v(P,W,H,Y){const D=c.attributes,$=W.attributes;let U=0;const B=H.getAttributes();for(const X in B)if(B[X].location>=0){const oe=D[X];let ue=$[X];if(ue===void 0&&(X==="instanceMatrix"&&P.instanceMatrix&&(ue=P.instanceMatrix),X==="instanceColor"&&P.instanceColor&&(ue=P.instanceColor)),oe===void 0||oe.attribute!==ue||ue&&oe.data!==ue.data)return!0;U++}return c.attributesNum!==U||c.index!==Y}function w(P,W,H,Y){const D={},$=W.attributes;let U=0;const B=H.getAttributes();for(const X in B)if(B[X].location>=0){let oe=$[X];oe===void 0&&(X==="instanceMatrix"&&P.instanceMatrix&&(oe=P.instanceMatrix),X==="instanceColor"&&P.instanceColor&&(oe=P.instanceColor));const ue={};ue.attribute=oe,oe&&oe.data&&(ue.data=oe.data),D[X]=ue,U++}c.attributes=D,c.attributesNum=U,c.index=Y}function b(){const P=c.newAttributes;for(let W=0,H=P.length;W<H;W++)P[W]=0}function S(P){C(P,0)}function C(P,W){const H=c.newAttributes,Y=c.enabledAttributes,D=c.attributeDivisors;H[P]=1,Y[P]===0&&(n.enableVertexAttribArray(P),Y[P]=1),D[P]!==W&&((s.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](P,W),D[P]=W)}function E(){const P=c.newAttributes,W=c.enabledAttributes;for(let H=0,Y=W.length;H<Y;H++)W[H]!==P[H]&&(n.disableVertexAttribArray(H),W[H]=0)}function k(P,W,H,Y,D,$){s.isWebGL2===!0&&(H===5124||H===5125)?n.vertexAttribIPointer(P,W,H,D,$):n.vertexAttribPointer(P,W,H,Y,D,$)}function I(P,W,H,Y){if(s.isWebGL2===!1&&(P.isInstancedMesh||Y.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;b();const D=Y.attributes,$=H.getAttributes(),U=W.defaultAttributeValues;for(const B in $){const X=$[B];if(X.location>=0){let te=D[B];if(te===void 0&&(B==="instanceMatrix"&&P.instanceMatrix&&(te=P.instanceMatrix),B==="instanceColor"&&P.instanceColor&&(te=P.instanceColor)),te!==void 0){const oe=te.normalized,ue=te.itemSize,Q=t.get(te);if(Q===void 0)continue;const ke=Q.buffer,Me=Q.type,De=Q.bytesPerElement;if(te.isInterleavedBufferAttribute){const Ee=te.data,Be=Ee.stride,ye=te.offset;if(Ee.isInstancedInterleavedBuffer){for(let fe=0;fe<X.locationSize;fe++)C(X.location+fe,Ee.meshPerAttribute);P.isInstancedMesh!==!0&&Y._maxInstanceCount===void 0&&(Y._maxInstanceCount=Ee.meshPerAttribute*Ee.count)}else for(let fe=0;fe<X.locationSize;fe++)S(X.location+fe);n.bindBuffer(34962,ke);for(let fe=0;fe<X.locationSize;fe++)k(X.location+fe,ue/X.locationSize,Me,oe,Be*De,(ye+ue/X.locationSize*fe)*De)}else{if(te.isInstancedBufferAttribute){for(let Ee=0;Ee<X.locationSize;Ee++)C(X.location+Ee,te.meshPerAttribute);P.isInstancedMesh!==!0&&Y._maxInstanceCount===void 0&&(Y._maxInstanceCount=te.meshPerAttribute*te.count)}else for(let Ee=0;Ee<X.locationSize;Ee++)S(X.location+Ee);n.bindBuffer(34962,ke);for(let Ee=0;Ee<X.locationSize;Ee++)k(X.location+Ee,ue/X.locationSize,Me,oe,ue*De,ue/X.locationSize*Ee*De)}}else if(U!==void 0){const oe=U[B];if(oe!==void 0)switch(oe.length){case 2:n.vertexAttrib2fv(X.location,oe);break;case 3:n.vertexAttrib3fv(X.location,oe);break;case 4:n.vertexAttrib4fv(X.location,oe);break;default:n.vertexAttrib1fv(X.location,oe)}}}}E()}function A(){V();for(const P in a){const W=a[P];for(const H in W){const Y=W[H];for(const D in Y)m(Y[D].object),delete Y[D];delete W[H]}delete a[P]}}function N(P){if(a[P.id]===void 0)return;const W=a[P.id];for(const H in W){const Y=W[H];for(const D in Y)m(Y[D].object),delete Y[D];delete W[H]}delete a[P.id]}function L(P){for(const W in a){const H=a[W];if(H[P.id]===void 0)continue;const Y=H[P.id];for(const D in Y)m(Y[D].object),delete Y[D];delete H[P.id]}}function V(){O(),u=!0,c!==l&&(c=l,f(c.object))}function O(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:V,resetDefaultState:O,dispose:A,releaseStatesOfGeometry:N,releaseStatesOfProgram:L,initAttributes:b,enableAttribute:S,disableUnusedAttributes:E}}function ibe(n,e,t,s){const i=s.isWebGL2;let r;function o(c){r=c}function a(c,u){n.drawArrays(r,c,u),t.update(u,r,1)}function l(c,u,h){if(h===0)return;let d,f;if(i)d=n,f="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](r,c,u,h),t.update(u,r,h)}this.setMode=o,this.render=a,this.renderInstances=l}function rbe(n,e,t){let s;function i(){if(s!==void 0)return s;if(e.has("EXT_texture_filter_anisotropic")===!0){const k=e.get("EXT_texture_filter_anisotropic");s=n.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function r(k){if(k==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";k="mediump"}return k==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=r(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=n.getParameter(34930),d=n.getParameter(35660),f=n.getParameter(3379),m=n.getParameter(34076),x=n.getParameter(34921),y=n.getParameter(36347),v=n.getParameter(36348),w=n.getParameter(36349),b=d>0,S=o||e.has("OES_texture_float"),C=b&&S,E=o?n.getParameter(36183):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:i,getMaxPrecision:r,precision:a,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:f,maxCubemapSize:m,maxAttributes:x,maxVertexUniforms:y,maxVaryings:v,maxFragmentUniforms:w,vertexTextures:b,floatFragmentTextures:S,floatVertexTextures:C,maxSamples:E}}function obe(n){const e=this;let t=null,s=0,i=!1,r=!1;const o=new ql,a=new zi,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,f){const m=h.length!==0||d||s!==0||i;return i=d,t=u(h,f,0),s=h.length,m},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1,c()},this.setState=function(h,d,f){const m=h.clippingPlanes,x=h.clipIntersection,y=h.clipShadows,v=n.get(h);if(!i||m===null||m.length===0||r&&!y)r?u(null):c();else{const w=r?0:s,b=w*4;let S=v.clippingState||null;l.value=S,S=u(m,d,b,f);for(let C=0;C!==b;++C)S[C]=t[C];v.clippingState=S,this.numIntersection=x?this.numPlanes:0,this.numPlanes+=w}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function u(h,d,f,m){const x=h!==null?h.length:0;let y=null;if(x!==0){if(y=l.value,m!==!0||y===null){const v=f+x*4,w=d.matrixWorldInverse;a.getNormalMatrix(w),(y===null||y.length<v)&&(y=new Float32Array(v));for(let b=0,S=f;b!==x;++b,S+=4)o.copy(h[b]).applyMatrix4(w,a),o.normal.toArray(y,S),y[S+3]=o.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=x,e.numIntersection=0,y}}function abe(n){let e=new WeakMap;function t(o,a){return a===Vm?o.mapping=Ec:a===Wm&&(o.mapping=Mc),o}function s(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Vm||a===Wm)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new UG(l.height/2);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",i),t(c.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function r(){e=new WeakMap}return{get:s,dispose:r}}class xc extends $0{constructor(e=-1,t=1,s=1,i=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=i,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,i,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=s-e,o=s+e,a=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,o=r+c*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Pd=4,SL=[.125,.215,.35,.446,.526,.582],_u=20,bC=new xc,_L=new Je;let SC=null;const yu=(1+Math.sqrt(5))/2,hd=1/yu,CL=[new G(1,1,1),new G(-1,1,1),new G(1,1,-1),new G(-1,1,-1),new G(0,yu,hd),new G(0,yu,-hd),new G(hd,0,yu),new G(-hd,0,yu),new G(yu,hd,0),new G(-yu,hd,0)];class eI{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,s=.1,i=100){SC=this._renderer.getRenderTarget(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,s,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=EL(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=IL(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(SC),e.scissorTest=!1,Wy(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Ec||e.mapping===Mc?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),SC=this._renderer.getRenderTarget();const s=t||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,s={magFilter:us,minFilter:us,generateMipmaps:!1,type:vf,format:br,encoding:gl,depthBuffer:!1},i=TL(e,t,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=TL(e,t,s);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=lbe(r)),this._blurMaterial=cbe(r,e,t)}return i}_compileMaterial(e){const t=new js(this._lodPlanes[0],e);this._renderer.compile(t,bC)}_sceneToCubeUV(e,t,s,i){const a=new Un(90,1,t,s),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(_L),u.toneMapping=Uo,u.autoClear=!1;const f=new Cl({name:"PMREM.Background",side:Er,depthWrite:!1,depthTest:!1}),m=new js(new Tl,f);let x=!1;const y=e.background;y?y.isColor&&(f.color.copy(y),e.background=null,x=!0):(f.color.copy(_L),x=!0);for(let v=0;v<6;v++){const w=v%3;w===0?(a.up.set(0,l[v],0),a.lookAt(c[v],0,0)):w===1?(a.up.set(0,0,l[v]),a.lookAt(0,c[v],0)):(a.up.set(0,l[v],0),a.lookAt(0,0,c[v]));const b=this._cubeSize;Wy(i,w*b,v>2?b:0,b,b),u.setRenderTarget(i),x&&u.render(m,a),u.render(e,a)}m.geometry.dispose(),m.material.dispose(),u.toneMapping=d,u.autoClear=h,e.background=y}_textureToCubeUV(e,t){const s=this._renderer,i=e.mapping===Ec||e.mapping===Mc;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=EL()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=IL());const r=i?this._cubemapMaterial:this._equirectMaterial,o=new js(this._lodPlanes[0],r),a=r.uniforms;a.envMap.value=e;const l=this._cubeSize;Wy(t,0,0,3*l,2*l),s.setRenderTarget(t),s.render(o,bC)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const r=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=CL[(i-1)%CL.length];this._blur(e,i-1,i,r,o)}t.autoClear=s}_blur(e,t,s,i,r){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,s,i,"latitudinal",r),this._halfBlur(o,e,s,s,i,"longitudinal",r)}_halfBlur(e,t,s,i,r,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new js(this._lodPlanes[i],c),d=c.uniforms,f=this._sizeLods[s]-1,m=isFinite(r)?Math.PI/(2*f):2*Math.PI/(2*_u-1),x=r/m,y=isFinite(r)?1+Math.floor(u*x):_u;y>_u&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${_u}`);const v=[];let w=0;for(let k=0;k<_u;++k){const I=k/x,A=Math.exp(-I*I/2);v.push(A),k===0?w+=A:k<y&&(w+=2*A)}for(let k=0;k<v.length;k++)v[k]=v[k]/w;d.envMap.value=e.texture,d.samples.value=y,d.weights.value=v,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:b}=this;d.dTheta.value=m,d.mipInt.value=b-s;const S=this._sizeLods[i],C=3*S*(i>b-Pd?i-b+Pd:0),E=4*(this._cubeSize-S);Wy(t,C,E,3*S,2*S),l.setRenderTarget(t),l.render(h,bC)}}function lbe(n){const e=[],t=[],s=[];let i=n;const r=n-Pd+1+SL.length;for(let o=0;o<r;o++){const a=Math.pow(2,i);t.push(a);let l=1/a;o>n-Pd?l=SL[o-n+Pd-1]:o===0&&(l=0),s.push(l);const c=1/(a-2),u=-c,h=1+c,d=[u,u,h,u,h,h,u,u,h,h,u,h],f=6,m=6,x=3,y=2,v=1,w=new Float32Array(x*m*f),b=new Float32Array(y*m*f),S=new Float32Array(v*m*f);for(let E=0;E<f;E++){const k=E%3*2/3-1,I=E>2?0:-1,A=[k,I,0,k+2/3,I,0,k+2/3,I+1,0,k,I,0,k+2/3,I+1,0,k,I+1,0];w.set(A,x*m*E),b.set(d,y*m*E);const N=[E,E,E,E,E,E];S.set(N,v*m*E)}const C=new Bt;C.setAttribute("position",new Cn(w,x)),C.setAttribute("uv",new Cn(b,y)),C.setAttribute("faceIndex",new Cn(S,v)),e.push(C),i>Pd&&i--}return{lodPlanes:e,sizeLods:t,sigmas:s}}function TL(n,e,t){const s=new mo(n,e,t);return s.texture.mapping=Wf,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function Wy(n,e,t,s,i){n.viewport.set(e,t,s,i),n.scissor.set(e,t,s,i)}function cbe(n,e,t){const s=new Float32Array(_u),i=new G(0,1,0);return new jo({name:"SphericalGaussianBlur",defines:{n:_u,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:rA(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ll,depthTest:!1,depthWrite:!1})}function IL(){return new jo({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:rA(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ll,depthTest:!1,depthWrite:!1})}function EL(){return new jo({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:rA(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ll,depthTest:!1,depthWrite:!1})}function rA(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function ube(n){let e=new WeakMap,t=null;function s(a){if(a&&a.isTexture){const l=a.mapping,c=l===Vm||l===Wm,u=l===Ec||l===Mc;if(c||u)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new eI(n)),h=c?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(c&&h&&h.height>0||u&&h&&i(h)){t===null&&(t=new eI(n));const d=c?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",r),d.texture}else return null}}}return a}function i(a){let l=0;const c=6;for(let u=0;u<c;u++)a[u]!==void 0&&l++;return l===c}function r(a){const l=a.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:o}}function hbe(n){const e={};function t(s){if(e[s]!==void 0)return e[s];let i;switch(s){case"WEBGL_depth_texture":i=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=n.getExtension(s)}return e[s]=i,i}return{has:function(s){return t(s)!==null},init:function(s){s.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(s){const i=t(s);return i===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),i}}}function dbe(n,e,t,s){const i={},r=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const m in d.attributes)e.remove(d.attributes[m]);d.removeEventListener("dispose",o),delete i[d.id];const f=r.get(d);f&&(e.remove(f),r.delete(d)),s.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return i[d.id]===!0||(d.addEventListener("dispose",o),i[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const m in d)e.update(d[m],34962);const f=h.morphAttributes;for(const m in f){const x=f[m];for(let y=0,v=x.length;y<v;y++)e.update(x[y],34962)}}function c(h){const d=[],f=h.index,m=h.attributes.position;let x=0;if(f!==null){const w=f.array;x=f.version;for(let b=0,S=w.length;b<S;b+=3){const C=w[b+0],E=w[b+1],k=w[b+2];d.push(C,E,E,k,k,C)}}else{const w=m.array;x=m.version;for(let b=0,S=w.length/3-1;b<S;b+=3){const C=b+0,E=b+1,k=b+2;d.push(C,E,E,k,k,C)}}const y=new(FG(d)?iA:sA)(d,1);y.version=x;const v=r.get(h);v&&e.remove(v),r.set(h,y)}function u(h){const d=r.get(h);if(d){const f=h.index;f!==null&&d.version<f.version&&c(h)}else c(h);return r.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function fbe(n,e,t,s){const i=s.isWebGL2;let r;function o(d){r=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function u(d,f){n.drawElements(r,f,a,d*l),t.update(f,r,1)}function h(d,f,m){if(m===0)return;let x,y;if(i)x=n,y="drawElementsInstanced";else if(x=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",x===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}x[y](r,f,a,d*l,m),t.update(f,r,m)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function pbe(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(r,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(r/3);break;case 1:t.lines+=a*(r/2);break;case 3:t.lines+=a*(r-1);break;case 2:t.lines+=a*r;break;case 0:t.points+=a*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:s}}function mbe(n,e){return n[0]-e[0]}function gbe(n,e){return Math.abs(e[1])-Math.abs(n[1])}function xbe(n,e,t){const s={},i=new Float32Array(8),r=new WeakMap,o=new rn,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,u,h,d){const f=c.morphTargetInfluences;if(e.isWebGL2===!0){const m=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,x=m!==void 0?m.length:0;let y=r.get(u);if(y===void 0||y.count!==x){let W=function(){O.dispose(),r.delete(u),u.removeEventListener("dispose",W)};y!==void 0&&y.texture.dispose();const b=u.morphAttributes.position!==void 0,S=u.morphAttributes.normal!==void 0,C=u.morphAttributes.color!==void 0,E=u.morphAttributes.position||[],k=u.morphAttributes.normal||[],I=u.morphAttributes.color||[];let A=0;b===!0&&(A=1),S===!0&&(A=2),C===!0&&(A=3);let N=u.attributes.position.count*A,L=1;N>e.maxTextureSize&&(L=Math.ceil(N/e.maxTextureSize),N=e.maxTextureSize);const V=new Float32Array(N*L*4*x),O=new L0(V,N,L,x);O.type=il,O.needsUpdate=!0;const P=A*4;for(let H=0;H<x;H++){const Y=E[H],D=k[H],$=I[H],U=N*L*4*H;for(let B=0;B<Y.count;B++){const X=B*P;b===!0&&(o.fromBufferAttribute(Y,B),V[U+X+0]=o.x,V[U+X+1]=o.y,V[U+X+2]=o.z,V[U+X+3]=0),S===!0&&(o.fromBufferAttribute(D,B),V[U+X+4]=o.x,V[U+X+5]=o.y,V[U+X+6]=o.z,V[U+X+7]=0),C===!0&&(o.fromBufferAttribute($,B),V[U+X+8]=o.x,V[U+X+9]=o.y,V[U+X+10]=o.z,V[U+X+11]=$.itemSize===4?o.w:1)}}y={count:x,texture:O,size:new Ae(N,L)},r.set(u,y),u.addEventListener("dispose",W)}let v=0;for(let b=0;b<f.length;b++)v+=f[b];const w=u.morphTargetsRelative?1:1-v;d.getUniforms().setValue(n,"morphTargetBaseInfluence",w),d.getUniforms().setValue(n,"morphTargetInfluences",f),d.getUniforms().setValue(n,"morphTargetsTexture",y.texture,t),d.getUniforms().setValue(n,"morphTargetsTextureSize",y.size)}else{const m=f===void 0?0:f.length;let x=s[u.id];if(x===void 0||x.length!==m){x=[];for(let S=0;S<m;S++)x[S]=[S,0];s[u.id]=x}for(let S=0;S<m;S++){const C=x[S];C[0]=S,C[1]=f[S]}x.sort(gbe);for(let S=0;S<8;S++)S<m&&x[S][1]?(a[S][0]=x[S][0],a[S][1]=x[S][1]):(a[S][0]=Number.MAX_SAFE_INTEGER,a[S][1]=0);a.sort(mbe);const y=u.morphAttributes.position,v=u.morphAttributes.normal;let w=0;for(let S=0;S<8;S++){const C=a[S],E=C[0],k=C[1];E!==Number.MAX_SAFE_INTEGER&&k?(y&&u.getAttribute("morphTarget"+S)!==y[E]&&u.setAttribute("morphTarget"+S,y[E]),v&&u.getAttribute("morphNormal"+S)!==v[E]&&u.setAttribute("morphNormal"+S,v[E]),i[S]=k,w+=k):(y&&u.hasAttribute("morphTarget"+S)===!0&&u.deleteAttribute("morphTarget"+S),v&&u.hasAttribute("morphNormal"+S)===!0&&u.deleteAttribute("morphNormal"+S),i[S]=0)}const b=u.morphTargetsRelative?1:1-w;d.getUniforms().setValue(n,"morphTargetBaseInfluence",b),d.getUniforms().setValue(n,"morphTargetInfluences",i)}}return{update:l}}function ybe(n,e,t,s){let i=new WeakMap;function r(l){const c=s.render.frame,u=l.geometry,h=e.get(l,u);return i.get(h)!==c&&(e.update(h),i.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){i=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:r,dispose:o}}const WG=new ns,GG=new L0,HG=new Vb,XG=new F0,ML=[],kL=[],AL=new Float32Array(16),NL=new Float32Array(9),RL=new Float32Array(4);function Xf(n,e,t){const s=n[0];if(s<=0||s>0)return n;const i=e*t;let r=ML[i];if(r===void 0&&(r=new Float32Array(i),ML[i]=r),e!==0){s.toArray(r,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(r,a)}return r}function Ps(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function $s(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function Hb(n,e){let t=kL[e];t===void 0&&(t=new Int32Array(e),kL[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function vbe(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function wbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Ps(t,e))return;n.uniform2fv(this.addr,e),$s(t,e)}}function bbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Ps(t,e))return;n.uniform3fv(this.addr,e),$s(t,e)}}function Sbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Ps(t,e))return;n.uniform4fv(this.addr,e),$s(t,e)}}function _be(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Ps(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),$s(t,e)}else{if(Ps(t,s))return;RL.set(s),n.uniformMatrix2fv(this.addr,!1,RL),$s(t,s)}}function Cbe(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Ps(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),$s(t,e)}else{if(Ps(t,s))return;NL.set(s),n.uniformMatrix3fv(this.addr,!1,NL),$s(t,s)}}function Tbe(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Ps(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),$s(t,e)}else{if(Ps(t,s))return;AL.set(s),n.uniformMatrix4fv(this.addr,!1,AL),$s(t,s)}}function Ibe(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function Ebe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Ps(t,e))return;n.uniform2iv(this.addr,e),$s(t,e)}}function Mbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Ps(t,e))return;n.uniform3iv(this.addr,e),$s(t,e)}}function kbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Ps(t,e))return;n.uniform4iv(this.addr,e),$s(t,e)}}function Abe(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function Nbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Ps(t,e))return;n.uniform2uiv(this.addr,e),$s(t,e)}}function Rbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Ps(t,e))return;n.uniform3uiv(this.addr,e),$s(t,e)}}function Dbe(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Ps(t,e))return;n.uniform4uiv(this.addr,e),$s(t,e)}}function Lbe(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2D(e||WG,i)}function Pbe(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture3D(e||HG,i)}function $be(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTextureCube(e||XG,i)}function Fbe(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2DArray(e||GG,i)}function Obe(n){switch(n){case 5126:return vbe;case 35664:return wbe;case 35665:return bbe;case 35666:return Sbe;case 35674:return _be;case 35675:return Cbe;case 35676:return Tbe;case 5124:case 35670:return Ibe;case 35667:case 35671:return Ebe;case 35668:case 35672:return Mbe;case 35669:case 35673:return kbe;case 5125:return Abe;case 36294:return Nbe;case 36295:return Rbe;case 36296:return Dbe;case 35678:case 36198:case 36298:case 36306:case 35682:return Lbe;case 35679:case 36299:case 36307:return Pbe;case 35680:case 36300:case 36308:case 36293:return $be;case 36289:case 36303:case 36311:case 36292:return Fbe}}function zbe(n,e){n.uniform1fv(this.addr,e)}function Bbe(n,e){const t=Xf(e,this.size,2);n.uniform2fv(this.addr,t)}function Ube(n,e){const t=Xf(e,this.size,3);n.uniform3fv(this.addr,t)}function Vbe(n,e){const t=Xf(e,this.size,4);n.uniform4fv(this.addr,t)}function Wbe(n,e){const t=Xf(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Gbe(n,e){const t=Xf(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Hbe(n,e){const t=Xf(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function Xbe(n,e){n.uniform1iv(this.addr,e)}function jbe(n,e){n.uniform2iv(this.addr,e)}function qbe(n,e){n.uniform3iv(this.addr,e)}function Kbe(n,e){n.uniform4iv(this.addr,e)}function Ybe(n,e){n.uniform1uiv(this.addr,e)}function Zbe(n,e){n.uniform2uiv(this.addr,e)}function Jbe(n,e){n.uniform3uiv(this.addr,e)}function Qbe(n,e){n.uniform4uiv(this.addr,e)}function eSe(n,e,t){const s=this.cache,i=e.length,r=Hb(t,i);Ps(s,r)||(n.uniform1iv(this.addr,r),$s(s,r));for(let o=0;o!==i;++o)t.setTexture2D(e[o]||WG,r[o])}function tSe(n,e,t){const s=this.cache,i=e.length,r=Hb(t,i);Ps(s,r)||(n.uniform1iv(this.addr,r),$s(s,r));for(let o=0;o!==i;++o)t.setTexture3D(e[o]||HG,r[o])}function nSe(n,e,t){const s=this.cache,i=e.length,r=Hb(t,i);Ps(s,r)||(n.uniform1iv(this.addr,r),$s(s,r));for(let o=0;o!==i;++o)t.setTextureCube(e[o]||XG,r[o])}function sSe(n,e,t){const s=this.cache,i=e.length,r=Hb(t,i);Ps(s,r)||(n.uniform1iv(this.addr,r),$s(s,r));for(let o=0;o!==i;++o)t.setTexture2DArray(e[o]||GG,r[o])}function iSe(n){switch(n){case 5126:return zbe;case 35664:return Bbe;case 35665:return Ube;case 35666:return Vbe;case 35674:return Wbe;case 35675:return Gbe;case 35676:return Hbe;case 5124:case 35670:return Xbe;case 35667:case 35671:return jbe;case 35668:case 35672:return qbe;case 35669:case 35673:return Kbe;case 5125:return Ybe;case 36294:return Zbe;case 36295:return Jbe;case 36296:return Qbe;case 35678:case 36198:case 36298:case 36306:case 35682:return eSe;case 35679:case 36299:case 36307:return tSe;case 35680:case 36300:case 36308:case 36293:return nSe;case 36289:case 36303:case 36311:case 36292:return sSe}}class rSe{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.setValue=Obe(t.type)}}class oSe{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.size=t.size,this.setValue=iSe(t.type)}}class aSe{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,s){const i=this.seq;for(let r=0,o=i.length;r!==o;++r){const a=i[r];a.setValue(e,t[a.id],s)}}}const _C=/(\w+)(\])?(\[|\.)?/g;function DL(n,e){n.seq.push(e),n.map[e.id]=e}function lSe(n,e,t){const s=n.name,i=s.length;for(_C.lastIndex=0;;){const r=_C.exec(s),o=_C.lastIndex;let a=r[1];const l=r[2]==="]",c=r[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===i){DL(t,c===void 0?new rSe(a,n,e):new oSe(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new aSe(a),DL(t,h)),t=h}}}class Ov{constructor(e,t){this.seq=[],this.map={};const s=e.getProgramParameter(t,35718);for(let i=0;i<s;++i){const r=e.getActiveUniform(t,i),o=e.getUniformLocation(t,r.name);lSe(r,o,this)}}setValue(e,t,s,i){const r=this.map[t];r!==void 0&&r.setValue(e,s,i)}setOptional(e,t,s){const i=t[s];i!==void 0&&this.setValue(e,s,i)}static upload(e,t,s,i){for(let r=0,o=t.length;r!==o;++r){const a=t[r],l=s[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,i)}}static seqWithValue(e,t){const s=[];for(let i=0,r=e.length;i!==r;++i){const o=e[i];o.id in t&&s.push(o)}return s}}function LL(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}let cSe=0;function uSe(n,e){const t=n.split(`
`),s=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let o=i;o<r;o++){const a=o+1;s.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return s.join(`
`)}function hSe(n){switch(n){case gl:return["Linear","( value )"];case En:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function PL(n,e,t){const s=n.getShaderParameter(e,35713),i=n.getShaderInfoLog(e).trim();if(s&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const o=parseInt(r[1]);return t.toUpperCase()+`

`+i+`

`+uSe(n.getShaderSource(e),o)}else return i}function dSe(n,e){const t=hSe(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function fSe(n,e){let t;switch(e){case uG:t="Linear";break;case hG:t="Reinhard";break;case dG:t="OptimizedCineon";break;case Yk:t="ACESFilmic";break;case fG:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function pSe(n){return[n.extensionDerivatives||!!n.envMapCubeUVHeight||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Yp).join(`
`)}function mSe(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function gSe(n,e){const t={},s=n.getProgramParameter(e,35721);for(let i=0;i<s;i++){const r=n.getActiveAttrib(e,i),o=r.name;let a=1;r.type===35674&&(a=2),r.type===35675&&(a=3),r.type===35676&&(a=4),t[o]={type:r.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Yp(n){return n!==""}function $L(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function FL(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const xSe=/^[ \t]*#include +<([\w\d./]+)>/gm;function tI(n){return n.replace(xSe,ySe)}function ySe(n,e){const t=Ot[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return tI(t)}const vSe=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function OL(n){return n.replace(vSe,wSe)}function wSe(n,e,t,s){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=s.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function zL(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function bSe(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===zb?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===um?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Au&&(e="SHADOWMAP_TYPE_VSM"),e}function SSe(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Ec:case Mc:e="ENVMAP_TYPE_CUBE";break;case Wf:e="ENVMAP_TYPE_CUBE_UV";break}return e}function _Se(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case Mc:e="ENVMAP_MODE_REFRACTION";break}return e}function CSe(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case D0:e="ENVMAP_BLENDING_MULTIPLY";break;case lG:e="ENVMAP_BLENDING_MIX";break;case cG:e="ENVMAP_BLENDING_ADD";break}return e}function TSe(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:s,maxMip:t}}function ISe(n,e,t,s){const i=n.getContext(),r=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=bSe(t),c=SSe(t),u=_Se(t),h=CSe(t),d=TSe(t),f=t.isWebGL2?"":pSe(t),m=mSe(r),x=i.createProgram();let y,v,w=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=[m].filter(Yp).join(`
`),y.length>0&&(y+=`
`),v=[f,m].filter(Yp).join(`
`),v.length>0&&(v+=`
`)):(y=[zL(t),"#define SHADER_NAME "+t.shaderName,m,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Yp).join(`
`),v=[f,zL(t),"#define SHADER_NAME "+t.shaderName,m,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Uo?"#define TONE_MAPPING":"",t.toneMapping!==Uo?Ot.tonemapping_pars_fragment:"",t.toneMapping!==Uo?fSe("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Ot.encodings_pars_fragment,dSe("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Yp).join(`
`)),o=tI(o),o=$L(o,t),o=FL(o,t),a=tI(a),a=$L(a,t),a=FL(a,t),o=OL(o),a=OL(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(w=`#version 300 es
`,y=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,v=["#define varying in",t.glslVersion===JT?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===JT?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);const b=w+y+o,S=w+v+a,C=LL(i,35633,b),E=LL(i,35632,S);if(i.attachShader(x,C),i.attachShader(x,E),t.index0AttributeName!==void 0?i.bindAttribLocation(x,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(x,0,"position"),i.linkProgram(x),n.debug.checkShaderErrors){const A=i.getProgramInfoLog(x).trim(),N=i.getShaderInfoLog(C).trim(),L=i.getShaderInfoLog(E).trim();let V=!0,O=!0;if(i.getProgramParameter(x,35714)===!1){V=!1;const P=PL(i,C,"vertex"),W=PL(i,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(x,35715)+`

Program Info Log: `+A+`
`+P+`
`+W)}else A!==""?console.warn("THREE.WebGLProgram: Program Info Log:",A):(N===""||L==="")&&(O=!1);O&&(this.diagnostics={runnable:V,programLog:A,vertexShader:{log:N,prefix:y},fragmentShader:{log:L,prefix:v}})}i.deleteShader(C),i.deleteShader(E);let k;this.getUniforms=function(){return k===void 0&&(k=new Ov(i,x)),k};let I;return this.getAttributes=function(){return I===void 0&&(I=gSe(i,x)),I},this.destroy=function(){s.releaseStatesOfProgram(this),i.deleteProgram(x),this.program=void 0},this.name=t.shaderName,this.id=cSe++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=C,this.fragmentShader=E,this}let ESe=0;class MSe{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,s=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(s),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(r)===!1&&(o.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const s of t)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let s=t.get(e);return s===void 0&&(s=new Set,t.set(e,s)),s}_getShaderStage(e){const t=this.shaderCache;let s=t.get(e);return s===void 0&&(s=new kSe(e),t.set(e,s)),s}}class kSe{constructor(e){this.id=ESe++,this.code=e,this.usedTimes=0}}function ASe(n,e,t,s,i,r,o){const a=new Hu,l=new MSe,c=[],u=i.isWebGL2,h=i.logarithmicDepthBuffer,d=i.vertexTextures;let f=i.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function x(I,A,N,L,V){const O=L.fog,P=V.geometry,W=I.isMeshStandardMaterial?L.environment:null,H=(I.isMeshStandardMaterial?t:e).get(I.envMap||W),Y=!!H&&H.mapping===Wf?H.image.height:null,D=m[I.type];I.precision!==null&&(f=i.getMaxPrecision(I.precision),f!==I.precision&&console.warn("THREE.WebGLProgram.getParameters:",I.precision,"not supported, using",f,"instead."));const $=P.morphAttributes.position||P.morphAttributes.normal||P.morphAttributes.color,U=$!==void 0?$.length:0;let B=0;P.morphAttributes.position!==void 0&&(B=1),P.morphAttributes.normal!==void 0&&(B=2),P.morphAttributes.color!==void 0&&(B=3);let X,te,oe,ue;if(D){const Be=Fi[D];X=Be.vertexShader,te=Be.fragmentShader}else X=I.vertexShader,te=I.fragmentShader,l.update(I),oe=l.getVertexShaderID(I),ue=l.getFragmentShaderID(I);const Q=n.getRenderTarget(),ke=I.alphaTest>0,Me=I.clearcoat>0,De=I.iridescence>0;return{isWebGL2:u,shaderID:D,shaderName:I.type,vertexShader:X,fragmentShader:te,defines:I.defines,customVertexShaderID:oe,customFragmentShaderID:ue,isRawShaderMaterial:I.isRawShaderMaterial===!0,glslVersion:I.glslVersion,precision:f,instancing:V.isInstancedMesh===!0,instancingColor:V.isInstancedMesh===!0&&V.instanceColor!==null,supportsVertexTextures:d,outputEncoding:Q===null?n.outputEncoding:Q.isXRRenderTarget===!0?Q.texture.encoding:gl,map:!!I.map,matcap:!!I.matcap,envMap:!!H,envMapMode:H&&H.mapping,envMapCubeUVHeight:Y,lightMap:!!I.lightMap,aoMap:!!I.aoMap,emissiveMap:!!I.emissiveMap,bumpMap:!!I.bumpMap,normalMap:!!I.normalMap,objectSpaceNormalMap:I.normalMapType===LG,tangentSpaceNormalMap:I.normalMapType===Wc,decodeVideoTexture:!!I.map&&I.map.isVideoTexture===!0&&I.map.encoding===En,clearcoat:Me,clearcoatMap:Me&&!!I.clearcoatMap,clearcoatRoughnessMap:Me&&!!I.clearcoatRoughnessMap,clearcoatNormalMap:Me&&!!I.clearcoatNormalMap,iridescence:De,iridescenceMap:De&&!!I.iridescenceMap,iridescenceThicknessMap:De&&!!I.iridescenceThicknessMap,displacementMap:!!I.displacementMap,roughnessMap:!!I.roughnessMap,metalnessMap:!!I.metalnessMap,specularMap:!!I.specularMap,specularIntensityMap:!!I.specularIntensityMap,specularColorMap:!!I.specularColorMap,opaque:I.transparent===!1&&I.blending===Uu,alphaMap:!!I.alphaMap,alphaTest:ke,gradientMap:!!I.gradientMap,sheen:I.sheen>0,sheenColorMap:!!I.sheenColorMap,sheenRoughnessMap:!!I.sheenRoughnessMap,transmission:I.transmission>0,transmissionMap:!!I.transmissionMap,thicknessMap:!!I.thicknessMap,combine:I.combine,vertexTangents:!!I.normalMap&&!!P.attributes.tangent,vertexColors:I.vertexColors,vertexAlphas:I.vertexColors===!0&&!!P.attributes.color&&P.attributes.color.itemSize===4,vertexUvs:!!I.map||!!I.bumpMap||!!I.normalMap||!!I.specularMap||!!I.alphaMap||!!I.emissiveMap||!!I.roughnessMap||!!I.metalnessMap||!!I.clearcoatMap||!!I.clearcoatRoughnessMap||!!I.clearcoatNormalMap||!!I.iridescenceMap||!!I.iridescenceThicknessMap||!!I.displacementMap||!!I.transmissionMap||!!I.thicknessMap||!!I.specularIntensityMap||!!I.specularColorMap||!!I.sheenColorMap||!!I.sheenRoughnessMap,uvsVertexOnly:!(!!I.map||!!I.bumpMap||!!I.normalMap||!!I.specularMap||!!I.alphaMap||!!I.emissiveMap||!!I.roughnessMap||!!I.metalnessMap||!!I.clearcoatNormalMap||!!I.iridescenceMap||!!I.iridescenceThicknessMap||I.transmission>0||!!I.transmissionMap||!!I.thicknessMap||!!I.specularIntensityMap||!!I.specularColorMap||I.sheen>0||!!I.sheenColorMap||!!I.sheenRoughnessMap)&&!!I.displacementMap,fog:!!O,useFog:I.fog===!0,fogExp2:O&&O.isFogExp2,flatShading:!!I.flatShading,sizeAttenuation:I.sizeAttenuation,logarithmicDepthBuffer:h,skinning:V.isSkinnedMesh===!0,morphTargets:P.morphAttributes.position!==void 0,morphNormals:P.morphAttributes.normal!==void 0,morphColors:P.morphAttributes.color!==void 0,morphTargetsCount:U,morphTextureStride:B,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numSpotLightMaps:A.spotLightMap.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numSpotLightShadowsWithMaps:A.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:I.dithering,shadowMapEnabled:n.shadowMap.enabled&&N.length>0,shadowMapType:n.shadowMap.type,toneMapping:I.toneMapped?n.toneMapping:Uo,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:I.premultipliedAlpha,doubleSided:I.side===sl,flipSided:I.side===Er,useDepthPacking:!!I.depthPacking,depthPacking:I.depthPacking||0,index0AttributeName:I.index0AttributeName,extensionDerivatives:I.extensions&&I.extensions.derivatives,extensionFragDepth:I.extensions&&I.extensions.fragDepth,extensionDrawBuffers:I.extensions&&I.extensions.drawBuffers,extensionShaderTextureLOD:I.extensions&&I.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||s.has("EXT_shader_texture_lod"),customProgramCacheKey:I.customProgramCacheKey()}}function y(I){const A=[];if(I.shaderID?A.push(I.shaderID):(A.push(I.customVertexShaderID),A.push(I.customFragmentShaderID)),I.defines!==void 0)for(const N in I.defines)A.push(N),A.push(I.defines[N]);return I.isRawShaderMaterial===!1&&(v(A,I),w(A,I),A.push(n.outputEncoding)),A.push(I.customProgramCacheKey),A.join()}function v(I,A){I.push(A.precision),I.push(A.outputEncoding),I.push(A.envMapMode),I.push(A.envMapCubeUVHeight),I.push(A.combine),I.push(A.vertexUvs),I.push(A.fogExp2),I.push(A.sizeAttenuation),I.push(A.morphTargetsCount),I.push(A.morphAttributeCount),I.push(A.numDirLights),I.push(A.numPointLights),I.push(A.numSpotLights),I.push(A.numSpotLightMaps),I.push(A.numHemiLights),I.push(A.numRectAreaLights),I.push(A.numDirLightShadows),I.push(A.numPointLightShadows),I.push(A.numSpotLightShadows),I.push(A.numSpotLightShadowsWithMaps),I.push(A.shadowMapType),I.push(A.toneMapping),I.push(A.numClippingPlanes),I.push(A.numClipIntersection),I.push(A.depthPacking)}function w(I,A){a.disableAll(),A.isWebGL2&&a.enable(0),A.supportsVertexTextures&&a.enable(1),A.instancing&&a.enable(2),A.instancingColor&&a.enable(3),A.map&&a.enable(4),A.matcap&&a.enable(5),A.envMap&&a.enable(6),A.lightMap&&a.enable(7),A.aoMap&&a.enable(8),A.emissiveMap&&a.enable(9),A.bumpMap&&a.enable(10),A.normalMap&&a.enable(11),A.objectSpaceNormalMap&&a.enable(12),A.tangentSpaceNormalMap&&a.enable(13),A.clearcoat&&a.enable(14),A.clearcoatMap&&a.enable(15),A.clearcoatRoughnessMap&&a.enable(16),A.clearcoatNormalMap&&a.enable(17),A.iridescence&&a.enable(18),A.iridescenceMap&&a.enable(19),A.iridescenceThicknessMap&&a.enable(20),A.displacementMap&&a.enable(21),A.specularMap&&a.enable(22),A.roughnessMap&&a.enable(23),A.metalnessMap&&a.enable(24),A.gradientMap&&a.enable(25),A.alphaMap&&a.enable(26),A.alphaTest&&a.enable(27),A.vertexColors&&a.enable(28),A.vertexAlphas&&a.enable(29),A.vertexUvs&&a.enable(30),A.vertexTangents&&a.enable(31),A.uvsVertexOnly&&a.enable(32),I.push(a.mask),a.disableAll(),A.fog&&a.enable(0),A.useFog&&a.enable(1),A.flatShading&&a.enable(2),A.logarithmicDepthBuffer&&a.enable(3),A.skinning&&a.enable(4),A.morphTargets&&a.enable(5),A.morphNormals&&a.enable(6),A.morphColors&&a.enable(7),A.premultipliedAlpha&&a.enable(8),A.shadowMapEnabled&&a.enable(9),A.physicallyCorrectLights&&a.enable(10),A.doubleSided&&a.enable(11),A.flipSided&&a.enable(12),A.useDepthPacking&&a.enable(13),A.dithering&&a.enable(14),A.specularIntensityMap&&a.enable(15),A.specularColorMap&&a.enable(16),A.transmission&&a.enable(17),A.transmissionMap&&a.enable(18),A.thicknessMap&&a.enable(19),A.sheen&&a.enable(20),A.sheenColorMap&&a.enable(21),A.sheenRoughnessMap&&a.enable(22),A.decodeVideoTexture&&a.enable(23),A.opaque&&a.enable(24),I.push(a.mask)}function b(I){const A=m[I.type];let N;if(A){const L=Fi[A];N=Wb.clone(L.uniforms)}else N=I.uniforms;return N}function S(I,A){let N;for(let L=0,V=c.length;L<V;L++){const O=c[L];if(O.cacheKey===A){N=O,++N.usedTimes;break}}return N===void 0&&(N=new ISe(n,A,I,r),c.push(N)),N}function C(I){if(--I.usedTimes===0){const A=c.indexOf(I);c[A]=c[c.length-1],c.pop(),I.destroy()}}function E(I){l.remove(I)}function k(){l.dispose()}return{getParameters:x,getProgramCacheKey:y,getUniforms:b,acquireProgram:S,releaseProgram:C,releaseShaderCache:E,programs:c,dispose:k}}function NSe(){let n=new WeakMap;function e(r){let o=n.get(r);return o===void 0&&(o={},n.set(r,o)),o}function t(r){n.delete(r)}function s(r,o,a){n.get(r)[o]=a}function i(){n=new WeakMap}return{get:e,remove:t,update:s,dispose:i}}function RSe(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function BL(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function UL(){const n=[];let e=0;const t=[],s=[],i=[];function r(){e=0,t.length=0,s.length=0,i.length=0}function o(h,d,f,m,x,y){let v=n[e];return v===void 0?(v={id:h.id,object:h,geometry:d,material:f,groupOrder:m,renderOrder:h.renderOrder,z:x,group:y},n[e]=v):(v.id=h.id,v.object=h,v.geometry=d,v.material=f,v.groupOrder=m,v.renderOrder=h.renderOrder,v.z=x,v.group=y),e++,v}function a(h,d,f,m,x,y){const v=o(h,d,f,m,x,y);f.transmission>0?s.push(v):f.transparent===!0?i.push(v):t.push(v)}function l(h,d,f,m,x,y){const v=o(h,d,f,m,x,y);f.transmission>0?s.unshift(v):f.transparent===!0?i.unshift(v):t.unshift(v)}function c(h,d){t.length>1&&t.sort(h||RSe),s.length>1&&s.sort(d||BL),i.length>1&&i.sort(d||BL)}function u(){for(let h=e,d=n.length;h<d;h++){const f=n[h];if(f.id===null)break;f.id=null,f.object=null,f.geometry=null,f.material=null,f.group=null}}return{opaque:t,transmissive:s,transparent:i,init:r,push:a,unshift:l,finish:u,sort:c}}function DSe(){let n=new WeakMap;function e(s,i){const r=n.get(s);let o;return r===void 0?(o=new UL,n.set(s,[o])):i>=r.length?(o=new UL,r.push(o)):o=r[i],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function LSe(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new G,color:new Je};break;case"SpotLight":t={position:new G,direction:new G,color:new Je,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new G,color:new Je,distance:0,decay:0};break;case"HemisphereLight":t={direction:new G,skyColor:new Je,groundColor:new Je};break;case"RectAreaLight":t={color:new Je,position:new G,halfWidth:new G,halfHeight:new G};break}return n[e.id]=t,t}}}function PSe(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let $Se=0;function FSe(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function OSe(n,e){const t=new LSe,s=PSe(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let u=0;u<9;u++)i.probe.push(new G);const r=new G,o=new kt,a=new kt;function l(u,h){let d=0,f=0,m=0;for(let L=0;L<9;L++)i.probe[L].set(0,0,0);let x=0,y=0,v=0,w=0,b=0,S=0,C=0,E=0,k=0,I=0;u.sort(FSe);const A=h!==!0?Math.PI:1;for(let L=0,V=u.length;L<V;L++){const O=u[L],P=O.color,W=O.intensity,H=O.distance,Y=O.shadow&&O.shadow.map?O.shadow.map.texture:null;if(O.isAmbientLight)d+=P.r*W*A,f+=P.g*W*A,m+=P.b*W*A;else if(O.isLightProbe)for(let D=0;D<9;D++)i.probe[D].addScaledVector(O.sh.coefficients[D],W);else if(O.isDirectionalLight){const D=t.get(O);if(D.color.copy(O.color).multiplyScalar(O.intensity*A),O.castShadow){const $=O.shadow,U=s.get(O);U.shadowBias=$.bias,U.shadowNormalBias=$.normalBias,U.shadowRadius=$.radius,U.shadowMapSize=$.mapSize,i.directionalShadow[x]=U,i.directionalShadowMap[x]=Y,i.directionalShadowMatrix[x]=O.shadow.matrix,S++}i.directional[x]=D,x++}else if(O.isSpotLight){const D=t.get(O);D.position.setFromMatrixPosition(O.matrixWorld),D.color.copy(P).multiplyScalar(W*A),D.distance=H,D.coneCos=Math.cos(O.angle),D.penumbraCos=Math.cos(O.angle*(1-O.penumbra)),D.decay=O.decay,i.spot[v]=D;const $=O.shadow;if(O.map&&(i.spotLightMap[k]=O.map,k++,$.updateMatrices(O),O.castShadow&&I++),i.spotLightMatrix[v]=$.matrix,O.castShadow){const U=s.get(O);U.shadowBias=$.bias,U.shadowNormalBias=$.normalBias,U.shadowRadius=$.radius,U.shadowMapSize=$.mapSize,i.spotShadow[v]=U,i.spotShadowMap[v]=Y,E++}v++}else if(O.isRectAreaLight){const D=t.get(O);D.color.copy(P).multiplyScalar(W),D.halfWidth.set(O.width*.5,0,0),D.halfHeight.set(0,O.height*.5,0),i.rectArea[w]=D,w++}else if(O.isPointLight){const D=t.get(O);if(D.color.copy(O.color).multiplyScalar(O.intensity*A),D.distance=O.distance,D.decay=O.decay,O.castShadow){const $=O.shadow,U=s.get(O);U.shadowBias=$.bias,U.shadowNormalBias=$.normalBias,U.shadowRadius=$.radius,U.shadowMapSize=$.mapSize,U.shadowCameraNear=$.camera.near,U.shadowCameraFar=$.camera.far,i.pointShadow[y]=U,i.pointShadowMap[y]=Y,i.pointShadowMatrix[y]=O.shadow.matrix,C++}i.point[y]=D,y++}else if(O.isHemisphereLight){const D=t.get(O);D.skyColor.copy(O.color).multiplyScalar(W*A),D.groundColor.copy(O.groundColor).multiplyScalar(W*A),i.hemi[b]=D,b++}}w>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=je.LTC_FLOAT_1,i.rectAreaLTC2=je.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=je.LTC_HALF_1,i.rectAreaLTC2=je.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=f,i.ambient[2]=m;const N=i.hash;(N.directionalLength!==x||N.pointLength!==y||N.spotLength!==v||N.rectAreaLength!==w||N.hemiLength!==b||N.numDirectionalShadows!==S||N.numPointShadows!==C||N.numSpotShadows!==E||N.numSpotMaps!==k)&&(i.directional.length=x,i.spot.length=v,i.rectArea.length=w,i.point.length=y,i.hemi.length=b,i.directionalShadow.length=S,i.directionalShadowMap.length=S,i.pointShadow.length=C,i.pointShadowMap.length=C,i.spotShadow.length=E,i.spotShadowMap.length=E,i.directionalShadowMatrix.length=S,i.pointShadowMatrix.length=C,i.spotLightMatrix.length=E+k-I,i.spotLightMap.length=k,i.numSpotLightShadowsWithMaps=I,N.directionalLength=x,N.pointLength=y,N.spotLength=v,N.rectAreaLength=w,N.hemiLength=b,N.numDirectionalShadows=S,N.numPointShadows=C,N.numSpotShadows=E,N.numSpotMaps=k,i.version=$Se++)}function c(u,h){let d=0,f=0,m=0,x=0,y=0;const v=h.matrixWorldInverse;for(let w=0,b=u.length;w<b;w++){const S=u[w];if(S.isDirectionalLight){const C=i.directional[d];C.direction.setFromMatrixPosition(S.matrixWorld),r.setFromMatrixPosition(S.target.matrixWorld),C.direction.sub(r),C.direction.transformDirection(v),d++}else if(S.isSpotLight){const C=i.spot[m];C.position.setFromMatrixPosition(S.matrixWorld),C.position.applyMatrix4(v),C.direction.setFromMatrixPosition(S.matrixWorld),r.setFromMatrixPosition(S.target.matrixWorld),C.direction.sub(r),C.direction.transformDirection(v),m++}else if(S.isRectAreaLight){const C=i.rectArea[x];C.position.setFromMatrixPosition(S.matrixWorld),C.position.applyMatrix4(v),a.identity(),o.copy(S.matrixWorld),o.premultiply(v),a.extractRotation(o),C.halfWidth.set(S.width*.5,0,0),C.halfHeight.set(0,S.height*.5,0),C.halfWidth.applyMatrix4(a),C.halfHeight.applyMatrix4(a),x++}else if(S.isPointLight){const C=i.point[f];C.position.setFromMatrixPosition(S.matrixWorld),C.position.applyMatrix4(v),f++}else if(S.isHemisphereLight){const C=i.hemi[y];C.direction.setFromMatrixPosition(S.matrixWorld),C.direction.transformDirection(v),y++}}}return{setup:l,setupView:c,state:i}}function VL(n,e){const t=new OSe(n,e),s=[],i=[];function r(){s.length=0,i.length=0}function o(h){s.push(h)}function a(h){i.push(h)}function l(h){t.setup(s,h)}function c(h){t.setupView(s,h)}return{init:r,state:{lightsArray:s,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function zSe(n,e){let t=new WeakMap;function s(r,o=0){const a=t.get(r);let l;return a===void 0?(l=new VL(n,e),t.set(r,[l])):o>=a.length?(l=new VL(n,e),a.push(l)):l=a[o],l}function i(){t=new WeakMap}return{get:s,dispose:i}}class oA extends li{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=RG,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class aA extends li{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new G,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const BSe=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,USe=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function VSe(n,e,t){let s=new Gb;const i=new Ae,r=new Ae,o=new rn,a=new oA({depthPacking:DG}),l=new aA,c={},u=t.maxTextureSize,h={0:Er,1:fh,2:sl},d=new jo({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ae},radius:{value:4}},vertexShader:BSe,fragmentShader:USe}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const m=new Bt;m.setAttribute("position",new Cn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const x=new js(m,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=zb,this.render=function(S,C,E){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||S.length===0)return;const k=n.getRenderTarget(),I=n.getActiveCubeFace(),A=n.getActiveMipmapLevel(),N=n.state;N.setBlending(ll),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);for(let L=0,V=S.length;L<V;L++){const O=S[L],P=O.shadow;if(P===void 0){console.warn("THREE.WebGLShadowMap:",O,"has no shadow.");continue}if(P.autoUpdate===!1&&P.needsUpdate===!1)continue;i.copy(P.mapSize);const W=P.getFrameExtents();if(i.multiply(W),r.copy(P.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/W.x),i.x=r.x*W.x,P.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/W.y),i.y=r.y*W.y,P.mapSize.y=r.y)),P.map===null){const Y=this.type!==Au?{minFilter:ws,magFilter:ws}:{};P.map=new mo(i.x,i.y,Y),P.map.texture.name=O.name+".shadowMap",P.camera.updateProjectionMatrix()}n.setRenderTarget(P.map),n.clear();const H=P.getViewportCount();for(let Y=0;Y<H;Y++){const D=P.getViewport(Y);o.set(r.x*D.x,r.y*D.y,r.x*D.z,r.y*D.w),N.viewport(o),P.updateMatrices(O,Y),s=P.getFrustum(),b(C,E,P.camera,O,this.type)}P.isPointLightShadow!==!0&&this.type===Au&&v(P,E),P.needsUpdate=!1}y.needsUpdate=!1,n.setRenderTarget(k,I,A)};function v(S,C){const E=e.update(x);d.defines.VSM_SAMPLES!==S.blurSamples&&(d.defines.VSM_SAMPLES=S.blurSamples,f.defines.VSM_SAMPLES=S.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),S.mapPass===null&&(S.mapPass=new mo(i.x,i.y)),d.uniforms.shadow_pass.value=S.map.texture,d.uniforms.resolution.value=S.mapSize,d.uniforms.radius.value=S.radius,n.setRenderTarget(S.mapPass),n.clear(),n.renderBufferDirect(C,null,E,d,x,null),f.uniforms.shadow_pass.value=S.mapPass.texture,f.uniforms.resolution.value=S.mapSize,f.uniforms.radius.value=S.radius,n.setRenderTarget(S.map),n.clear(),n.renderBufferDirect(C,null,E,f,x,null)}function w(S,C,E,k,I,A){let N=null;const L=E.isPointLight===!0?S.customDistanceMaterial:S.customDepthMaterial;if(L!==void 0?N=L:N=E.isPointLight===!0?l:a,n.localClippingEnabled&&C.clipShadows===!0&&Array.isArray(C.clippingPlanes)&&C.clippingPlanes.length!==0||C.displacementMap&&C.displacementScale!==0||C.alphaMap&&C.alphaTest>0||C.map&&C.alphaTest>0){const V=N.uuid,O=C.uuid;let P=c[V];P===void 0&&(P={},c[V]=P);let W=P[O];W===void 0&&(W=N.clone(),P[O]=W),N=W}return N.visible=C.visible,N.wireframe=C.wireframe,A===Au?N.side=C.shadowSide!==null?C.shadowSide:C.side:N.side=C.shadowSide!==null?C.shadowSide:h[C.side],N.alphaMap=C.alphaMap,N.alphaTest=C.alphaTest,N.map=C.map,N.clipShadows=C.clipShadows,N.clippingPlanes=C.clippingPlanes,N.clipIntersection=C.clipIntersection,N.displacementMap=C.displacementMap,N.displacementScale=C.displacementScale,N.displacementBias=C.displacementBias,N.wireframeLinewidth=C.wireframeLinewidth,N.linewidth=C.linewidth,E.isPointLight===!0&&N.isMeshDistanceMaterial===!0&&(N.referencePosition.setFromMatrixPosition(E.matrixWorld),N.nearDistance=k,N.farDistance=I),N}function b(S,C,E,k,I){if(S.visible===!1)return;if(S.layers.test(C.layers)&&(S.isMesh||S.isLine||S.isPoints)&&(S.castShadow||S.receiveShadow&&I===Au)&&(!S.frustumCulled||s.intersectsObject(S))){S.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse,S.matrixWorld);const L=e.update(S),V=S.material;if(Array.isArray(V)){const O=L.groups;for(let P=0,W=O.length;P<W;P++){const H=O[P],Y=V[H.materialIndex];if(Y&&Y.visible){const D=w(S,Y,k,E.near,E.far,I);n.renderBufferDirect(E,null,L,D,S,H)}}}else if(V.visible){const O=w(S,V,k,E.near,E.far,I);n.renderBufferDirect(E,null,L,O,S,null)}}const N=S.children;for(let L=0,V=N.length;L<V;L++)b(N[L],C,E,k,I)}}function WSe(n,e,t){const s=t.isWebGL2;function i(){let ie=!1;const _e=new rn;let Fe=null;const rt=new rn(0,0,0,0);return{setMask:function(gt){Fe!==gt&&!ie&&(n.colorMask(gt,gt,gt,gt),Fe=gt)},setLocked:function(gt){ie=gt},setClear:function(gt,nn,os,zs,Jo){Jo===!0&&(gt*=zs,nn*=zs,os*=zs),_e.set(gt,nn,os,zs),rt.equals(_e)===!1&&(n.clearColor(gt,nn,os,zs),rt.copy(_e))},reset:function(){ie=!1,Fe=null,rt.set(-1,0,0,0)}}}function r(){let ie=!1,_e=null,Fe=null,rt=null;return{setTest:function(gt){gt?ke(2929):Me(2929)},setMask:function(gt){_e!==gt&&!ie&&(n.depthMask(gt),_e=gt)},setFunc:function(gt){if(Fe!==gt){switch(gt){case tG:n.depthFunc(512);break;case nG:n.depthFunc(519);break;case sG:n.depthFunc(513);break;case F1:n.depthFunc(515);break;case iG:n.depthFunc(514);break;case rG:n.depthFunc(518);break;case oG:n.depthFunc(516);break;case aG:n.depthFunc(517);break;default:n.depthFunc(515)}Fe=gt}},setLocked:function(gt){ie=gt},setClear:function(gt){rt!==gt&&(n.clearDepth(gt),rt=gt)},reset:function(){ie=!1,_e=null,Fe=null,rt=null}}}function o(){let ie=!1,_e=null,Fe=null,rt=null,gt=null,nn=null,os=null,zs=null,Jo=null;return{setTest:function(vn){ie||(vn?ke(2960):Me(2960))},setMask:function(vn){_e!==vn&&!ie&&(n.stencilMask(vn),_e=vn)},setFunc:function(vn,Fr,qi){(Fe!==vn||rt!==Fr||gt!==qi)&&(n.stencilFunc(vn,Fr,qi),Fe=vn,rt=Fr,gt=qi)},setOp:function(vn,Fr,qi){(nn!==vn||os!==Fr||zs!==qi)&&(n.stencilOp(vn,Fr,qi),nn=vn,os=Fr,zs=qi)},setLocked:function(vn){ie=vn},setClear:function(vn){Jo!==vn&&(n.clearStencil(vn),Jo=vn)},reset:function(){ie=!1,_e=null,Fe=null,rt=null,gt=null,nn=null,os=null,zs=null,Jo=null}}}const a=new i,l=new r,c=new o,u=new WeakMap,h=new WeakMap;let d={},f={},m=new WeakMap,x=[],y=null,v=!1,w=null,b=null,S=null,C=null,E=null,k=null,I=null,A=!1,N=null,L=null,V=null,O=null,P=null;const W=n.getParameter(35661);let H=!1,Y=0;const D=n.getParameter(7938);D.indexOf("WebGL")!==-1?(Y=parseFloat(/^WebGL (\d)/.exec(D)[1]),H=Y>=1):D.indexOf("OpenGL ES")!==-1&&(Y=parseFloat(/^OpenGL ES (\d)/.exec(D)[1]),H=Y>=2);let $=null,U={};const B=n.getParameter(3088),X=n.getParameter(2978),te=new rn().fromArray(B),oe=new rn().fromArray(X);function ue(ie,_e,Fe){const rt=new Uint8Array(4),gt=n.createTexture();n.bindTexture(ie,gt),n.texParameteri(ie,10241,9728),n.texParameteri(ie,10240,9728);for(let nn=0;nn<Fe;nn++)n.texImage2D(_e+nn,0,6408,1,1,0,6408,5121,rt);return gt}const Q={};Q[3553]=ue(3553,3553,1),Q[34067]=ue(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ke(2929),l.setFunc(F1),Le(!1),nt(TT),ke(2884),Re(ll);function ke(ie){d[ie]!==!0&&(n.enable(ie),d[ie]=!0)}function Me(ie){d[ie]!==!1&&(n.disable(ie),d[ie]=!1)}function De(ie,_e){return f[ie]!==_e?(n.bindFramebuffer(ie,_e),f[ie]=_e,s&&(ie===36009&&(f[36160]=_e),ie===36160&&(f[36009]=_e)),!0):!1}function Ee(ie,_e){let Fe=x,rt=!1;if(ie)if(Fe=m.get(_e),Fe===void 0&&(Fe=[],m.set(_e,Fe)),ie.isWebGLMultipleRenderTargets){const gt=ie.texture;if(Fe.length!==gt.length||Fe[0]!==36064){for(let nn=0,os=gt.length;nn<os;nn++)Fe[nn]=36064+nn;Fe.length=gt.length,rt=!0}}else Fe[0]!==36064&&(Fe[0]=36064,rt=!0);else Fe[0]!==1029&&(Fe[0]=1029,rt=!0);rt&&(t.isWebGL2?n.drawBuffers(Fe):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Fe))}function Be(ie){return y!==ie?(n.useProgram(ie),y=ie,!0):!1}const ye={[Su]:32774,[GW]:32778,[HW]:32779};if(s)ye[kT]=32775,ye[AT]=32776;else{const ie=e.get("EXT_blend_minmax");ie!==null&&(ye[kT]=ie.MIN_EXT,ye[AT]=ie.MAX_EXT)}const fe={[XW]:0,[jW]:1,[qW]:768,[qk]:770,[eG]:776,[JW]:774,[YW]:772,[KW]:769,[Kk]:771,[QW]:775,[ZW]:773};function Re(ie,_e,Fe,rt,gt,nn,os,zs){if(ie===ll){v===!0&&(Me(3042),v=!1);return}if(v===!1&&(ke(3042),v=!0),ie!==WW){if(ie!==w||zs!==A){if((b!==Su||E!==Su)&&(n.blendEquation(32774),b=Su,E=Su),zs)switch(ie){case Uu:n.blendFuncSeparate(1,771,1,771);break;case IT:n.blendFunc(1,1);break;case ET:n.blendFuncSeparate(0,769,0,1);break;case MT:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",ie);break}else switch(ie){case Uu:n.blendFuncSeparate(770,771,1,771);break;case IT:n.blendFunc(770,1);break;case ET:n.blendFuncSeparate(0,769,0,1);break;case MT:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",ie);break}S=null,C=null,k=null,I=null,w=ie,A=zs}return}gt=gt||_e,nn=nn||Fe,os=os||rt,(_e!==b||gt!==E)&&(n.blendEquationSeparate(ye[_e],ye[gt]),b=_e,E=gt),(Fe!==S||rt!==C||nn!==k||os!==I)&&(n.blendFuncSeparate(fe[Fe],fe[rt],fe[nn],fe[os]),S=Fe,C=rt,k=nn,I=os),w=ie,A=!1}function We(ie,_e){ie.side===sl?Me(2884):ke(2884);let Fe=ie.side===Er;_e&&(Fe=!Fe),Le(Fe),ie.blending===Uu&&ie.transparent===!1?Re(ll):Re(ie.blending,ie.blendEquation,ie.blendSrc,ie.blendDst,ie.blendEquationAlpha,ie.blendSrcAlpha,ie.blendDstAlpha,ie.premultipliedAlpha),l.setFunc(ie.depthFunc),l.setTest(ie.depthTest),l.setMask(ie.depthWrite),a.setMask(ie.colorWrite);const rt=ie.stencilWrite;c.setTest(rt),rt&&(c.setMask(ie.stencilWriteMask),c.setFunc(ie.stencilFunc,ie.stencilRef,ie.stencilFuncMask),c.setOp(ie.stencilFail,ie.stencilZFail,ie.stencilZPass)),ot(ie.polygonOffset,ie.polygonOffsetFactor,ie.polygonOffsetUnits),ie.alphaToCoverage===!0?ke(32926):Me(32926)}function Le(ie){N!==ie&&(ie?n.frontFace(2304):n.frontFace(2305),N=ie)}function nt(ie){ie!==BW?(ke(2884),ie!==L&&(ie===TT?n.cullFace(1029):ie===UW?n.cullFace(1028):n.cullFace(1032))):Me(2884),L=ie}function Ke(ie){ie!==V&&(H&&n.lineWidth(ie),V=ie)}function ot(ie,_e,Fe){ie?(ke(32823),(O!==_e||P!==Fe)&&(n.polygonOffset(_e,Fe),O=_e,P=Fe)):Me(32823)}function vt(ie){ie?ke(3089):Me(3089)}function Dt(ie){ie===void 0&&(ie=33984+W-1),$!==ie&&(n.activeTexture(ie),$=ie)}function q(ie,_e,Fe){Fe===void 0&&($===null?Fe=33984+W-1:Fe=$);let rt=U[Fe];rt===void 0&&(rt={type:void 0,texture:void 0},U[Fe]=rt),(rt.type!==ie||rt.texture!==_e)&&($!==Fe&&(n.activeTexture(Fe),$=Fe),n.bindTexture(ie,_e||Q[ie]),rt.type=ie,rt.texture=_e)}function z(){const ie=U[$];ie!==void 0&&ie.type!==void 0&&(n.bindTexture(ie.type,null),ie.type=void 0,ie.texture=void 0)}function ge(){try{n.compressedTexImage2D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function Pe(){try{n.compressedTexImage3D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function ze(){try{n.texSubImage2D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function Xe(){try{n.texSubImage3D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function ft(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function Ye(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function Te(){try{n.texStorage2D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function ht(){try{n.texStorage3D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function J(){try{n.texImage2D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function ve(){try{n.texImage3D.apply(n,arguments)}catch(ie){console.error("THREE.WebGLState:",ie)}}function Oe(ie){te.equals(ie)===!1&&(n.scissor(ie.x,ie.y,ie.z,ie.w),te.copy(ie))}function Ge(ie){oe.equals(ie)===!1&&(n.viewport(ie.x,ie.y,ie.z,ie.w),oe.copy(ie))}function St(ie,_e){let Fe=h.get(_e);Fe===void 0&&(Fe=new WeakMap,h.set(_e,Fe));let rt=Fe.get(ie);rt===void 0&&(rt=n.getUniformBlockIndex(_e,ie.name),Fe.set(ie,rt))}function Xt(ie,_e){const rt=h.get(_e).get(ie);u.get(ie)!==rt&&(n.uniformBlockBinding(_e,rt,ie.__bindingPointIndex),u.set(ie,rt))}function Dn(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),s===!0&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),d={},$=null,U={},f={},m=new WeakMap,x=[],y=null,v=!1,w=null,b=null,S=null,C=null,E=null,k=null,I=null,A=!1,N=null,L=null,V=null,O=null,P=null,te.set(0,0,n.canvas.width,n.canvas.height),oe.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:ke,disable:Me,bindFramebuffer:De,drawBuffers:Ee,useProgram:Be,setBlending:Re,setMaterial:We,setFlipSided:Le,setCullFace:nt,setLineWidth:Ke,setPolygonOffset:ot,setScissorTest:vt,activeTexture:Dt,bindTexture:q,unbindTexture:z,compressedTexImage2D:ge,compressedTexImage3D:Pe,texImage2D:J,texImage3D:ve,updateUBOMapping:St,uniformBlockBinding:Xt,texStorage2D:Te,texStorage3D:ht,texSubImage2D:ze,texSubImage3D:Xe,compressedTexSubImage2D:ft,compressedTexSubImage3D:Ye,scissor:Oe,viewport:Ge,reset:Dn}}function GSe(n,e,t,s,i,r,o){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,h=i.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,f=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),m=new WeakMap;let x;const y=new WeakMap;let v=!1;try{v=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function w(q,z){return v?new OffscreenCanvas(q,z):Zm("canvas")}function b(q,z,ge,Pe){let ze=1;if((q.width>Pe||q.height>Pe)&&(ze=Pe/Math.max(q.width,q.height)),ze<1||z===!0)if(typeof HTMLImageElement<"u"&&q instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&q instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&q instanceof ImageBitmap){const Xe=z?U1:Math.floor,ft=Xe(ze*q.width),Ye=Xe(ze*q.height);x===void 0&&(x=w(ft,Ye));const Te=ge?w(ft,Ye):x;return Te.width=ft,Te.height=Ye,Te.getContext("2d").drawImage(q,0,0,ft,Ye),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+q.width+"x"+q.height+") to ("+ft+"x"+Ye+")."),Te}else return"data"in q&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+q.width+"x"+q.height+")."),q;return q}function S(q){return QT(q.width)&&QT(q.height)}function C(q){return a?!1:q.wrapS!==Si||q.wrapT!==Si||q.minFilter!==ws&&q.minFilter!==us}function E(q,z){return q.generateMipmaps&&z&&q.minFilter!==ws&&q.minFilter!==us}function k(q){n.generateMipmap(q)}function I(q,z,ge,Pe,ze=!1){if(a===!1)return z;if(q!==null){if(n[q]!==void 0)return n[q];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+q+"'")}let Xe=z;return z===6403&&(ge===5126&&(Xe=33326),ge===5131&&(Xe=33325),ge===5121&&(Xe=33321)),z===33319&&(ge===5126&&(Xe=33328),ge===5131&&(Xe=33327),ge===5121&&(Xe=33323)),z===6408&&(ge===5126&&(Xe=34836),ge===5131&&(Xe=34842),ge===5121&&(Xe=Pe===En&&ze===!1?35907:32856),ge===32819&&(Xe=32854),ge===32820&&(Xe=32855)),(Xe===33325||Xe===33326||Xe===33327||Xe===33328||Xe===34842||Xe===34836)&&e.get("EXT_color_buffer_float"),Xe}function A(q,z,ge){return E(q,ge)===!0||q.isFramebufferTexture&&q.minFilter!==ws&&q.minFilter!==us?Math.log2(Math.max(z.width,z.height))+1:q.mipmaps!==void 0&&q.mipmaps.length>0?q.mipmaps.length:q.isCompressedTexture&&Array.isArray(q.image)?z.mipmaps.length:1}function N(q){return q===ws||q===O1||q===z1?9728:9729}function L(q){const z=q.target;z.removeEventListener("dispose",L),O(z),z.isVideoTexture&&m.delete(z)}function V(q){const z=q.target;z.removeEventListener("dispose",V),W(z)}function O(q){const z=s.get(q);if(z.__webglInit===void 0)return;const ge=q.source,Pe=y.get(ge);if(Pe){const ze=Pe[z.__cacheKey];ze.usedTimes--,ze.usedTimes===0&&P(q),Object.keys(Pe).length===0&&y.delete(ge)}s.remove(q)}function P(q){const z=s.get(q);n.deleteTexture(z.__webglTexture);const ge=q.source,Pe=y.get(ge);delete Pe[z.__cacheKey],o.memory.textures--}function W(q){const z=q.texture,ge=s.get(q),Pe=s.get(z);if(Pe.__webglTexture!==void 0&&(n.deleteTexture(Pe.__webglTexture),o.memory.textures--),q.depthTexture&&q.depthTexture.dispose(),q.isWebGLCubeRenderTarget)for(let ze=0;ze<6;ze++)n.deleteFramebuffer(ge.__webglFramebuffer[ze]),ge.__webglDepthbuffer&&n.deleteRenderbuffer(ge.__webglDepthbuffer[ze]);else{if(n.deleteFramebuffer(ge.__webglFramebuffer),ge.__webglDepthbuffer&&n.deleteRenderbuffer(ge.__webglDepthbuffer),ge.__webglMultisampledFramebuffer&&n.deleteFramebuffer(ge.__webglMultisampledFramebuffer),ge.__webglColorRenderbuffer)for(let ze=0;ze<ge.__webglColorRenderbuffer.length;ze++)ge.__webglColorRenderbuffer[ze]&&n.deleteRenderbuffer(ge.__webglColorRenderbuffer[ze]);ge.__webglDepthRenderbuffer&&n.deleteRenderbuffer(ge.__webglDepthRenderbuffer)}if(q.isWebGLMultipleRenderTargets)for(let ze=0,Xe=z.length;ze<Xe;ze++){const ft=s.get(z[ze]);ft.__webglTexture&&(n.deleteTexture(ft.__webglTexture),o.memory.textures--),s.remove(z[ze])}s.remove(z),s.remove(q)}let H=0;function Y(){H=0}function D(){const q=H;return q>=l&&console.warn("THREE.WebGLTextures: Trying to use "+q+" texture units while this GPU supports only "+l),H+=1,q}function $(q){const z=[];return z.push(q.wrapS),z.push(q.wrapT),z.push(q.wrapR||0),z.push(q.magFilter),z.push(q.minFilter),z.push(q.anisotropy),z.push(q.internalFormat),z.push(q.format),z.push(q.type),z.push(q.generateMipmaps),z.push(q.premultiplyAlpha),z.push(q.flipY),z.push(q.unpackAlignment),z.push(q.encoding),z.join()}function U(q,z){const ge=s.get(q);if(q.isVideoTexture&&vt(q),q.isRenderTargetTexture===!1&&q.version>0&&ge.__version!==q.version){const Pe=q.image;if(Pe===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Pe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Me(ge,q,z);return}}t.bindTexture(3553,ge.__webglTexture,33984+z)}function B(q,z){const ge=s.get(q);if(q.version>0&&ge.__version!==q.version){Me(ge,q,z);return}t.bindTexture(35866,ge.__webglTexture,33984+z)}function X(q,z){const ge=s.get(q);if(q.version>0&&ge.__version!==q.version){Me(ge,q,z);return}t.bindTexture(32879,ge.__webglTexture,33984+z)}function te(q,z){const ge=s.get(q);if(q.version>0&&ge.__version!==q.version){De(ge,q,z);return}t.bindTexture(34067,ge.__webglTexture,33984+z)}const oe={[Gm]:10497,[Si]:33071,[Hm]:33648},ue={[ws]:9728,[O1]:9984,[z1]:9986,[us]:9729,[Zk]:9985,[Nh]:9987};function Q(q,z,ge){if(ge?(n.texParameteri(q,10242,oe[z.wrapS]),n.texParameteri(q,10243,oe[z.wrapT]),(q===32879||q===35866)&&n.texParameteri(q,32882,oe[z.wrapR]),n.texParameteri(q,10240,ue[z.magFilter]),n.texParameteri(q,10241,ue[z.minFilter])):(n.texParameteri(q,10242,33071),n.texParameteri(q,10243,33071),(q===32879||q===35866)&&n.texParameteri(q,32882,33071),(z.wrapS!==Si||z.wrapT!==Si)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(q,10240,N(z.magFilter)),n.texParameteri(q,10241,N(z.minFilter)),z.minFilter!==ws&&z.minFilter!==us&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const Pe=e.get("EXT_texture_filter_anisotropic");if(z.type===il&&e.has("OES_texture_float_linear")===!1||a===!1&&z.type===vf&&e.has("OES_texture_half_float_linear")===!1)return;(z.anisotropy>1||s.get(z).__currentAnisotropy)&&(n.texParameterf(q,Pe.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(z.anisotropy,i.getMaxAnisotropy())),s.get(z).__currentAnisotropy=z.anisotropy)}}function ke(q,z){let ge=!1;q.__webglInit===void 0&&(q.__webglInit=!0,z.addEventListener("dispose",L));const Pe=z.source;let ze=y.get(Pe);ze===void 0&&(ze={},y.set(Pe,ze));const Xe=$(z);if(Xe!==q.__cacheKey){ze[Xe]===void 0&&(ze[Xe]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,ge=!0),ze[Xe].usedTimes++;const ft=ze[q.__cacheKey];ft!==void 0&&(ze[q.__cacheKey].usedTimes--,ft.usedTimes===0&&P(z)),q.__cacheKey=Xe,q.__webglTexture=ze[Xe].texture}return ge}function Me(q,z,ge){let Pe=3553;(z.isDataArrayTexture||z.isCompressedArrayTexture)&&(Pe=35866),z.isData3DTexture&&(Pe=32879);const ze=ke(q,z),Xe=z.source;t.bindTexture(Pe,q.__webglTexture,33984+ge);const ft=s.get(Xe);if(Xe.version!==ft.__version||ze===!0){t.activeTexture(33984+ge),n.pixelStorei(37440,z.flipY),n.pixelStorei(37441,z.premultiplyAlpha),n.pixelStorei(3317,z.unpackAlignment),n.pixelStorei(37443,0);const Ye=C(z)&&S(z.image)===!1;let Te=b(z.image,Ye,!1,u);Te=Dt(z,Te);const ht=S(Te)||a,J=r.convert(z.format,z.encoding);let ve=r.convert(z.type),Oe=I(z.internalFormat,J,ve,z.encoding,z.isVideoTexture);Q(Pe,z,ht);let Ge;const St=z.mipmaps,Xt=a&&z.isVideoTexture!==!0,Dn=ft.__version===void 0||ze===!0,ie=A(z,Te,ht);if(z.isDepthTexture)Oe=6402,a?z.type===il?Oe=36012:z.type===sc?Oe=33190:z.type===Vu?Oe=35056:Oe=33189:z.type===il&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),z.format===gc&&Oe===6402&&z.type!==Jk&&z.type!==sc&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),z.type=sc,ve=r.convert(z.type)),z.format===ph&&Oe===6402&&(Oe=34041,z.type!==Vu&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),z.type=Vu,ve=r.convert(z.type))),Dn&&(Xt?t.texStorage2D(3553,1,Oe,Te.width,Te.height):t.texImage2D(3553,0,Oe,Te.width,Te.height,0,J,ve,null));else if(z.isDataTexture)if(St.length>0&&ht){Xt&&Dn&&t.texStorage2D(3553,ie,Oe,St[0].width,St[0].height);for(let _e=0,Fe=St.length;_e<Fe;_e++)Ge=St[_e],Xt?t.texSubImage2D(3553,_e,0,0,Ge.width,Ge.height,J,ve,Ge.data):t.texImage2D(3553,_e,Oe,Ge.width,Ge.height,0,J,ve,Ge.data);z.generateMipmaps=!1}else Xt?(Dn&&t.texStorage2D(3553,ie,Oe,Te.width,Te.height),t.texSubImage2D(3553,0,0,0,Te.width,Te.height,J,ve,Te.data)):t.texImage2D(3553,0,Oe,Te.width,Te.height,0,J,ve,Te.data);else if(z.isCompressedTexture)if(z.isCompressedArrayTexture){Xt&&Dn&&t.texStorage3D(35866,ie,Oe,St[0].width,St[0].height,Te.depth);for(let _e=0,Fe=St.length;_e<Fe;_e++)Ge=St[_e],z.format!==br?J!==null?Xt?t.compressedTexSubImage3D(35866,_e,0,0,0,Ge.width,Ge.height,Te.depth,J,Ge.data,0,0):t.compressedTexImage3D(35866,_e,Oe,Ge.width,Ge.height,Te.depth,0,Ge.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Xt?t.texSubImage3D(35866,_e,0,0,0,Ge.width,Ge.height,Te.depth,J,ve,Ge.data):t.texImage3D(35866,_e,Oe,Ge.width,Ge.height,Te.depth,0,J,ve,Ge.data)}else{Xt&&Dn&&t.texStorage2D(3553,ie,Oe,St[0].width,St[0].height);for(let _e=0,Fe=St.length;_e<Fe;_e++)Ge=St[_e],z.format!==br?J!==null?Xt?t.compressedTexSubImage2D(3553,_e,0,0,Ge.width,Ge.height,J,Ge.data):t.compressedTexImage2D(3553,_e,Oe,Ge.width,Ge.height,0,Ge.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Xt?t.texSubImage2D(3553,_e,0,0,Ge.width,Ge.height,J,ve,Ge.data):t.texImage2D(3553,_e,Oe,Ge.width,Ge.height,0,J,ve,Ge.data)}else if(z.isDataArrayTexture)Xt?(Dn&&t.texStorage3D(35866,ie,Oe,Te.width,Te.height,Te.depth),t.texSubImage3D(35866,0,0,0,0,Te.width,Te.height,Te.depth,J,ve,Te.data)):t.texImage3D(35866,0,Oe,Te.width,Te.height,Te.depth,0,J,ve,Te.data);else if(z.isData3DTexture)Xt?(Dn&&t.texStorage3D(32879,ie,Oe,Te.width,Te.height,Te.depth),t.texSubImage3D(32879,0,0,0,0,Te.width,Te.height,Te.depth,J,ve,Te.data)):t.texImage3D(32879,0,Oe,Te.width,Te.height,Te.depth,0,J,ve,Te.data);else if(z.isFramebufferTexture){if(Dn)if(Xt)t.texStorage2D(3553,ie,Oe,Te.width,Te.height);else{let _e=Te.width,Fe=Te.height;for(let rt=0;rt<ie;rt++)t.texImage2D(3553,rt,Oe,_e,Fe,0,J,ve,null),_e>>=1,Fe>>=1}}else if(St.length>0&&ht){Xt&&Dn&&t.texStorage2D(3553,ie,Oe,St[0].width,St[0].height);for(let _e=0,Fe=St.length;_e<Fe;_e++)Ge=St[_e],Xt?t.texSubImage2D(3553,_e,0,0,J,ve,Ge):t.texImage2D(3553,_e,Oe,J,ve,Ge);z.generateMipmaps=!1}else Xt?(Dn&&t.texStorage2D(3553,ie,Oe,Te.width,Te.height),t.texSubImage2D(3553,0,0,0,J,ve,Te)):t.texImage2D(3553,0,Oe,J,ve,Te);E(z,ht)&&k(Pe),ft.__version=Xe.version,z.onUpdate&&z.onUpdate(z)}q.__version=z.version}function De(q,z,ge){if(z.image.length!==6)return;const Pe=ke(q,z),ze=z.source;t.bindTexture(34067,q.__webglTexture,33984+ge);const Xe=s.get(ze);if(ze.version!==Xe.__version||Pe===!0){t.activeTexture(33984+ge),n.pixelStorei(37440,z.flipY),n.pixelStorei(37441,z.premultiplyAlpha),n.pixelStorei(3317,z.unpackAlignment),n.pixelStorei(37443,0);const ft=z.isCompressedTexture||z.image[0].isCompressedTexture,Ye=z.image[0]&&z.image[0].isDataTexture,Te=[];for(let _e=0;_e<6;_e++)!ft&&!Ye?Te[_e]=b(z.image[_e],!1,!0,c):Te[_e]=Ye?z.image[_e].image:z.image[_e],Te[_e]=Dt(z,Te[_e]);const ht=Te[0],J=S(ht)||a,ve=r.convert(z.format,z.encoding),Oe=r.convert(z.type),Ge=I(z.internalFormat,ve,Oe,z.encoding),St=a&&z.isVideoTexture!==!0,Xt=Xe.__version===void 0||Pe===!0;let Dn=A(z,ht,J);Q(34067,z,J);let ie;if(ft){St&&Xt&&t.texStorage2D(34067,Dn,Ge,ht.width,ht.height);for(let _e=0;_e<6;_e++){ie=Te[_e].mipmaps;for(let Fe=0;Fe<ie.length;Fe++){const rt=ie[Fe];z.format!==br?ve!==null?St?t.compressedTexSubImage2D(34069+_e,Fe,0,0,rt.width,rt.height,ve,rt.data):t.compressedTexImage2D(34069+_e,Fe,Ge,rt.width,rt.height,0,rt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):St?t.texSubImage2D(34069+_e,Fe,0,0,rt.width,rt.height,ve,Oe,rt.data):t.texImage2D(34069+_e,Fe,Ge,rt.width,rt.height,0,ve,Oe,rt.data)}}}else{ie=z.mipmaps,St&&Xt&&(ie.length>0&&Dn++,t.texStorage2D(34067,Dn,Ge,Te[0].width,Te[0].height));for(let _e=0;_e<6;_e++)if(Ye){St?t.texSubImage2D(34069+_e,0,0,0,Te[_e].width,Te[_e].height,ve,Oe,Te[_e].data):t.texImage2D(34069+_e,0,Ge,Te[_e].width,Te[_e].height,0,ve,Oe,Te[_e].data);for(let Fe=0;Fe<ie.length;Fe++){const gt=ie[Fe].image[_e].image;St?t.texSubImage2D(34069+_e,Fe+1,0,0,gt.width,gt.height,ve,Oe,gt.data):t.texImage2D(34069+_e,Fe+1,Ge,gt.width,gt.height,0,ve,Oe,gt.data)}}else{St?t.texSubImage2D(34069+_e,0,0,0,ve,Oe,Te[_e]):t.texImage2D(34069+_e,0,Ge,ve,Oe,Te[_e]);for(let Fe=0;Fe<ie.length;Fe++){const rt=ie[Fe];St?t.texSubImage2D(34069+_e,Fe+1,0,0,ve,Oe,rt.image[_e]):t.texImage2D(34069+_e,Fe+1,Ge,ve,Oe,rt.image[_e])}}}E(z,J)&&k(34067),Xe.__version=ze.version,z.onUpdate&&z.onUpdate(z)}q.__version=z.version}function Ee(q,z,ge,Pe,ze){const Xe=r.convert(ge.format,ge.encoding),ft=r.convert(ge.type),Ye=I(ge.internalFormat,Xe,ft,ge.encoding);s.get(z).__hasExternalTextures||(ze===32879||ze===35866?t.texImage3D(ze,0,Ye,z.width,z.height,z.depth,0,Xe,ft,null):t.texImage2D(ze,0,Ye,z.width,z.height,0,Xe,ft,null)),t.bindFramebuffer(36160,q),ot(z)?d.framebufferTexture2DMultisampleEXT(36160,Pe,ze,s.get(ge).__webglTexture,0,Ke(z)):(ze===3553||ze>=34069&&ze<=34074)&&n.framebufferTexture2D(36160,Pe,ze,s.get(ge).__webglTexture,0),t.bindFramebuffer(36160,null)}function Be(q,z,ge){if(n.bindRenderbuffer(36161,q),z.depthBuffer&&!z.stencilBuffer){let Pe=33189;if(ge||ot(z)){const ze=z.depthTexture;ze&&ze.isDepthTexture&&(ze.type===il?Pe=36012:ze.type===sc&&(Pe=33190));const Xe=Ke(z);ot(z)?d.renderbufferStorageMultisampleEXT(36161,Xe,Pe,z.width,z.height):n.renderbufferStorageMultisample(36161,Xe,Pe,z.width,z.height)}else n.renderbufferStorage(36161,Pe,z.width,z.height);n.framebufferRenderbuffer(36160,36096,36161,q)}else if(z.depthBuffer&&z.stencilBuffer){const Pe=Ke(z);ge&&ot(z)===!1?n.renderbufferStorageMultisample(36161,Pe,35056,z.width,z.height):ot(z)?d.renderbufferStorageMultisampleEXT(36161,Pe,35056,z.width,z.height):n.renderbufferStorage(36161,34041,z.width,z.height),n.framebufferRenderbuffer(36160,33306,36161,q)}else{const Pe=z.isWebGLMultipleRenderTargets===!0?z.texture:[z.texture];for(let ze=0;ze<Pe.length;ze++){const Xe=Pe[ze],ft=r.convert(Xe.format,Xe.encoding),Ye=r.convert(Xe.type),Te=I(Xe.internalFormat,ft,Ye,Xe.encoding),ht=Ke(z);ge&&ot(z)===!1?n.renderbufferStorageMultisample(36161,ht,Te,z.width,z.height):ot(z)?d.renderbufferStorageMultisampleEXT(36161,ht,Te,z.width,z.height):n.renderbufferStorage(36161,Te,z.width,z.height)}}n.bindRenderbuffer(36161,null)}function ye(q,z){if(z&&z.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,q),!(z.depthTexture&&z.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(z.depthTexture).__webglTexture||z.depthTexture.image.width!==z.width||z.depthTexture.image.height!==z.height)&&(z.depthTexture.image.width=z.width,z.depthTexture.image.height=z.height,z.depthTexture.needsUpdate=!0),U(z.depthTexture,0);const Pe=s.get(z.depthTexture).__webglTexture,ze=Ke(z);if(z.depthTexture.format===gc)ot(z)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,Pe,0,ze):n.framebufferTexture2D(36160,36096,3553,Pe,0);else if(z.depthTexture.format===ph)ot(z)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,Pe,0,ze):n.framebufferTexture2D(36160,33306,3553,Pe,0);else throw new Error("Unknown depthTexture format")}function fe(q){const z=s.get(q),ge=q.isWebGLCubeRenderTarget===!0;if(q.depthTexture&&!z.__autoAllocateDepthBuffer){if(ge)throw new Error("target.depthTexture not supported in Cube render targets");ye(z.__webglFramebuffer,q)}else if(ge){z.__webglDepthbuffer=[];for(let Pe=0;Pe<6;Pe++)t.bindFramebuffer(36160,z.__webglFramebuffer[Pe]),z.__webglDepthbuffer[Pe]=n.createRenderbuffer(),Be(z.__webglDepthbuffer[Pe],q,!1)}else t.bindFramebuffer(36160,z.__webglFramebuffer),z.__webglDepthbuffer=n.createRenderbuffer(),Be(z.__webglDepthbuffer,q,!1);t.bindFramebuffer(36160,null)}function Re(q,z,ge){const Pe=s.get(q);z!==void 0&&Ee(Pe.__webglFramebuffer,q,q.texture,36064,3553),ge!==void 0&&fe(q)}function We(q){const z=q.texture,ge=s.get(q),Pe=s.get(z);q.addEventListener("dispose",V),q.isWebGLMultipleRenderTargets!==!0&&(Pe.__webglTexture===void 0&&(Pe.__webglTexture=n.createTexture()),Pe.__version=z.version,o.memory.textures++);const ze=q.isWebGLCubeRenderTarget===!0,Xe=q.isWebGLMultipleRenderTargets===!0,ft=S(q)||a;if(ze){ge.__webglFramebuffer=[];for(let Ye=0;Ye<6;Ye++)ge.__webglFramebuffer[Ye]=n.createFramebuffer()}else{if(ge.__webglFramebuffer=n.createFramebuffer(),Xe)if(i.drawBuffers){const Ye=q.texture;for(let Te=0,ht=Ye.length;Te<ht;Te++){const J=s.get(Ye[Te]);J.__webglTexture===void 0&&(J.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&q.samples>0&&ot(q)===!1){const Ye=Xe?z:[z];ge.__webglMultisampledFramebuffer=n.createFramebuffer(),ge.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,ge.__webglMultisampledFramebuffer);for(let Te=0;Te<Ye.length;Te++){const ht=Ye[Te];ge.__webglColorRenderbuffer[Te]=n.createRenderbuffer(),n.bindRenderbuffer(36161,ge.__webglColorRenderbuffer[Te]);const J=r.convert(ht.format,ht.encoding),ve=r.convert(ht.type),Oe=I(ht.internalFormat,J,ve,ht.encoding,q.isXRRenderTarget===!0),Ge=Ke(q);n.renderbufferStorageMultisample(36161,Ge,Oe,q.width,q.height),n.framebufferRenderbuffer(36160,36064+Te,36161,ge.__webglColorRenderbuffer[Te])}n.bindRenderbuffer(36161,null),q.depthBuffer&&(ge.__webglDepthRenderbuffer=n.createRenderbuffer(),Be(ge.__webglDepthRenderbuffer,q,!0)),t.bindFramebuffer(36160,null)}}if(ze){t.bindTexture(34067,Pe.__webglTexture),Q(34067,z,ft);for(let Ye=0;Ye<6;Ye++)Ee(ge.__webglFramebuffer[Ye],q,z,36064,34069+Ye);E(z,ft)&&k(34067),t.unbindTexture()}else if(Xe){const Ye=q.texture;for(let Te=0,ht=Ye.length;Te<ht;Te++){const J=Ye[Te],ve=s.get(J);t.bindTexture(3553,ve.__webglTexture),Q(3553,J,ft),Ee(ge.__webglFramebuffer,q,J,36064+Te,3553),E(J,ft)&&k(3553)}t.unbindTexture()}else{let Ye=3553;(q.isWebGL3DRenderTarget||q.isWebGLArrayRenderTarget)&&(a?Ye=q.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(Ye,Pe.__webglTexture),Q(Ye,z,ft),Ee(ge.__webglFramebuffer,q,z,36064,Ye),E(z,ft)&&k(Ye),t.unbindTexture()}q.depthBuffer&&fe(q)}function Le(q){const z=S(q)||a,ge=q.isWebGLMultipleRenderTargets===!0?q.texture:[q.texture];for(let Pe=0,ze=ge.length;Pe<ze;Pe++){const Xe=ge[Pe];if(E(Xe,z)){const ft=q.isWebGLCubeRenderTarget?34067:3553,Ye=s.get(Xe).__webglTexture;t.bindTexture(ft,Ye),k(ft),t.unbindTexture()}}}function nt(q){if(a&&q.samples>0&&ot(q)===!1){const z=q.isWebGLMultipleRenderTargets?q.texture:[q.texture],ge=q.width,Pe=q.height;let ze=16384;const Xe=[],ft=q.stencilBuffer?33306:36096,Ye=s.get(q),Te=q.isWebGLMultipleRenderTargets===!0;if(Te)for(let ht=0;ht<z.length;ht++)t.bindFramebuffer(36160,Ye.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+ht,36161,null),t.bindFramebuffer(36160,Ye.__webglFramebuffer),n.framebufferTexture2D(36009,36064+ht,3553,null,0);t.bindFramebuffer(36008,Ye.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,Ye.__webglFramebuffer);for(let ht=0;ht<z.length;ht++){Xe.push(36064+ht),q.depthBuffer&&Xe.push(ft);const J=Ye.__ignoreDepthValues!==void 0?Ye.__ignoreDepthValues:!1;if(J===!1&&(q.depthBuffer&&(ze|=256),q.stencilBuffer&&(ze|=1024)),Te&&n.framebufferRenderbuffer(36008,36064,36161,Ye.__webglColorRenderbuffer[ht]),J===!0&&(n.invalidateFramebuffer(36008,[ft]),n.invalidateFramebuffer(36009,[ft])),Te){const ve=s.get(z[ht]).__webglTexture;n.framebufferTexture2D(36009,36064,3553,ve,0)}n.blitFramebuffer(0,0,ge,Pe,0,0,ge,Pe,ze,9728),f&&n.invalidateFramebuffer(36008,Xe)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),Te)for(let ht=0;ht<z.length;ht++){t.bindFramebuffer(36160,Ye.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+ht,36161,Ye.__webglColorRenderbuffer[ht]);const J=s.get(z[ht]).__webglTexture;t.bindFramebuffer(36160,Ye.__webglFramebuffer),n.framebufferTexture2D(36009,36064+ht,3553,J,0)}t.bindFramebuffer(36009,Ye.__webglMultisampledFramebuffer)}}function Ke(q){return Math.min(h,q.samples)}function ot(q){const z=s.get(q);return a&&q.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&z.__useRenderToTexture!==!1}function vt(q){const z=o.render.frame;m.get(q)!==z&&(m.set(q,z),q.update())}function Dt(q,z){const ge=q.encoding,Pe=q.format,ze=q.type;return q.isCompressedTexture===!0||q.isVideoTexture===!0||q.format===B1||ge!==gl&&(ge===En?a===!1?e.has("EXT_sRGB")===!0&&Pe===br?(q.format=B1,q.minFilter=us,q.generateMipmaps=!1):z=nA.sRGBToLinear(z):(Pe!==br||ze!==kc)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",ge)),z}this.allocateTextureUnit=D,this.resetTextureUnits=Y,this.setTexture2D=U,this.setTexture2DArray=B,this.setTexture3D=X,this.setTextureCube=te,this.rebindTextures=Re,this.setupRenderTarget=We,this.updateRenderTargetMipmap=Le,this.updateMultisampleRenderTarget=nt,this.setupDepthRenderbuffer=fe,this.setupFrameBufferTexture=Ee,this.useMultisampledRTT=ot}function jG(n,e,t){const s=t.isWebGL2;function i(r,o=null){let a;if(r===kc)return 5121;if(r===xG)return 32819;if(r===yG)return 32820;if(r===pG)return 5120;if(r===mG)return 5122;if(r===Jk)return 5123;if(r===gG)return 5124;if(r===sc)return 5125;if(r===il)return 5126;if(r===vf)return s?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(r===vG)return 6406;if(r===br)return 6408;if(r===bG)return 6409;if(r===SG)return 6410;if(r===gc)return 6402;if(r===ph)return 34041;if(r===wG)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(r===B1)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(r===_G)return 6403;if(r===CG)return 36244;if(r===TG)return 33319;if(r===IG)return 33320;if(r===EG)return 36249;if(r===Nv||r===Rv||r===Dv||r===Lv)if(o===En)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(r===Nv)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===Rv)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===Dv)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===Lv)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(r===Nv)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Rv)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===Dv)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===Lv)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===NT||r===RT||r===DT||r===LT)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(r===NT)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===RT)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===DT)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===LT)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===MG)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===PT||r===$T)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(r===PT)return o===En?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(r===$T)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===FT||r===OT||r===zT||r===BT||r===UT||r===VT||r===WT||r===GT||r===HT||r===XT||r===jT||r===qT||r===KT||r===YT)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(r===FT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===OT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===zT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===BT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===UT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===VT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===WT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===GT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===HT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===XT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===jT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===qT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===KT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===YT)return o===En?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===ZT)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(r===ZT)return o===En?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return r===Vu?s?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[r]!==void 0?n[r]:null}return{convert:i}}class qG extends Un{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class $d extends fn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const HSe={type:"move"};class CC{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new $d,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new $d,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new G,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new G),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new $d,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new G,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new G),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let i=null,r=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const x of e.hand.values()){const y=t.getJointPose(x,s),v=this._getHandJoint(c,x);y!==null&&(v.matrix.fromArray(y.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.jointRadius=y.radius),v.visible=y!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),f=.02,m=.005;c.inputState.pinching&&d>f+m?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=f-m&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,s),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(i=t.getPose(e.targetRaySpace,s),i===null&&r!==null&&(i=r),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(HSe)))}return a!==null&&(a.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new $d;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class KG extends ns{constructor(e,t,s,i,r,o,a,l,c,u){if(u=u!==void 0?u:gc,u!==gc&&u!==ph)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&u===gc&&(s=sc),s===void 0&&u===ph&&(s=Vu),super(null,i,r,o,a,l,u,s,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:ws,this.minFilter=l!==void 0?l:ws,this.flipY=!1,this.generateMipmaps=!1}}class XSe extends Na{constructor(e,t){super();const s=this;let i=null,r=1,o=null,a="local-floor",l=null,c=null,u=null,h=null,d=null,f=null;const m=t.getContextAttributes();let x=null,y=null;const v=[],w=[],b=new Set,S=new Map,C=new Un;C.layers.enable(1),C.viewport=new rn;const E=new Un;E.layers.enable(2),E.viewport=new rn;const k=[C,E],I=new qG;I.layers.enable(1),I.layers.enable(2);let A=null,N=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(B){let X=v[B];return X===void 0&&(X=new CC,v[B]=X),X.getTargetRaySpace()},this.getControllerGrip=function(B){let X=v[B];return X===void 0&&(X=new CC,v[B]=X),X.getGripSpace()},this.getHand=function(B){let X=v[B];return X===void 0&&(X=new CC,v[B]=X),X.getHandSpace()};function L(B){const X=w.indexOf(B.inputSource);if(X===-1)return;const te=v[X];te!==void 0&&te.dispatchEvent({type:B.type,data:B.inputSource})}function V(){i.removeEventListener("select",L),i.removeEventListener("selectstart",L),i.removeEventListener("selectend",L),i.removeEventListener("squeeze",L),i.removeEventListener("squeezestart",L),i.removeEventListener("squeezeend",L),i.removeEventListener("end",V),i.removeEventListener("inputsourceschange",O);for(let B=0;B<v.length;B++){const X=w[B];X!==null&&(w[B]=null,v[B].disconnect(X))}A=null,N=null,e.setRenderTarget(x),d=null,h=null,u=null,i=null,y=null,U.stop(),s.isPresenting=!1,s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(B){r=B,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(B){a=B,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||o},this.setReferenceSpace=function(B){l=B},this.getBaseLayer=function(){return h!==null?h:d},this.getBinding=function(){return u},this.getFrame=function(){return f},this.getSession=function(){return i},this.setSession=async function(B){if(i=B,i!==null){if(x=e.getRenderTarget(),i.addEventListener("select",L),i.addEventListener("selectstart",L),i.addEventListener("selectend",L),i.addEventListener("squeeze",L),i.addEventListener("squeezestart",L),i.addEventListener("squeezeend",L),i.addEventListener("end",V),i.addEventListener("inputsourceschange",O),m.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const X={antialias:i.renderState.layers===void 0?m.antialias:!0,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(i,t,X),i.updateRenderState({baseLayer:d}),y=new mo(d.framebufferWidth,d.framebufferHeight,{format:br,type:kc,encoding:e.outputEncoding,stencilBuffer:m.stencil})}else{let X=null,te=null,oe=null;m.depth&&(oe=m.stencil?35056:33190,X=m.stencil?ph:gc,te=m.stencil?Vu:sc);const ue={colorFormat:32856,depthFormat:oe,scaleFactor:r};u=new XRWebGLBinding(i,t),h=u.createProjectionLayer(ue),i.updateRenderState({layers:[h]}),y=new mo(h.textureWidth,h.textureHeight,{format:br,type:kc,depthTexture:new KG(h.textureWidth,h.textureHeight,te,void 0,void 0,void 0,void 0,void 0,void 0,X),stencilBuffer:m.stencil,encoding:e.outputEncoding,samples:m.antialias?4:0});const Q=e.properties.get(y);Q.__ignoreDepthValues=h.ignoreDepthValues}y.isXRRenderTarget=!0,this.setFoveation(1),l=null,o=await i.requestReferenceSpace(a),U.setContext(i),U.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}};function O(B){for(let X=0;X<B.removed.length;X++){const te=B.removed[X],oe=w.indexOf(te);oe>=0&&(w[oe]=null,v[oe].disconnect(te))}for(let X=0;X<B.added.length;X++){const te=B.added[X];let oe=w.indexOf(te);if(oe===-1){for(let Q=0;Q<v.length;Q++)if(Q>=w.length){w.push(te),oe=Q;break}else if(w[Q]===null){w[Q]=te,oe=Q;break}if(oe===-1)break}const ue=v[oe];ue&&ue.connect(te)}}const P=new G,W=new G;function H(B,X,te){P.setFromMatrixPosition(X.matrixWorld),W.setFromMatrixPosition(te.matrixWorld);const oe=P.distanceTo(W),ue=X.projectionMatrix.elements,Q=te.projectionMatrix.elements,ke=ue[14]/(ue[10]-1),Me=ue[14]/(ue[10]+1),De=(ue[9]+1)/ue[5],Ee=(ue[9]-1)/ue[5],Be=(ue[8]-1)/ue[0],ye=(Q[8]+1)/Q[0],fe=ke*Be,Re=ke*ye,We=oe/(-Be+ye),Le=We*-Be;X.matrixWorld.decompose(B.position,B.quaternion,B.scale),B.translateX(Le),B.translateZ(We),B.matrixWorld.compose(B.position,B.quaternion,B.scale),B.matrixWorldInverse.copy(B.matrixWorld).invert();const nt=ke+We,Ke=Me+We,ot=fe-Le,vt=Re+(oe-Le),Dt=De*Me/Ke*nt,q=Ee*Me/Ke*nt;B.projectionMatrix.makePerspective(ot,vt,Dt,q,nt,Ke)}function Y(B,X){X===null?B.matrixWorld.copy(B.matrix):B.matrixWorld.multiplyMatrices(X.matrixWorld,B.matrix),B.matrixWorldInverse.copy(B.matrixWorld).invert()}this.updateCamera=function(B){if(i===null)return;I.near=E.near=C.near=B.near,I.far=E.far=C.far=B.far,(A!==I.near||N!==I.far)&&(i.updateRenderState({depthNear:I.near,depthFar:I.far}),A=I.near,N=I.far);const X=B.parent,te=I.cameras;Y(I,X);for(let ue=0;ue<te.length;ue++)Y(te[ue],X);I.matrixWorld.decompose(I.position,I.quaternion,I.scale),B.matrix.copy(I.matrix),B.matrix.decompose(B.position,B.quaternion,B.scale);const oe=B.children;for(let ue=0,Q=oe.length;ue<Q;ue++)oe[ue].updateMatrixWorld(!0);te.length===2?H(I,C,E):I.projectionMatrix.copy(C.projectionMatrix)},this.getCamera=function(){return I},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(B){h!==null&&(h.fixedFoveation=B),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=B)},this.getPlanes=function(){return b};let D=null;function $(B,X){if(c=X.getViewerPose(l||o),f=X,c!==null){const te=c.views;d!==null&&(e.setRenderTargetFramebuffer(y,d.framebuffer),e.setRenderTarget(y));let oe=!1;te.length!==I.cameras.length&&(I.cameras.length=0,oe=!0);for(let ue=0;ue<te.length;ue++){const Q=te[ue];let ke=null;if(d!==null)ke=d.getViewport(Q);else{const De=u.getViewSubImage(h,Q);ke=De.viewport,ue===0&&(e.setRenderTargetTextures(y,De.colorTexture,h.ignoreDepthValues?void 0:De.depthStencilTexture),e.setRenderTarget(y))}let Me=k[ue];Me===void 0&&(Me=new Un,Me.layers.enable(ue),Me.viewport=new rn,k[ue]=Me),Me.matrix.fromArray(Q.transform.matrix),Me.projectionMatrix.fromArray(Q.projectionMatrix),Me.viewport.set(ke.x,ke.y,ke.width,ke.height),ue===0&&I.matrix.copy(Me.matrix),oe===!0&&I.cameras.push(Me)}}for(let te=0;te<v.length;te++){const oe=w[te],ue=v[te];oe!==null&&ue!==void 0&&ue.update(oe,X,l||o)}if(D&&D(B,X),X.detectedPlanes){s.dispatchEvent({type:"planesdetected",data:X.detectedPlanes});let te=null;for(const oe of b)X.detectedPlanes.has(oe)||(te===null&&(te=[]),te.push(oe));if(te!==null)for(const oe of te)b.delete(oe),S.delete(oe),s.dispatchEvent({type:"planeremoved",data:oe});for(const oe of X.detectedPlanes)if(!b.has(oe))b.add(oe),S.set(oe,X.lastChangedTime),s.dispatchEvent({type:"planeadded",data:oe});else{const ue=S.get(oe);oe.lastChangedTime>ue&&(S.set(oe,oe.lastChangedTime),s.dispatchEvent({type:"planechanged",data:oe}))}}f=null}const U=new VG;U.setAnimationLoop($),this.setAnimationLoop=function(B){D=B},this.dispose=function(){}}}function jSe(n,e){function t(x,y){y.color.getRGB(x.fogColor.value,zG(n)),y.isFog?(x.fogNear.value=y.near,x.fogFar.value=y.far):y.isFogExp2&&(x.fogDensity.value=y.density)}function s(x,y,v,w,b){y.isMeshBasicMaterial||y.isMeshLambertMaterial?i(x,y):y.isMeshToonMaterial?(i(x,y),u(x,y)):y.isMeshPhongMaterial?(i(x,y),c(x,y)):y.isMeshStandardMaterial?(i(x,y),h(x,y),y.isMeshPhysicalMaterial&&d(x,y,b)):y.isMeshMatcapMaterial?(i(x,y),f(x,y)):y.isMeshDepthMaterial?i(x,y):y.isMeshDistanceMaterial?(i(x,y),m(x,y)):y.isMeshNormalMaterial?i(x,y):y.isLineBasicMaterial?(r(x,y),y.isLineDashedMaterial&&o(x,y)):y.isPointsMaterial?a(x,y,v,w):y.isSpriteMaterial?l(x,y):y.isShadowMaterial?(x.color.value.copy(y.color),x.opacity.value=y.opacity):y.isShaderMaterial&&(y.uniformsNeedUpdate=!1)}function i(x,y){x.opacity.value=y.opacity,y.color&&x.diffuse.value.copy(y.color),y.emissive&&x.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),y.map&&(x.map.value=y.map),y.alphaMap&&(x.alphaMap.value=y.alphaMap),y.bumpMap&&(x.bumpMap.value=y.bumpMap,x.bumpScale.value=y.bumpScale,y.side===Er&&(x.bumpScale.value*=-1)),y.displacementMap&&(x.displacementMap.value=y.displacementMap,x.displacementScale.value=y.displacementScale,x.displacementBias.value=y.displacementBias),y.emissiveMap&&(x.emissiveMap.value=y.emissiveMap),y.normalMap&&(x.normalMap.value=y.normalMap,x.normalScale.value.copy(y.normalScale),y.side===Er&&x.normalScale.value.negate()),y.specularMap&&(x.specularMap.value=y.specularMap),y.alphaTest>0&&(x.alphaTest.value=y.alphaTest);const v=e.get(y).envMap;if(v&&(x.envMap.value=v,x.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,x.reflectivity.value=y.reflectivity,x.ior.value=y.ior,x.refractionRatio.value=y.refractionRatio),y.lightMap){x.lightMap.value=y.lightMap;const S=n.physicallyCorrectLights!==!0?Math.PI:1;x.lightMapIntensity.value=y.lightMapIntensity*S}y.aoMap&&(x.aoMap.value=y.aoMap,x.aoMapIntensity.value=y.aoMapIntensity);let w;y.map?w=y.map:y.specularMap?w=y.specularMap:y.displacementMap?w=y.displacementMap:y.normalMap?w=y.normalMap:y.bumpMap?w=y.bumpMap:y.roughnessMap?w=y.roughnessMap:y.metalnessMap?w=y.metalnessMap:y.alphaMap?w=y.alphaMap:y.emissiveMap?w=y.emissiveMap:y.clearcoatMap?w=y.clearcoatMap:y.clearcoatNormalMap?w=y.clearcoatNormalMap:y.clearcoatRoughnessMap?w=y.clearcoatRoughnessMap:y.iridescenceMap?w=y.iridescenceMap:y.iridescenceThicknessMap?w=y.iridescenceThicknessMap:y.specularIntensityMap?w=y.specularIntensityMap:y.specularColorMap?w=y.specularColorMap:y.transmissionMap?w=y.transmissionMap:y.thicknessMap?w=y.thicknessMap:y.sheenColorMap?w=y.sheenColorMap:y.sheenRoughnessMap&&(w=y.sheenRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),x.uvTransform.value.copy(w.matrix));let b;y.aoMap?b=y.aoMap:y.lightMap&&(b=y.lightMap),b!==void 0&&(b.isWebGLRenderTarget&&(b=b.texture),b.matrixAutoUpdate===!0&&b.updateMatrix(),x.uv2Transform.value.copy(b.matrix))}function r(x,y){x.diffuse.value.copy(y.color),x.opacity.value=y.opacity}function o(x,y){x.dashSize.value=y.dashSize,x.totalSize.value=y.dashSize+y.gapSize,x.scale.value=y.scale}function a(x,y,v,w){x.diffuse.value.copy(y.color),x.opacity.value=y.opacity,x.size.value=y.size*v,x.scale.value=w*.5,y.map&&(x.map.value=y.map),y.alphaMap&&(x.alphaMap.value=y.alphaMap),y.alphaTest>0&&(x.alphaTest.value=y.alphaTest);let b;y.map?b=y.map:y.alphaMap&&(b=y.alphaMap),b!==void 0&&(b.matrixAutoUpdate===!0&&b.updateMatrix(),x.uvTransform.value.copy(b.matrix))}function l(x,y){x.diffuse.value.copy(y.color),x.opacity.value=y.opacity,x.rotation.value=y.rotation,y.map&&(x.map.value=y.map),y.alphaMap&&(x.alphaMap.value=y.alphaMap),y.alphaTest>0&&(x.alphaTest.value=y.alphaTest);let v;y.map?v=y.map:y.alphaMap&&(v=y.alphaMap),v!==void 0&&(v.matrixAutoUpdate===!0&&v.updateMatrix(),x.uvTransform.value.copy(v.matrix))}function c(x,y){x.specular.value.copy(y.specular),x.shininess.value=Math.max(y.shininess,1e-4)}function u(x,y){y.gradientMap&&(x.gradientMap.value=y.gradientMap)}function h(x,y){x.roughness.value=y.roughness,x.metalness.value=y.metalness,y.roughnessMap&&(x.roughnessMap.value=y.roughnessMap),y.metalnessMap&&(x.metalnessMap.value=y.metalnessMap),e.get(y).envMap&&(x.envMapIntensity.value=y.envMapIntensity)}function d(x,y,v){x.ior.value=y.ior,y.sheen>0&&(x.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),x.sheenRoughness.value=y.sheenRoughness,y.sheenColorMap&&(x.sheenColorMap.value=y.sheenColorMap),y.sheenRoughnessMap&&(x.sheenRoughnessMap.value=y.sheenRoughnessMap)),y.clearcoat>0&&(x.clearcoat.value=y.clearcoat,x.clearcoatRoughness.value=y.clearcoatRoughness,y.clearcoatMap&&(x.clearcoatMap.value=y.clearcoatMap),y.clearcoatRoughnessMap&&(x.clearcoatRoughnessMap.value=y.clearcoatRoughnessMap),y.clearcoatNormalMap&&(x.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),x.clearcoatNormalMap.value=y.clearcoatNormalMap,y.side===Er&&x.clearcoatNormalScale.value.negate())),y.iridescence>0&&(x.iridescence.value=y.iridescence,x.iridescenceIOR.value=y.iridescenceIOR,x.iridescenceThicknessMinimum.value=y.iridescenceThicknessRange[0],x.iridescenceThicknessMaximum.value=y.iridescenceThicknessRange[1],y.iridescenceMap&&(x.iridescenceMap.value=y.iridescenceMap),y.iridescenceThicknessMap&&(x.iridescenceThicknessMap.value=y.iridescenceThicknessMap)),y.transmission>0&&(x.transmission.value=y.transmission,x.transmissionSamplerMap.value=v.texture,x.transmissionSamplerSize.value.set(v.width,v.height),y.transmissionMap&&(x.transmissionMap.value=y.transmissionMap),x.thickness.value=y.thickness,y.thicknessMap&&(x.thicknessMap.value=y.thicknessMap),x.attenuationDistance.value=y.attenuationDistance,x.attenuationColor.value.copy(y.attenuationColor)),x.specularIntensity.value=y.specularIntensity,x.specularColor.value.copy(y.specularColor),y.specularIntensityMap&&(x.specularIntensityMap.value=y.specularIntensityMap),y.specularColorMap&&(x.specularColorMap.value=y.specularColorMap)}function f(x,y){y.matcap&&(x.matcap.value=y.matcap)}function m(x,y){x.referencePosition.value.copy(y.referencePosition),x.nearDistance.value=y.nearDistance,x.farDistance.value=y.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:s}}function qSe(n,e,t,s){let i={},r={},o=[];const a=t.isWebGL2?n.getParameter(35375):0;function l(w,b){const S=b.program;s.uniformBlockBinding(w,S)}function c(w,b){let S=i[w.id];S===void 0&&(m(w),S=u(w),i[w.id]=S,w.addEventListener("dispose",y));const C=b.program;s.updateUBOMapping(w,C);const E=e.render.frame;r[w.id]!==E&&(d(w),r[w.id]=E)}function u(w){const b=h();w.__bindingPointIndex=b;const S=n.createBuffer(),C=w.__size,E=w.usage;return n.bindBuffer(35345,S),n.bufferData(35345,C,E),n.bindBuffer(35345,null),n.bindBufferBase(35345,b,S),S}function h(){for(let w=0;w<a;w++)if(o.indexOf(w)===-1)return o.push(w),w;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(w){const b=i[w.id],S=w.uniforms,C=w.__cache;n.bindBuffer(35345,b);for(let E=0,k=S.length;E<k;E++){const I=S[E];if(f(I,E,C)===!0){const A=I.value,N=I.__offset;typeof A=="number"?(I.__data[0]=A,n.bufferSubData(35345,N,I.__data)):(I.value.isMatrix3?(I.__data[0]=I.value.elements[0],I.__data[1]=I.value.elements[1],I.__data[2]=I.value.elements[2],I.__data[3]=I.value.elements[0],I.__data[4]=I.value.elements[3],I.__data[5]=I.value.elements[4],I.__data[6]=I.value.elements[5],I.__data[7]=I.value.elements[0],I.__data[8]=I.value.elements[6],I.__data[9]=I.value.elements[7],I.__data[10]=I.value.elements[8],I.__data[11]=I.value.elements[0]):A.toArray(I.__data),n.bufferSubData(35345,N,I.__data))}}n.bindBuffer(35345,null)}function f(w,b,S){const C=w.value;if(S[b]===void 0)return typeof C=="number"?S[b]=C:S[b]=C.clone(),!0;if(typeof C=="number"){if(S[b]!==C)return S[b]=C,!0}else{const E=S[b];if(E.equals(C)===!1)return E.copy(C),!0}return!1}function m(w){const b=w.uniforms;let S=0;const C=16;let E=0;for(let k=0,I=b.length;k<I;k++){const A=b[k],N=x(A);if(A.__data=new Float32Array(N.storage/Float32Array.BYTES_PER_ELEMENT),A.__offset=S,k>0){E=S%C;const L=C-E;E!==0&&L-N.boundary<0&&(S+=C-E,A.__offset=S)}S+=N.storage}return E=S%C,E>0&&(S+=C-E),w.__size=S,w.__cache={},this}function x(w){const b=w.value,S={boundary:0,storage:0};return typeof b=="number"?(S.boundary=4,S.storage=4):b.isVector2?(S.boundary=8,S.storage=8):b.isVector3||b.isColor?(S.boundary=16,S.storage=12):b.isVector4?(S.boundary=16,S.storage=16):b.isMatrix3?(S.boundary=48,S.storage=48):b.isMatrix4?(S.boundary=64,S.storage=64):b.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",b),S}function y(w){const b=w.target;b.removeEventListener("dispose",y);const S=o.indexOf(b.__bindingPointIndex);o.splice(S,1),n.deleteBuffer(i[b.id]),delete i[b.id],delete r[b.id]}function v(){for(const w in i)n.deleteBuffer(i[w]);o=[],i={},r={}}return{bind:l,update:c,dispose:v}}function KSe(){const n=Zm("canvas");return n.style.display="block",n}function lA(n={}){this.isWebGLRenderer=!0;const e=n.canvas!==void 0?n.canvas:KSe(),t=n.context!==void 0?n.context:null,s=n.depth!==void 0?n.depth:!0,i=n.stencil!==void 0?n.stencil:!0,r=n.antialias!==void 0?n.antialias:!1,o=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,a=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,l=n.powerPreference!==void 0?n.powerPreference:"default",c=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let u;t!==null?u=t.getContextAttributes().alpha:u=n.alpha!==void 0?n.alpha:!1;let h=null,d=null;const f=[],m=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=gl,this.physicallyCorrectLights=!1,this.toneMapping=Uo,this.toneMappingExposure=1;const x=this;let y=!1,v=0,w=0,b=null,S=-1,C=null;const E=new rn,k=new rn;let I=null,A=e.width,N=e.height,L=1,V=null,O=null;const P=new rn(0,0,A,N),W=new rn(0,0,A,N);let H=!1;const Y=new Gb;let D=!1,$=!1,U=null;const B=new kt,X=new Ae,te=new G,oe={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ue(){return b===null?L:1}let Q=t;function ke(j,pe){for(let Ie=0;Ie<j.length;Ie++){const he=j[Ie],Ne=e.getContext(he,pe);if(Ne!==null)return Ne}return null}try{const j={alpha:!0,depth:s,stencil:i,antialias:r,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Ob}`),e.addEventListener("webglcontextlost",Oe,!1),e.addEventListener("webglcontextrestored",Ge,!1),e.addEventListener("webglcontextcreationerror",St,!1),Q===null){const pe=["webgl2","webgl","experimental-webgl"];if(x.isWebGL1Renderer===!0&&pe.shift(),Q=ke(pe,j),Q===null)throw ke(pe)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Q.getShaderPrecisionFormat===void 0&&(Q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(j){throw console.error("THREE.WebGLRenderer: "+j.message),j}let Me,De,Ee,Be,ye,fe,Re,We,Le,nt,Ke,ot,vt,Dt,q,z,ge,Pe,ze,Xe,ft,Ye,Te,ht;function J(){Me=new hbe(Q),De=new rbe(Q,Me,n),Me.init(De),Ye=new jG(Q,Me,De),Ee=new WSe(Q,Me,De),Be=new pbe,ye=new NSe,fe=new GSe(Q,Me,Ee,ye,De,Ye,Be),Re=new abe(x),We=new ube(x),Le=new _ve(Q,De),Te=new sbe(Q,Me,Le,De),nt=new dbe(Q,Le,Be,Te),Ke=new ybe(Q,nt,Le,Be),ze=new xbe(Q,De,fe),z=new obe(ye),ot=new ASe(x,Re,We,Me,De,Te,z),vt=new jSe(x,ye),Dt=new DSe,q=new zSe(Me,De),Pe=new nbe(x,Re,We,Ee,Ke,u,o),ge=new VSe(x,Ke,De),ht=new qSe(Q,Be,De,Ee),Xe=new ibe(Q,Me,Be,De),ft=new fbe(Q,Me,Be,De),Be.programs=ot.programs,x.capabilities=De,x.extensions=Me,x.properties=ye,x.renderLists=Dt,x.shadowMap=ge,x.state=Ee,x.info=Be}J();const ve=new XSe(x,Q);this.xr=ve,this.getContext=function(){return Q},this.getContextAttributes=function(){return Q.getContextAttributes()},this.forceContextLoss=function(){const j=Me.get("WEBGL_lose_context");j&&j.loseContext()},this.forceContextRestore=function(){const j=Me.get("WEBGL_lose_context");j&&j.restoreContext()},this.getPixelRatio=function(){return L},this.setPixelRatio=function(j){j!==void 0&&(L=j,this.setSize(A,N,!1))},this.getSize=function(j){return j.set(A,N)},this.setSize=function(j,pe,Ie){if(ve.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}A=j,N=pe,e.width=Math.floor(j*L),e.height=Math.floor(pe*L),Ie!==!1&&(e.style.width=j+"px",e.style.height=pe+"px"),this.setViewport(0,0,j,pe)},this.getDrawingBufferSize=function(j){return j.set(A*L,N*L).floor()},this.setDrawingBufferSize=function(j,pe,Ie){A=j,N=pe,L=Ie,e.width=Math.floor(j*Ie),e.height=Math.floor(pe*Ie),this.setViewport(0,0,j,pe)},this.getCurrentViewport=function(j){return j.copy(E)},this.getViewport=function(j){return j.copy(P)},this.setViewport=function(j,pe,Ie,he){j.isVector4?P.set(j.x,j.y,j.z,j.w):P.set(j,pe,Ie,he),Ee.viewport(E.copy(P).multiplyScalar(L).floor())},this.getScissor=function(j){return j.copy(W)},this.setScissor=function(j,pe,Ie,he){j.isVector4?W.set(j.x,j.y,j.z,j.w):W.set(j,pe,Ie,he),Ee.scissor(k.copy(W).multiplyScalar(L).floor())},this.getScissorTest=function(){return H},this.setScissorTest=function(j){Ee.setScissorTest(H=j)},this.setOpaqueSort=function(j){V=j},this.setTransparentSort=function(j){O=j},this.getClearColor=function(j){return j.copy(Pe.getClearColor())},this.setClearColor=function(){Pe.setClearColor.apply(Pe,arguments)},this.getClearAlpha=function(){return Pe.getClearAlpha()},this.setClearAlpha=function(){Pe.setClearAlpha.apply(Pe,arguments)},this.clear=function(j=!0,pe=!0,Ie=!0){let he=0;j&&(he|=16384),pe&&(he|=256),Ie&&(he|=1024),Q.clear(he)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Oe,!1),e.removeEventListener("webglcontextrestored",Ge,!1),e.removeEventListener("webglcontextcreationerror",St,!1),Dt.dispose(),q.dispose(),ye.dispose(),Re.dispose(),We.dispose(),Ke.dispose(),Te.dispose(),ht.dispose(),ot.dispose(),ve.dispose(),ve.removeEventListener("sessionstart",rt),ve.removeEventListener("sessionend",gt),U&&(U.dispose(),U=null),nn.stop()};function Oe(j){j.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function Ge(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const j=Be.autoReset,pe=ge.enabled,Ie=ge.autoUpdate,he=ge.needsUpdate,Ne=ge.type;J(),Be.autoReset=j,ge.enabled=pe,ge.autoUpdate=Ie,ge.needsUpdate=he,ge.type=Ne}function St(j){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",j.statusMessage)}function Xt(j){const pe=j.target;pe.removeEventListener("dispose",Xt),Dn(pe)}function Dn(j){ie(j),ye.remove(j)}function ie(j){const pe=ye.get(j).programs;pe!==void 0&&(pe.forEach(function(Ie){ot.releaseProgram(Ie)}),j.isShaderMaterial&&ot.releaseShaderCache(j))}this.renderBufferDirect=function(j,pe,Ie,he,Ne,wt){pe===null&&(pe=oe);const It=Ne.isMesh&&Ne.matrixWorld.determinant()<0,Pt=iS(j,pe,Ie,he,Ne);Ee.setMaterial(he,It);let Vt=Ie.index,Jt=1;he.wireframe===!0&&(Vt=nt.getWireframeAttribute(Ie),Jt=2);const jt=Ie.drawRange,qt=Ie.attributes.position;let Kn=jt.start*Jt,ki=(jt.start+jt.count)*Jt;wt!==null&&(Kn=Math.max(Kn,wt.start*Jt),ki=Math.min(ki,(wt.start+wt.count)*Jt)),Vt!==null?(Kn=Math.max(Kn,0),ki=Math.min(ki,Vt.count)):qt!=null&&(Kn=Math.max(Kn,0),ki=Math.min(ki,qt.count));const vo=ki-Kn;if(vo<0||vo===1/0)return;Te.setup(Ne,he,Pt,Ie,Vt);let La,On=Xe;if(Vt!==null&&(La=Le.get(Vt),On=ft,On.setIndex(La)),Ne.isMesh)he.wireframe===!0?(Ee.setLineWidth(he.wireframeLinewidth*ue()),On.setMode(1)):On.setMode(4);else if(Ne.isLine){let $t=he.linewidth;$t===void 0&&($t=1),Ee.setLineWidth($t*ue()),Ne.isLineSegments?On.setMode(1):Ne.isLineLoop?On.setMode(2):On.setMode(3)}else Ne.isPoints?On.setMode(0):Ne.isSprite&&On.setMode(4);if(Ne.isInstancedMesh)On.renderInstances(Kn,vo,Ne.count);else if(Ie.isInstancedBufferGeometry){const $t=Ie._maxInstanceCount!==void 0?Ie._maxInstanceCount:1/0,Hc=Math.min(Ie.instanceCount,$t);On.renderInstances(Kn,vo,Hc)}else On.render(Kn,vo)},this.compile=function(j,pe){function Ie(he,Ne,wt){he.transparent===!0&&he.side===sl?(he.side=Er,he.needsUpdate=!0,qi(he,Ne,wt),he.side=fh,he.needsUpdate=!0,qi(he,Ne,wt),he.side=sl):qi(he,Ne,wt)}d=q.get(j),d.init(),m.push(d),j.traverseVisible(function(he){he.isLight&&he.layers.test(pe.layers)&&(d.pushLight(he),he.castShadow&&d.pushShadow(he))}),d.setupLights(x.physicallyCorrectLights),j.traverse(function(he){const Ne=he.material;if(Ne)if(Array.isArray(Ne))for(let wt=0;wt<Ne.length;wt++){const It=Ne[wt];Ie(It,j,he)}else Ie(Ne,j,he)}),m.pop(),d=null};let _e=null;function Fe(j){_e&&_e(j)}function rt(){nn.stop()}function gt(){nn.start()}const nn=new VG;nn.setAnimationLoop(Fe),typeof self<"u"&&nn.setContext(self),this.setAnimationLoop=function(j){_e=j,ve.setAnimationLoop(j),j===null?nn.stop():nn.start()},ve.addEventListener("sessionstart",rt),ve.addEventListener("sessionend",gt),this.render=function(j,pe){if(pe!==void 0&&pe.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;j.matrixWorldAutoUpdate===!0&&j.updateMatrixWorld(),pe.parent===null&&pe.matrixWorldAutoUpdate===!0&&pe.updateMatrixWorld(),ve.enabled===!0&&ve.isPresenting===!0&&(ve.cameraAutoUpdate===!0&&ve.updateCamera(pe),pe=ve.getCamera()),j.isScene===!0&&j.onBeforeRender(x,j,pe,b),d=q.get(j,m.length),d.init(),m.push(d),B.multiplyMatrices(pe.projectionMatrix,pe.matrixWorldInverse),Y.setFromProjectionMatrix(B),$=this.localClippingEnabled,D=z.init(this.clippingPlanes,$,pe),h=Dt.get(j,f.length),h.init(),f.push(h),os(j,pe,0,x.sortObjects),h.finish(),x.sortObjects===!0&&h.sort(V,O),D===!0&&z.beginShadows();const Ie=d.state.shadowsArray;if(ge.render(Ie,j,pe),D===!0&&z.endShadows(),this.info.autoReset===!0&&this.info.reset(),Pe.render(h,j),d.setupLights(x.physicallyCorrectLights),pe.isArrayCamera){const he=pe.cameras;for(let Ne=0,wt=he.length;Ne<wt;Ne++){const It=he[Ne];zs(h,j,It,It.viewport)}}else zs(h,j,pe);b!==null&&(fe.updateMultisampleRenderTarget(b),fe.updateRenderTargetMipmap(b)),j.isScene===!0&&j.onAfterRender(x,j,pe),Te.resetDefaultState(),S=-1,C=null,m.pop(),m.length>0?d=m[m.length-1]:d=null,f.pop(),f.length>0?h=f[f.length-1]:h=null};function os(j,pe,Ie,he){if(j.visible===!1)return;if(j.layers.test(pe.layers)){if(j.isGroup)Ie=j.renderOrder;else if(j.isLOD)j.autoUpdate===!0&&j.update(pe);else if(j.isLight)d.pushLight(j),j.castShadow&&d.pushShadow(j);else if(j.isSprite){if(!j.frustumCulled||Y.intersectsSprite(j)){he&&te.setFromMatrixPosition(j.matrixWorld).applyMatrix4(B);const It=Ke.update(j),Pt=j.material;Pt.visible&&h.push(j,It,Pt,Ie,te.z,null)}}else if((j.isMesh||j.isLine||j.isPoints)&&(j.isSkinnedMesh&&j.skeleton.frame!==Be.render.frame&&(j.skeleton.update(),j.skeleton.frame=Be.render.frame),!j.frustumCulled||Y.intersectsObject(j))){he&&te.setFromMatrixPosition(j.matrixWorld).applyMatrix4(B);const It=Ke.update(j),Pt=j.material;if(Array.isArray(Pt)){const Vt=It.groups;for(let Jt=0,jt=Vt.length;Jt<jt;Jt++){const qt=Vt[Jt],Kn=Pt[qt.materialIndex];Kn&&Kn.visible&&h.push(j,It,Kn,Ie,te.z,qt)}}else Pt.visible&&h.push(j,It,Pt,Ie,te.z,null)}}const wt=j.children;for(let It=0,Pt=wt.length;It<Pt;It++)os(wt[It],pe,Ie,he)}function zs(j,pe,Ie,he){const Ne=j.opaque,wt=j.transmissive,It=j.transparent;d.setupLightsView(Ie),wt.length>0&&Jo(Ne,pe,Ie),he&&Ee.viewport(E.copy(he)),Ne.length>0&&vn(Ne,pe,Ie),wt.length>0&&vn(wt,pe,Ie),It.length>0&&vn(It,pe,Ie),Ee.buffers.depth.setTest(!0),Ee.buffers.depth.setMask(!0),Ee.buffers.color.setMask(!0),Ee.setPolygonOffset(!1)}function Jo(j,pe,Ie){const he=De.isWebGL2;U===null&&(U=new mo(1,1,{generateMipmaps:!0,type:Me.has("EXT_color_buffer_half_float")?vf:kc,minFilter:Nh,samples:he&&r===!0?4:0})),x.getDrawingBufferSize(X),he?U.setSize(X.x,X.y):U.setSize(U1(X.x),U1(X.y));const Ne=x.getRenderTarget();x.setRenderTarget(U),x.clear();const wt=x.toneMapping;x.toneMapping=Uo,vn(j,pe,Ie),x.toneMapping=wt,fe.updateMultisampleRenderTarget(U),fe.updateRenderTargetMipmap(U),x.setRenderTarget(Ne)}function vn(j,pe,Ie){const he=pe.isScene===!0?pe.overrideMaterial:null;for(let Ne=0,wt=j.length;Ne<wt;Ne++){const It=j[Ne],Pt=It.object,Vt=It.geometry,Jt=he===null?It.material:he,jt=It.group;Pt.layers.test(Ie.layers)&&Fr(Pt,pe,Ie,Vt,Jt,jt)}}function Fr(j,pe,Ie,he,Ne,wt){j.onBeforeRender(x,pe,Ie,he,Ne,wt),j.modelViewMatrix.multiplyMatrices(Ie.matrixWorldInverse,j.matrixWorld),j.normalMatrix.getNormalMatrix(j.modelViewMatrix),Ne.onBeforeRender(x,pe,Ie,he,j,wt),Ne.transparent===!0&&Ne.side===sl?(Ne.side=Er,Ne.needsUpdate=!0,x.renderBufferDirect(Ie,pe,he,Ne,j,wt),Ne.side=fh,Ne.needsUpdate=!0,x.renderBufferDirect(Ie,pe,he,Ne,j,wt),Ne.side=sl):x.renderBufferDirect(Ie,pe,he,Ne,j,wt),j.onAfterRender(x,pe,Ie,he,Ne,wt)}function qi(j,pe,Ie){pe.isScene!==!0&&(pe=oe);const he=ye.get(j),Ne=d.state.lights,wt=d.state.shadowsArray,It=Ne.state.version,Pt=ot.getParameters(j,Ne.state,wt,pe,Ie),Vt=ot.getProgramCacheKey(Pt);let Jt=he.programs;he.environment=j.isMeshStandardMaterial?pe.environment:null,he.fog=pe.fog,he.envMap=(j.isMeshStandardMaterial?We:Re).get(j.envMap||he.environment),Jt===void 0&&(j.addEventListener("dispose",Xt),Jt=new Map,he.programs=Jt);let jt=Jt.get(Vt);if(jt!==void 0){if(he.currentProgram===jt&&he.lightsStateVersion===It)return J0(j,Pt),jt}else Pt.uniforms=ot.getUniforms(j),j.onBuild(Ie,Pt,x),j.onBeforeCompile(Pt,x),jt=ot.acquireProgram(Pt,Vt),Jt.set(Vt,jt),he.uniforms=Pt.uniforms;const qt=he.uniforms;(!j.isShaderMaterial&&!j.isRawShaderMaterial||j.clipping===!0)&&(qt.clippingPlanes=z.uniform),J0(j,Pt),he.needsLights=Zf(j),he.lightsStateVersion=It,he.needsLights&&(qt.ambientLightColor.value=Ne.state.ambient,qt.lightProbe.value=Ne.state.probe,qt.directionalLights.value=Ne.state.directional,qt.directionalLightShadows.value=Ne.state.directionalShadow,qt.spotLights.value=Ne.state.spot,qt.spotLightShadows.value=Ne.state.spotShadow,qt.rectAreaLights.value=Ne.state.rectArea,qt.ltc_1.value=Ne.state.rectAreaLTC1,qt.ltc_2.value=Ne.state.rectAreaLTC2,qt.pointLights.value=Ne.state.point,qt.pointLightShadows.value=Ne.state.pointShadow,qt.hemisphereLights.value=Ne.state.hemi,qt.directionalShadowMap.value=Ne.state.directionalShadowMap,qt.directionalShadowMatrix.value=Ne.state.directionalShadowMatrix,qt.spotShadowMap.value=Ne.state.spotShadowMap,qt.spotLightMatrix.value=Ne.state.spotLightMatrix,qt.spotLightMap.value=Ne.state.spotLightMap,qt.pointShadowMap.value=Ne.state.pointShadowMap,qt.pointShadowMatrix.value=Ne.state.pointShadowMatrix);const Kn=jt.getUniforms(),ki=Ov.seqWithValue(Kn.seq,qt);return he.currentProgram=jt,he.uniformsList=ki,jt}function J0(j,pe){const Ie=ye.get(j);Ie.outputEncoding=pe.outputEncoding,Ie.instancing=pe.instancing,Ie.skinning=pe.skinning,Ie.morphTargets=pe.morphTargets,Ie.morphNormals=pe.morphNormals,Ie.morphColors=pe.morphColors,Ie.morphTargetsCount=pe.morphTargetsCount,Ie.numClippingPlanes=pe.numClippingPlanes,Ie.numIntersection=pe.numClipIntersection,Ie.vertexAlphas=pe.vertexAlphas,Ie.vertexTangents=pe.vertexTangents,Ie.toneMapping=pe.toneMapping}function iS(j,pe,Ie,he,Ne){pe.isScene!==!0&&(pe=oe),fe.resetTextureUnits();const wt=pe.fog,It=he.isMeshStandardMaterial?pe.environment:null,Pt=b===null?x.outputEncoding:b.isXRRenderTarget===!0?b.texture.encoding:gl,Vt=(he.isMeshStandardMaterial?We:Re).get(he.envMap||It),Jt=he.vertexColors===!0&&!!Ie.attributes.color&&Ie.attributes.color.itemSize===4,jt=!!he.normalMap&&!!Ie.attributes.tangent,qt=!!Ie.morphAttributes.position,Kn=!!Ie.morphAttributes.normal,ki=!!Ie.morphAttributes.color,vo=he.toneMapped?x.toneMapping:Uo,La=Ie.morphAttributes.position||Ie.morphAttributes.normal||Ie.morphAttributes.color,On=La!==void 0?La.length:0,$t=ye.get(he),Hc=d.state.lights;if(D===!0&&($===!0||j!==C)){const mn=j===C&&he.id===S;z.setState(he,j,mn)}let Yn=!1;he.version===$t.__version?($t.needsLights&&$t.lightsStateVersion!==Hc.state.version||$t.outputEncoding!==Pt||Ne.isInstancedMesh&&$t.instancing===!1||!Ne.isInstancedMesh&&$t.instancing===!0||Ne.isSkinnedMesh&&$t.skinning===!1||!Ne.isSkinnedMesh&&$t.skinning===!0||$t.envMap!==Vt||he.fog===!0&&$t.fog!==wt||$t.numClippingPlanes!==void 0&&($t.numClippingPlanes!==z.numPlanes||$t.numIntersection!==z.numIntersection)||$t.vertexAlphas!==Jt||$t.vertexTangents!==jt||$t.morphTargets!==qt||$t.morphNormals!==Kn||$t.morphColors!==ki||$t.toneMapping!==vo||De.isWebGL2===!0&&$t.morphTargetsCount!==On)&&(Yn=!0):(Yn=!0,$t.__version=he.version);let Pa=$t.currentProgram;Yn===!0&&(Pa=qi(he,pe,Ne));let $h=!1,Or=!1,zr=!1;const Lt=Pa.getUniforms(),tn=$t.uniforms;if(Ee.useProgram(Pa.program)&&($h=!0,Or=!0,zr=!0),he.id!==S&&(S=he.id,Or=!0),$h||C!==j){if(Lt.setValue(Q,"projectionMatrix",j.projectionMatrix),De.logarithmicDepthBuffer&&Lt.setValue(Q,"logDepthBufFC",2/(Math.log(j.far+1)/Math.LN2)),C!==j&&(C=j,Or=!0,zr=!0),he.isShaderMaterial||he.isMeshPhongMaterial||he.isMeshToonMaterial||he.isMeshStandardMaterial||he.envMap){const mn=Lt.map.cameraPosition;mn!==void 0&&mn.setValue(Q,te.setFromMatrixPosition(j.matrixWorld))}(he.isMeshPhongMaterial||he.isMeshToonMaterial||he.isMeshLambertMaterial||he.isMeshBasicMaterial||he.isMeshStandardMaterial||he.isShaderMaterial)&&Lt.setValue(Q,"isOrthographic",j.isOrthographicCamera===!0),(he.isMeshPhongMaterial||he.isMeshToonMaterial||he.isMeshLambertMaterial||he.isMeshBasicMaterial||he.isMeshStandardMaterial||he.isShaderMaterial||he.isShadowMaterial||Ne.isSkinnedMesh)&&Lt.setValue(Q,"viewMatrix",j.matrixWorldInverse)}if(Ne.isSkinnedMesh){Lt.setOptional(Q,Ne,"bindMatrix"),Lt.setOptional(Q,Ne,"bindMatrixInverse");const mn=Ne.skeleton;mn&&(De.floatVertexTextures?(mn.boneTexture===null&&mn.computeBoneTexture(),Lt.setValue(Q,"boneTexture",mn.boneTexture,fe),Lt.setValue(Q,"boneTextureSize",mn.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const Br=Ie.morphAttributes;if((Br.position!==void 0||Br.normal!==void 0||Br.color!==void 0&&De.isWebGL2===!0)&&ze.update(Ne,Ie,he,Pa),(Or||$t.receiveShadow!==Ne.receiveShadow)&&($t.receiveShadow=Ne.receiveShadow,Lt.setValue(Q,"receiveShadow",Ne.receiveShadow)),he.isMeshGouraudMaterial&&he.envMap!==null&&(tn.envMap.value=Vt,tn.flipEnvMap.value=Vt.isCubeTexture&&Vt.isRenderTargetTexture===!1?-1:1),Or&&(Lt.setValue(Q,"toneMappingExposure",x.toneMappingExposure),$t.needsLights&&Q0(tn,zr),wt&&he.fog===!0&&vt.refreshFogUniforms(tn,wt),vt.refreshMaterialUniforms(tn,he,L,N,U),Ov.upload(Q,$t.uniformsList,tn,fe)),he.isShaderMaterial&&he.uniformsNeedUpdate===!0&&(Ov.upload(Q,$t.uniformsList,tn,fe),he.uniformsNeedUpdate=!1),he.isSpriteMaterial&&Lt.setValue(Q,"center",Ne.center),Lt.setValue(Q,"modelViewMatrix",Ne.modelViewMatrix),Lt.setValue(Q,"normalMatrix",Ne.normalMatrix),Lt.setValue(Q,"modelMatrix",Ne.matrixWorld),he.isShaderMaterial||he.isRawShaderMaterial){const mn=he.uniformsGroups;for(let Bs=0,$a=mn.length;Bs<$a;Bs++)if(De.isWebGL2){const Fa=mn[Bs];ht.update(Fa,Pa),ht.bind(Fa,Pa)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Pa}function Q0(j,pe){j.ambientLightColor.needsUpdate=pe,j.lightProbe.needsUpdate=pe,j.directionalLights.needsUpdate=pe,j.directionalLightShadows.needsUpdate=pe,j.pointLights.needsUpdate=pe,j.pointLightShadows.needsUpdate=pe,j.spotLights.needsUpdate=pe,j.spotLightShadows.needsUpdate=pe,j.rectAreaLights.needsUpdate=pe,j.hemisphereLights.needsUpdate=pe}function Zf(j){return j.isMeshLambertMaterial||j.isMeshToonMaterial||j.isMeshPhongMaterial||j.isMeshStandardMaterial||j.isShadowMaterial||j.isShaderMaterial&&j.lights===!0}this.getActiveCubeFace=function(){return v},this.getActiveMipmapLevel=function(){return w},this.getRenderTarget=function(){return b},this.setRenderTargetTextures=function(j,pe,Ie){ye.get(j.texture).__webglTexture=pe,ye.get(j.depthTexture).__webglTexture=Ie;const he=ye.get(j);he.__hasExternalTextures=!0,he.__hasExternalTextures&&(he.__autoAllocateDepthBuffer=Ie===void 0,he.__autoAllocateDepthBuffer||Me.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),he.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(j,pe){const Ie=ye.get(j);Ie.__webglFramebuffer=pe,Ie.__useDefaultFramebuffer=pe===void 0},this.setRenderTarget=function(j,pe=0,Ie=0){b=j,v=pe,w=Ie;let he=!0,Ne=null,wt=!1,It=!1;if(j){const Vt=ye.get(j);Vt.__useDefaultFramebuffer!==void 0?(Ee.bindFramebuffer(36160,null),he=!1):Vt.__webglFramebuffer===void 0?fe.setupRenderTarget(j):Vt.__hasExternalTextures&&fe.rebindTextures(j,ye.get(j.texture).__webglTexture,ye.get(j.depthTexture).__webglTexture);const Jt=j.texture;(Jt.isData3DTexture||Jt.isDataArrayTexture||Jt.isCompressedArrayTexture)&&(It=!0);const jt=ye.get(j).__webglFramebuffer;j.isWebGLCubeRenderTarget?(Ne=jt[pe],wt=!0):De.isWebGL2&&j.samples>0&&fe.useMultisampledRTT(j)===!1?Ne=ye.get(j).__webglMultisampledFramebuffer:Ne=jt,E.copy(j.viewport),k.copy(j.scissor),I=j.scissorTest}else E.copy(P).multiplyScalar(L).floor(),k.copy(W).multiplyScalar(L).floor(),I=H;if(Ee.bindFramebuffer(36160,Ne)&&De.drawBuffers&&he&&Ee.drawBuffers(j,Ne),Ee.viewport(E),Ee.scissor(k),Ee.setScissorTest(I),wt){const Vt=ye.get(j.texture);Q.framebufferTexture2D(36160,36064,34069+pe,Vt.__webglTexture,Ie)}else if(It){const Vt=ye.get(j.texture),Jt=pe||0;Q.framebufferTextureLayer(36160,36064,Vt.__webglTexture,Ie||0,Jt)}S=-1},this.readRenderTargetPixels=function(j,pe,Ie,he,Ne,wt,It){if(!(j&&j.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Pt=ye.get(j).__webglFramebuffer;if(j.isWebGLCubeRenderTarget&&It!==void 0&&(Pt=Pt[It]),Pt){Ee.bindFramebuffer(36160,Pt);try{const Vt=j.texture,Jt=Vt.format,jt=Vt.type;if(Jt!==br&&Ye.convert(Jt)!==Q.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const qt=jt===vf&&(Me.has("EXT_color_buffer_half_float")||De.isWebGL2&&Me.has("EXT_color_buffer_float"));if(jt!==kc&&Ye.convert(jt)!==Q.getParameter(35738)&&!(jt===il&&(De.isWebGL2||Me.has("OES_texture_float")||Me.has("WEBGL_color_buffer_float")))&&!qt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}pe>=0&&pe<=j.width-he&&Ie>=0&&Ie<=j.height-Ne&&Q.readPixels(pe,Ie,he,Ne,Ye.convert(Jt),Ye.convert(jt),wt)}finally{const Vt=b!==null?ye.get(b).__webglFramebuffer:null;Ee.bindFramebuffer(36160,Vt)}}},this.copyFramebufferToTexture=function(j,pe,Ie=0){const he=Math.pow(2,-Ie),Ne=Math.floor(pe.image.width*he),wt=Math.floor(pe.image.height*he);fe.setTexture2D(pe,0),Q.copyTexSubImage2D(3553,Ie,0,0,j.x,j.y,Ne,wt),Ee.unbindTexture()},this.copyTextureToTexture=function(j,pe,Ie,he=0){const Ne=pe.image.width,wt=pe.image.height,It=Ye.convert(Ie.format),Pt=Ye.convert(Ie.type);fe.setTexture2D(Ie,0),Q.pixelStorei(37440,Ie.flipY),Q.pixelStorei(37441,Ie.premultiplyAlpha),Q.pixelStorei(3317,Ie.unpackAlignment),pe.isDataTexture?Q.texSubImage2D(3553,he,j.x,j.y,Ne,wt,It,Pt,pe.image.data):pe.isCompressedTexture?Q.compressedTexSubImage2D(3553,he,j.x,j.y,pe.mipmaps[0].width,pe.mipmaps[0].height,It,pe.mipmaps[0].data):Q.texSubImage2D(3553,he,j.x,j.y,It,Pt,pe.image),he===0&&Ie.generateMipmaps&&Q.generateMipmap(3553),Ee.unbindTexture()},this.copyTextureToTexture3D=function(j,pe,Ie,he,Ne=0){if(x.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const wt=j.max.x-j.min.x+1,It=j.max.y-j.min.y+1,Pt=j.max.z-j.min.z+1,Vt=Ye.convert(he.format),Jt=Ye.convert(he.type);let jt;if(he.isData3DTexture)fe.setTexture3D(he,0),jt=32879;else if(he.isDataArrayTexture)fe.setTexture2DArray(he,0),jt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Q.pixelStorei(37440,he.flipY),Q.pixelStorei(37441,he.premultiplyAlpha),Q.pixelStorei(3317,he.unpackAlignment);const qt=Q.getParameter(3314),Kn=Q.getParameter(32878),ki=Q.getParameter(3316),vo=Q.getParameter(3315),La=Q.getParameter(32877),On=Ie.isCompressedTexture?Ie.mipmaps[0]:Ie.image;Q.pixelStorei(3314,On.width),Q.pixelStorei(32878,On.height),Q.pixelStorei(3316,j.min.x),Q.pixelStorei(3315,j.min.y),Q.pixelStorei(32877,j.min.z),Ie.isDataTexture||Ie.isData3DTexture?Q.texSubImage3D(jt,Ne,pe.x,pe.y,pe.z,wt,It,Pt,Vt,Jt,On.data):Ie.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Q.compressedTexSubImage3D(jt,Ne,pe.x,pe.y,pe.z,wt,It,Pt,Vt,On.data)):Q.texSubImage3D(jt,Ne,pe.x,pe.y,pe.z,wt,It,Pt,Vt,Jt,On),Q.pixelStorei(3314,qt),Q.pixelStorei(32878,Kn),Q.pixelStorei(3316,ki),Q.pixelStorei(3315,vo),Q.pixelStorei(32877,La),Ne===0&&he.generateMipmaps&&Q.generateMipmap(jt),Ee.unbindTexture()},this.initTexture=function(j){j.isCubeTexture?fe.setTextureCube(j,0):j.isData3DTexture?fe.setTexture3D(j,0):j.isDataArrayTexture||j.isCompressedArrayTexture?fe.setTexture2DArray(j,0):fe.setTexture2D(j,0),Ee.unbindTexture()},this.resetState=function(){v=0,w=0,b=null,Ee.reset(),Te.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class YG extends lA{}YG.prototype.isWebGL1Renderer=!0;class Xb{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new Je(e),this.density=t}clone(){return new Xb(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class jb{constructor(e,t=1,s=1e3){this.isFog=!0,this.name="",this.color=new Je(e),this.near=t,this.far=s}clone(){return new jb(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class cA extends fn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.backgroundIntensity=this.backgroundIntensity),t}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(e){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=e}}class qb{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Km,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Mr()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[s+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Mr()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Mr()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ri=new G;class Cr{constructor(e,t,s,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=i===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)Ri.fromBufferAttribute(this,t),Ri.applyMatrix4(e),this.setXYZ(t,Ri.x,Ri.y,Ri.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Ri.fromBufferAttribute(this,t),Ri.applyNormalMatrix(e),this.setXYZ(t,Ri.x,Ri.y,Ri.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Ri.fromBufferAttribute(this,t),Ri.transformDirection(e),this.setXYZ(t,Ri.x,Ri.y,Ri.z);return this}setX(e,t){return this.normalized&&(t=bn(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=bn(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=bn(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=bn(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=rl(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=rl(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=rl(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=rl(t,this.array)),t}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=bn(t,this.array),s=bn(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=bn(t,this.array),s=bn(s,this.array),i=bn(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=bn(t,this.array),s=bn(s,this.array),i=bn(i,this.array),r=bn(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Cn(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Cr(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class uA extends li{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Je(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let dd;const Rp=new G,fd=new G,pd=new G,md=new Ae,Dp=new Ae,ZG=new kt,Gy=new G,Lp=new G,Hy=new G,WL=new Ae,TC=new Ae,GL=new Ae;class JG extends fn{constructor(e){if(super(),this.isSprite=!0,this.type="Sprite",dd===void 0){dd=new Bt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new qb(t,5);dd.setIndex([0,1,2,0,2,3]),dd.setAttribute("position",new Cr(s,3,0,!1)),dd.setAttribute("uv",new Cr(s,2,3,!1))}this.geometry=dd,this.material=e!==void 0?e:new uA,this.center=new Ae(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),fd.setFromMatrixScale(this.matrixWorld),ZG.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),pd.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&fd.multiplyScalar(-pd.z);const s=this.material.rotation;let i,r;s!==0&&(r=Math.cos(s),i=Math.sin(s));const o=this.center;Xy(Gy.set(-.5,-.5,0),pd,o,fd,i,r),Xy(Lp.set(.5,-.5,0),pd,o,fd,i,r),Xy(Hy.set(.5,.5,0),pd,o,fd,i,r),WL.set(0,0),TC.set(1,0),GL.set(1,1);let a=e.ray.intersectTriangle(Gy,Lp,Hy,!1,Rp);if(a===null&&(Xy(Lp.set(-.5,.5,0),pd,o,fd,i,r),TC.set(0,1),a=e.ray.intersectTriangle(Gy,Hy,Lp,!1,Rp),a===null))return;const l=e.ray.origin.distanceTo(Rp);l<e.near||l>e.far||t.push({distance:l,point:Rp.clone(),uv:so.getUV(Rp,Gy,Lp,Hy,WL,TC,GL,new Ae),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function Xy(n,e,t,s,i,r){md.subVectors(n,t).addScalar(.5).multiply(s),i!==void 0?(Dp.x=r*md.x-i*md.y,Dp.y=i*md.x+r*md.y):Dp.copy(md),n.copy(e),n.x+=Dp.x,n.y+=Dp.y,n.applyMatrix4(ZG)}const jy=new G,HL=new G;class QG extends fn{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let s=0,i=t.length;s<i;s++){const r=t[s];this.addLevel(r.object.clone(),r.distance,r.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,s=0){t=Math.abs(t);const i=this.levels;let r;for(r=0;r<i.length&&!(t<i[r].distance);r++);return i.splice(r,0,{distance:t,hysteresis:s,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let s,i;for(s=1,i=t.length;s<i;s++){let r=t[s].distance;if(t[s].object.visible&&(r-=r*t[s].hysteresis),e<r)break}return t[s-1].object}return null}raycast(e,t){if(this.levels.length>0){jy.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(jy);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){jy.setFromMatrixPosition(e.matrixWorld),HL.setFromMatrixPosition(this.matrixWorld);const s=jy.distanceTo(HL)/e.zoom;t[0].object.visible=!0;let i,r;for(i=1,r=t.length;i<r;i++){let o=t[i].distance;if(t[i].object.visible&&(o-=o*t[i].hysteresis),s>=o)t[i-1].object.visible=!1,t[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const s=this.levels;for(let i=0,r=s.length;i<r;i++){const o=s[i];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const XL=new G,jL=new rn,qL=new rn,YSe=new G,KL=new kt;class e5 extends js{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new kt,this.bindMatrixInverse=new kt}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new rn,t=this.geometry.attributes.skinWeight;for(let s=0,i=t.count;s<i;s++){e.fromBufferAttribute(t,s);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const s=this.skeleton,i=this.geometry;jL.fromBufferAttribute(i.attributes.skinIndex,e),qL.fromBufferAttribute(i.attributes.skinWeight,e),XL.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const o=qL.getComponent(r);if(o!==0){const a=jL.getComponent(r);KL.multiplyMatrices(s.bones[a].matrixWorld,s.boneInverses[a]),t.addScaledVector(YSe.copy(XL).applyMatrix4(KL),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}class hA extends fn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Kd extends ns{constructor(e=null,t=1,s=1,i,r,o,a,l,c=ws,u=ws,h,d){super(null,o,a,l,c,u,i,r,h,d),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const YL=new kt,ZSe=new kt;class Kb{constructor(e=[],t=[]){this.uuid=Mr(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,i=this.bones.length;s<i;s++)this.boneInverses.push(new kt)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const s=new kt;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,t=this.boneInverses,s=this.boneMatrices,i=this.boneTexture;for(let r=0,o=e.length;r<o;r++){const a=e[r]?e[r].matrixWorld:ZSe;YL.multiplyMatrices(a,t[r]),YL.toArray(s,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new Kb(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=$G(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const s=new Kd(t,e,e,br,il);return s.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=s,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,s=this.bones.length;t<s;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let s=0,i=e.bones.length;s<i;s++){const r=e.bones[s];let o=t[r];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new hA),this.bones.push(o),this.boneInverses.push(new kt().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,s=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const o=t[i];e.bones.push(o.uuid);const a=s[i];e.boneInverses.push(a.toArray())}return e}}class Sf extends Cn{constructor(e,t,s,i=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const ZL=new kt,JL=new kt,qy=[],JSe=new kt,Pp=new js;class t5 extends js{constructor(e,t,s){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Sf(new Float32Array(s*16),16),this.instanceColor=null,this.count=s,this.frustumCulled=!1;for(let i=0;i<s;i++)this.setMatrixAt(i,JSe)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const s=this.matrixWorld,i=this.count;if(Pp.geometry=this.geometry,Pp.material=this.material,Pp.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,ZL),JL.multiplyMatrices(s,ZL),Pp.matrixWorld=JL,Pp.raycast(e,qy);for(let o=0,a=qy.length;o<a;o++){const l=qy[o];l.instanceId=r,l.object=this,t.push(l)}qy.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Sf(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class ji extends li{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Je(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const QL=new G,eP=new G,tP=new kt,IC=new P0,Ky=new _l;class Ac extends fn{constructor(e=new Bt,t=new ji){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[0];for(let i=1,r=t.count;i<r;i++)QL.fromBufferAttribute(t,i-1),eP.fromBufferAttribute(t,i),s[i]=s[i-1],s[i]+=QL.distanceTo(eP);e.setAttribute("lineDistance",new ut(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),Ky.copy(s.boundingSphere),Ky.applyMatrix4(i),Ky.radius+=r,e.ray.intersectsSphere(Ky)===!1)return;tP.copy(i).invert(),IC.copy(e.ray).applyMatrix4(tP);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new G,u=new G,h=new G,d=new G,f=this.isLineSegments?2:1,m=s.index,y=s.attributes.position;if(m!==null){const v=Math.max(0,o.start),w=Math.min(m.count,o.start+o.count);for(let b=v,S=w-1;b<S;b+=f){const C=m.getX(b),E=m.getX(b+1);if(c.fromBufferAttribute(y,C),u.fromBufferAttribute(y,E),IC.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const I=e.ray.origin.distanceTo(d);I<e.near||I>e.far||t.push({distance:I,point:h.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}else{const v=Math.max(0,o.start),w=Math.min(y.count,o.start+o.count);for(let b=v,S=w-1;b<S;b+=f){if(c.fromBufferAttribute(y,b),u.fromBufferAttribute(y,b+1),IC.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const E=e.ray.origin.distanceTo(d);E<e.near||E>e.far||t.push({distance:E,point:h.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}const nP=new G,sP=new G;class Da extends Ac{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[];for(let i=0,r=t.count;i<r;i+=2)nP.fromBufferAttribute(t,i),sP.fromBufferAttribute(t,i+1),s[i]=i===0?0:s[i-1],s[i+1]=s[i]+nP.distanceTo(sP);e.setAttribute("lineDistance",new ut(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class n5 extends Ac{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class dA extends li{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Je(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const iP=new kt,nI=new P0,Yy=new _l,Zy=new G;class s5 extends fn{constructor(e=new Bt,t=new dA){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),Yy.copy(s.boundingSphere),Yy.applyMatrix4(i),Yy.radius+=r,e.ray.intersectsSphere(Yy)===!1)return;iP.copy(i).invert(),nI.copy(e.ray).applyMatrix4(iP);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=s.index,h=s.attributes.position;if(c!==null){const d=Math.max(0,o.start),f=Math.min(c.count,o.start+o.count);for(let m=d,x=f;m<x;m++){const y=c.getX(m);Zy.fromBufferAttribute(h,y),rP(Zy,y,l,i,e,t,this)}}else{const d=Math.max(0,o.start),f=Math.min(h.count,o.start+o.count);for(let m=d,x=f;m<x;m++)Zy.fromBufferAttribute(h,m),rP(Zy,m,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}function rP(n,e,t,s,i,r,o){const a=nI.distanceSqToPoint(n);if(a<t){const l=new G;nI.closestPointToPoint(n,l),l.applyMatrix4(s);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class QSe extends ns{constructor(e,t,s,i,r,o,a,l,c){super(e,t,s,i,r,o,a,l,c),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:us,this.magFilter=r!==void 0?r:us,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class e_e extends ns{constructor(e,t,s){super({width:e,height:t}),this.isFramebufferTexture=!0,this.format=s,this.magFilter=ws,this.minFilter=ws,this.generateMipmaps=!1,this.needsUpdate=!0}}class fA extends ns{constructor(e,t,s,i,r,o,a,l,c,u,h,d){super(null,o,a,l,c,u,i,r,h,d),this.isCompressedTexture=!0,this.image={width:t,height:s},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class t_e extends fA{constructor(e,t,s,i,r,o){super(e,t,s,r,o),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=Si}}class n_e extends ns{constructor(e,t,s,i,r,o,a,l,c){super(e,t,s,i,r,o,a,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Yo{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const s=this.getUtoTmapping(e);return this.getPoint(s,t)}getPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return t}getSpacedPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPointAt(s/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let s,i=this.getPoint(0),r=0;t.push(0);for(let o=1;o<=e;o++)s=this.getPoint(o/e),r+=s.distanceTo(i),t.push(r),i=s;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const s=this.getLengths();let i=0;const r=s.length;let o;t?o=t:o=e*s[r-1];let a=0,l=r-1,c;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),c=s[i]-o,c<0)a=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,s[i]===o)return i/(r-1);const u=s[i],d=s[i+1]-u,f=(o-u)/d;return(i+f)/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const o=this.getPoint(i),a=this.getPoint(r),l=t||(o.isVector2?new Ae:new G);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const s=this.getUtoTmapping(e);return this.getTangent(s,t)}computeFrenetFrames(e,t){const s=new G,i=[],r=[],o=[],a=new G,l=new kt;for(let f=0;f<=e;f++){const m=f/e;i[f]=this.getTangentAt(m,new G)}r[0]=new G,o[0]=new G;let c=Number.MAX_VALUE;const u=Math.abs(i[0].x),h=Math.abs(i[0].y),d=Math.abs(i[0].z);u<=c&&(c=u,s.set(1,0,0)),h<=c&&(c=h,s.set(0,1,0)),d<=c&&s.set(0,0,1),a.crossVectors(i[0],s).normalize(),r[0].crossVectors(i[0],a),o[0].crossVectors(i[0],r[0]);for(let f=1;f<=e;f++){if(r[f]=r[f-1].clone(),o[f]=o[f-1].clone(),a.crossVectors(i[f-1],i[f]),a.length()>Number.EPSILON){a.normalize();const m=Math.acos(hs(i[f-1].dot(i[f]),-1,1));r[f].applyMatrix4(l.makeRotationAxis(a,m))}o[f].crossVectors(i[f],r[f])}if(t===!0){let f=Math.acos(hs(r[0].dot(r[e]),-1,1));f/=e,i[0].dot(a.crossVectors(r[0],r[e]))>0&&(f=-f);for(let m=1;m<=e;m++)r[m].applyMatrix4(l.makeRotationAxis(i[m],f*m)),o[m].crossVectors(i[m],r[m])}return{tangents:i,normals:r,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Yb extends Yo{constructor(e=0,t=0,s=1,i=1,r=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=s,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t){const s=t||new Ae,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const o=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(o?r=0:r=i),this.aClockwise===!0&&!o&&(r===i?r=-i:r=r-i);const a=this.aStartAngle+e*r;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*u-f*h+this.aX,c=d*h+f*u+this.aY}return s.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class i5 extends Yb{constructor(e,t,s,i,r,o){super(e,t,s,s,i,r,o),this.isArcCurve=!0,this.type="ArcCurve"}}function pA(){let n=0,e=0,t=0,s=0;function i(r,o,a,l){n=r,e=a,t=-3*r+3*o-2*a-l,s=2*r-2*o+a+l}return{initCatmullRom:function(r,o,a,l,c){i(o,a,c*(a-r),c*(l-o))},initNonuniformCatmullRom:function(r,o,a,l,c,u,h){let d=(o-r)/c-(a-r)/(c+u)+(a-o)/u,f=(a-o)/u-(l-o)/(u+h)+(l-a)/h;d*=u,f*=u,i(o,a,d,f)},calc:function(r){const o=r*r,a=o*r;return n+e*r+t*o+s*a}}}const Jy=new G,EC=new pA,MC=new pA,kC=new pA;class r5 extends Yo{constructor(e=[],t=!1,s="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=s,this.tension=i}getPoint(e,t=new G){const s=t,i=this.points,r=i.length,o=(r-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/r)+1)*r:l===0&&a===r-1&&(a=r-2,l=1);let c,u;this.closed||a>0?c=i[(a-1)%r]:(Jy.subVectors(i[0],i[1]).add(i[0]),c=Jy);const h=i[a%r],d=i[(a+1)%r];if(this.closed||a+2<r?u=i[(a+2)%r]:(Jy.subVectors(i[r-1],i[r-2]).add(i[r-1]),u=Jy),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let m=Math.pow(c.distanceToSquared(h),f),x=Math.pow(h.distanceToSquared(d),f),y=Math.pow(d.distanceToSquared(u),f);x<1e-4&&(x=1),m<1e-4&&(m=x),y<1e-4&&(y=x),EC.initNonuniformCatmullRom(c.x,h.x,d.x,u.x,m,x,y),MC.initNonuniformCatmullRom(c.y,h.y,d.y,u.y,m,x,y),kC.initNonuniformCatmullRom(c.z,h.z,d.z,u.z,m,x,y)}else this.curveType==="catmullrom"&&(EC.initCatmullRom(c.x,h.x,d.x,u.x,this.tension),MC.initCatmullRom(c.y,h.y,d.y,u.y,this.tension),kC.initCatmullRom(c.z,h.z,d.z,u.z,this.tension));return s.set(EC.calc(l),MC.calc(l),kC.calc(l)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(new G().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function oP(n,e,t,s,i){const r=(s-e)*.5,o=(i-t)*.5,a=n*n,l=n*a;return(2*t-2*s+r+o)*l+(-3*t+3*s-2*r-o)*a+r*n+t}function s_e(n,e){const t=1-n;return t*t*e}function i_e(n,e){return 2*(1-n)*n*e}function r_e(n,e){return n*n*e}function dm(n,e,t,s){return s_e(n,e)+i_e(n,t)+r_e(n,s)}function o_e(n,e){const t=1-n;return t*t*t*e}function a_e(n,e){const t=1-n;return 3*t*t*n*e}function l_e(n,e){return 3*(1-n)*n*n*e}function c_e(n,e){return n*n*n*e}function fm(n,e,t,s,i){return o_e(n,e)+a_e(n,t)+l_e(n,s)+c_e(n,i)}class mA extends Yo{constructor(e=new Ae,t=new Ae,s=new Ae,i=new Ae){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=s,this.v3=i}getPoint(e,t=new Ae){const s=t,i=this.v0,r=this.v1,o=this.v2,a=this.v3;return s.set(fm(e,i.x,r.x,o.x,a.x),fm(e,i.y,r.y,o.y,a.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class o5 extends Yo{constructor(e=new G,t=new G,s=new G,i=new G){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=s,this.v3=i}getPoint(e,t=new G){const s=t,i=this.v0,r=this.v1,o=this.v2,a=this.v3;return s.set(fm(e,i.x,r.x,o.x,a.x),fm(e,i.y,r.y,o.y,a.y),fm(e,i.z,r.z,o.z,a.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class Zb extends Yo{constructor(e=new Ae,t=new Ae){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Ae){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const s=t||new Ae;return s.copy(this.v2).sub(this.v1).normalize(),s}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class a5 extends Yo{constructor(e=new G,t=new G){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new G){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class gA extends Yo{constructor(e=new Ae,t=new Ae,s=new Ae){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new Ae){const s=t,i=this.v0,r=this.v1,o=this.v2;return s.set(dm(e,i.x,r.x,o.x),dm(e,i.y,r.y,o.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class xA extends Yo{constructor(e=new G,t=new G,s=new G){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new G){const s=t,i=this.v0,r=this.v1,o=this.v2;return s.set(dm(e,i.x,r.x,o.x),dm(e,i.y,r.y,o.y),dm(e,i.z,r.z,o.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class yA extends Yo{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Ae){const s=t,i=this.points,r=(i.length-1)*e,o=Math.floor(r),a=r-o,l=i[o===0?o:o-1],c=i[o],u=i[o>i.length-2?i.length-1:o+1],h=i[o>i.length-3?i.length-1:o+2];return s.set(oP(a,l.x,c.x,u.x,h.x),oP(a,l.y,c.y,u.y,h.y)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const i=e.points[t];this.points.push(new Ae().fromArray(i))}return this}}var vA=Object.freeze({__proto__:null,ArcCurve:i5,CatmullRomCurve3:r5,CubicBezierCurve:mA,CubicBezierCurve3:o5,EllipseCurve:Yb,LineCurve:Zb,LineCurve3:a5,QuadraticBezierCurve:gA,QuadraticBezierCurve3:xA,SplineCurve:yA});class l5 extends Yo{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Zb(t,e))}getPoint(e,t){const s=e*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=s){const o=i[r]-s,a=this.curves[r],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,t)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let s=0,i=this.curves.length;s<i;s++)t+=this.curves[s].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let s;for(let i=0,r=this.curves;i<r.length;i++){const o=r[i],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let c=0;c<l.length;c++){const u=l[c];s&&s.equals(u)||(t.push(u),s=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,s=this.curves.length;t<s;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const i=e.curves[t];this.curves.push(new vA[i.type]().fromJSON(i))}return this}}class Jm extends l5{constructor(e){super(),this.type="Path",this.currentPoint=new Ae,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,s=e.length;t<s;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const s=new Zb(this.currentPoint.clone(),new Ae(e,t));return this.curves.push(s),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,s,i){const r=new gA(this.currentPoint.clone(),new Ae(e,t),new Ae(s,i));return this.curves.push(r),this.currentPoint.set(s,i),this}bezierCurveTo(e,t,s,i,r,o){const a=new mA(this.currentPoint.clone(),new Ae(e,t),new Ae(s,i),new Ae(r,o));return this.curves.push(a),this.currentPoint.set(r,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),s=new yA(t);return this.curves.push(s),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,s,i,r,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,s,i,r,o),this}absarc(e,t,s,i,r,o){return this.absellipse(e,t,s,s,i,r,o),this}ellipse(e,t,s,i,r,o,a,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,t+u,s,i,r,o,a,l),this}absellipse(e,t,s,i,r,o,a,l){const c=new Yb(e,t,s,i,r,o,a,l);if(this.curves.length>0){const h=c.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class jf extends Bt{constructor(e=[new Ae(0,-.5),new Ae(.5,0),new Ae(0,.5)],t=12,s=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:s,phiLength:i},t=Math.floor(t),i=hs(i,0,Math.PI*2);const r=[],o=[],a=[],l=[],c=[],u=1/t,h=new G,d=new Ae,f=new G,m=new G,x=new G;let y=0,v=0;for(let w=0;w<=e.length-1;w++)switch(w){case 0:y=e[w+1].x-e[w].x,v=e[w+1].y-e[w].y,f.x=v*1,f.y=-y,f.z=v*0,x.copy(f),f.normalize(),l.push(f.x,f.y,f.z);break;case e.length-1:l.push(x.x,x.y,x.z);break;default:y=e[w+1].x-e[w].x,v=e[w+1].y-e[w].y,f.x=v*1,f.y=-y,f.z=v*0,m.copy(f),f.x+=x.x,f.y+=x.y,f.z+=x.z,f.normalize(),l.push(f.x,f.y,f.z),x.copy(m)}for(let w=0;w<=t;w++){const b=s+w*u*i,S=Math.sin(b),C=Math.cos(b);for(let E=0;E<=e.length-1;E++){h.x=e[E].x*S,h.y=e[E].y,h.z=e[E].x*C,o.push(h.x,h.y,h.z),d.x=w/t,d.y=E/(e.length-1),a.push(d.x,d.y);const k=l[3*E+0]*S,I=l[3*E+1],A=l[3*E+0]*C;c.push(k,I,A)}}for(let w=0;w<t;w++)for(let b=0;b<e.length-1;b++){const S=b+w*e.length,C=S,E=S+e.length,k=S+e.length+1,I=S+1;r.push(C,E,I),r.push(k,I,E)}this.setIndex(r),this.setAttribute("position",new ut(o,3)),this.setAttribute("uv",new ut(a,2)),this.setAttribute("normal",new ut(c,3))}static fromJSON(e){return new jf(e.points,e.segments,e.phiStart,e.phiLength)}}class O0 extends jf{constructor(e=1,t=1,s=4,i=8){const r=new Jm;r.absarc(0,-t/2,e,Math.PI*1.5,0),r.absarc(0,t/2,e,0,Math.PI*.5),super(r.getPoints(s),i),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:s,radialSegments:i}}static fromJSON(e){return new O0(e.radius,e.length,e.capSegments,e.radialSegments)}}class z0 extends Bt{constructor(e=1,t=8,s=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:s,thetaLength:i},t=Math.max(3,t);const r=[],o=[],a=[],l=[],c=new G,u=new Ae;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const f=s+h/t*i;c.x=e*Math.cos(f),c.y=e*Math.sin(f),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[d]/e+1)/2,u.y=(o[d+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)r.push(h,h+1,0);this.setIndex(r),this.setAttribute("position",new ut(o,3)),this.setAttribute("normal",new ut(a,3)),this.setAttribute("uv",new ut(l,2))}static fromJSON(e){return new z0(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Rh extends Bt{constructor(e=1,t=1,s=1,i=8,r=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:s,radialSegments:i,heightSegments:r,openEnded:o,thetaStart:a,thetaLength:l};const c=this;i=Math.floor(i),r=Math.floor(r);const u=[],h=[],d=[],f=[];let m=0;const x=[],y=s/2;let v=0;w(),o===!1&&(e>0&&b(!0),t>0&&b(!1)),this.setIndex(u),this.setAttribute("position",new ut(h,3)),this.setAttribute("normal",new ut(d,3)),this.setAttribute("uv",new ut(f,2));function w(){const S=new G,C=new G;let E=0;const k=(t-e)/s;for(let I=0;I<=r;I++){const A=[],N=I/r,L=N*(t-e)+e;for(let V=0;V<=i;V++){const O=V/i,P=O*l+a,W=Math.sin(P),H=Math.cos(P);C.x=L*W,C.y=-N*s+y,C.z=L*H,h.push(C.x,C.y,C.z),S.set(W,k,H).normalize(),d.push(S.x,S.y,S.z),f.push(O,1-N),A.push(m++)}x.push(A)}for(let I=0;I<i;I++)for(let A=0;A<r;A++){const N=x[A][I],L=x[A+1][I],V=x[A+1][I+1],O=x[A][I+1];u.push(N,L,O),u.push(L,V,O),E+=6}c.addGroup(v,E,0),v+=E}function b(S){const C=m,E=new Ae,k=new G;let I=0;const A=S===!0?e:t,N=S===!0?1:-1;for(let V=1;V<=i;V++)h.push(0,y*N,0),d.push(0,N,0),f.push(.5,.5),m++;const L=m;for(let V=0;V<=i;V++){const P=V/i*l+a,W=Math.cos(P),H=Math.sin(P);k.x=A*H,k.y=y*N,k.z=A*W,h.push(k.x,k.y,k.z),d.push(0,N,0),E.x=W*.5+.5,E.y=H*.5*N+.5,f.push(E.x,E.y),m++}for(let V=0;V<i;V++){const O=C+V,P=L+V;S===!0?u.push(P,P+1,O):u.push(P+1,P,O),I+=3}c.addGroup(v,I,S===!0?1:2),v+=I}}static fromJSON(e){return new Rh(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class B0 extends Rh{constructor(e=1,t=1,s=8,i=1,r=!1,o=0,a=Math.PI*2){super(0,e,t,s,i,r,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:s,heightSegments:i,openEnded:r,thetaStart:o,thetaLength:a}}static fromJSON(e){return new B0(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Il extends Bt{constructor(e=[],t=[],s=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:s,detail:i};const r=[],o=[];a(i),c(s),u(),this.setAttribute("position",new ut(r,3)),this.setAttribute("normal",new ut(r.slice(),3)),this.setAttribute("uv",new ut(o,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function a(w){const b=new G,S=new G,C=new G;for(let E=0;E<t.length;E+=3)f(t[E+0],b),f(t[E+1],S),f(t[E+2],C),l(b,S,C,w)}function l(w,b,S,C){const E=C+1,k=[];for(let I=0;I<=E;I++){k[I]=[];const A=w.clone().lerp(S,I/E),N=b.clone().lerp(S,I/E),L=E-I;for(let V=0;V<=L;V++)V===0&&I===E?k[I][V]=A:k[I][V]=A.clone().lerp(N,V/L)}for(let I=0;I<E;I++)for(let A=0;A<2*(E-I)-1;A++){const N=Math.floor(A/2);A%2===0?(d(k[I][N+1]),d(k[I+1][N]),d(k[I][N])):(d(k[I][N+1]),d(k[I+1][N+1]),d(k[I+1][N]))}}function c(w){const b=new G;for(let S=0;S<r.length;S+=3)b.x=r[S+0],b.y=r[S+1],b.z=r[S+2],b.normalize().multiplyScalar(w),r[S+0]=b.x,r[S+1]=b.y,r[S+2]=b.z}function u(){const w=new G;for(let b=0;b<r.length;b+=3){w.x=r[b+0],w.y=r[b+1],w.z=r[b+2];const S=y(w)/2/Math.PI+.5,C=v(w)/Math.PI+.5;o.push(S,1-C)}m(),h()}function h(){for(let w=0;w<o.length;w+=6){const b=o[w+0],S=o[w+2],C=o[w+4],E=Math.max(b,S,C),k=Math.min(b,S,C);E>.9&&k<.1&&(b<.2&&(o[w+0]+=1),S<.2&&(o[w+2]+=1),C<.2&&(o[w+4]+=1))}}function d(w){r.push(w.x,w.y,w.z)}function f(w,b){const S=w*3;b.x=e[S+0],b.y=e[S+1],b.z=e[S+2]}function m(){const w=new G,b=new G,S=new G,C=new G,E=new Ae,k=new Ae,I=new Ae;for(let A=0,N=0;A<r.length;A+=9,N+=6){w.set(r[A+0],r[A+1],r[A+2]),b.set(r[A+3],r[A+4],r[A+5]),S.set(r[A+6],r[A+7],r[A+8]),E.set(o[N+0],o[N+1]),k.set(o[N+2],o[N+3]),I.set(o[N+4],o[N+5]),C.copy(w).add(b).add(S).divideScalar(3);const L=y(C);x(E,N+0,w,L),x(k,N+2,b,L),x(I,N+4,S,L)}}function x(w,b,S,C){C<0&&w.x===1&&(o[b]=w.x-1),S.x===0&&S.z===0&&(o[b]=C/2/Math.PI+.5)}function y(w){return Math.atan2(w.z,-w.x)}function v(w){return Math.atan2(-w.y,Math.sqrt(w.x*w.x+w.z*w.z))}}static fromJSON(e){return new Il(e.vertices,e.indices,e.radius,e.details)}}class U0 extends Il{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,i=1/s,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-s,0,-i,s,0,i,-s,0,i,s,-i,-s,0,-i,s,0,i,-s,0,i,s,0,-s,0,-i,s,0,-i,-s,0,i,s,0,i],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new U0(e.radius,e.detail)}}const Qy=new G,ev=new G,AC=new G,tv=new so;class c5 extends Bt{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),r=Math.cos(Wu*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),d={},f=[];for(let m=0;m<l;m+=3){o?(c[0]=o.getX(m),c[1]=o.getX(m+1),c[2]=o.getX(m+2)):(c[0]=m,c[1]=m+1,c[2]=m+2);const{a:x,b:y,c:v}=tv;if(x.fromBufferAttribute(a,c[0]),y.fromBufferAttribute(a,c[1]),v.fromBufferAttribute(a,c[2]),tv.getNormal(AC),h[0]=`${Math.round(x.x*i)},${Math.round(x.y*i)},${Math.round(x.z*i)}`,h[1]=`${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`,h[2]=`${Math.round(v.x*i)},${Math.round(v.y*i)},${Math.round(v.z*i)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let w=0;w<3;w++){const b=(w+1)%3,S=h[w],C=h[b],E=tv[u[w]],k=tv[u[b]],I=`${S}_${C}`,A=`${C}_${S}`;A in d&&d[A]?(AC.dot(d[A].normal)<=r&&(f.push(E.x,E.y,E.z),f.push(k.x,k.y,k.z)),d[A]=null):I in d||(d[I]={index0:c[w],index1:c[b],normal:AC.clone()})}}for(const m in d)if(d[m]){const{index0:x,index1:y}=d[m];Qy.fromBufferAttribute(a,x),ev.fromBufferAttribute(a,y),f.push(Qy.x,Qy.y,Qy.z),f.push(ev.x,ev.y,ev.z)}this.setAttribute("position",new ut(f,3))}}}class Xu extends Jm{constructor(e){super(e),this.uuid=Mr(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let s=0,i=this.holes.length;s<i;s++)t[s]=this.holes[s].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,s=this.holes.length;t<s;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const i=e.holes[t];this.holes.push(new Jm().fromJSON(i))}return this}}const u_e={triangulate:function(n,e,t=2){const s=e&&e.length,i=s?e[0]*t:n.length;let r=u5(n,0,i,t,!0);const o=[];if(!r||r.next===r.prev)return o;let a,l,c,u,h,d,f;if(s&&(r=m_e(n,e,r,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let m=t;m<i;m+=t)h=n[m],d=n[m+1],h<a&&(a=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);f=Math.max(c-a,u-l),f=f!==0?32767/f:0}return Qm(r,o,t,a,l,f,0),o}};function u5(n,e,t,s,i){let r,o;if(i===I_e(n,e,t,s)>0)for(r=e;r<t;r+=s)o=aP(r,n[r],n[r+1],o);else for(r=t-s;r>=e;r-=s)o=aP(r,n[r],n[r+1],o);return o&&Jb(o,o.next)&&(tg(o),o=o.next),o}function mh(n,e){if(!n)return n;e||(e=n);let t=n,s;do if(s=!1,!t.steiner&&(Jb(t,t.next)||Xn(t.prev,t,t.next)===0)){if(tg(t),t=e=t.prev,t===t.next)break;s=!0}else t=t.next;while(s||t!==e);return e}function Qm(n,e,t,s,i,r,o){if(!n)return;!o&&r&&w_e(n,s,i,r);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,r?d_e(n,s,i,r):h_e(n)){e.push(l.i/t|0),e.push(n.i/t|0),e.push(c.i/t|0),tg(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=f_e(mh(n),e,t),Qm(n,e,t,s,i,r,2)):o===2&&p_e(n,e,t,s,i,r):Qm(mh(n),e,t,s,i,r,1);break}}}function h_e(n){const e=n.prev,t=n,s=n.next;if(Xn(e,t,s)>=0)return!1;const i=e.x,r=t.x,o=s.x,a=e.y,l=t.y,c=s.y,u=i<r?i<o?i:o:r<o?r:o,h=a<l?a<c?a:c:l<c?l:c,d=i>r?i>o?i:o:r>o?r:o,f=a>l?a>c?a:c:l>c?l:c;let m=s.next;for(;m!==e;){if(m.x>=u&&m.x<=d&&m.y>=h&&m.y<=f&&Fd(i,a,r,l,o,c,m.x,m.y)&&Xn(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function d_e(n,e,t,s){const i=n.prev,r=n,o=n.next;if(Xn(i,r,o)>=0)return!1;const a=i.x,l=r.x,c=o.x,u=i.y,h=r.y,d=o.y,f=a<l?a<c?a:c:l<c?l:c,m=u<h?u<d?u:d:h<d?h:d,x=a>l?a>c?a:c:l>c?l:c,y=u>h?u>d?u:d:h>d?h:d,v=sI(f,m,e,t,s),w=sI(x,y,e,t,s);let b=n.prevZ,S=n.nextZ;for(;b&&b.z>=v&&S&&S.z<=w;){if(b.x>=f&&b.x<=x&&b.y>=m&&b.y<=y&&b!==i&&b!==o&&Fd(a,u,l,h,c,d,b.x,b.y)&&Xn(b.prev,b,b.next)>=0||(b=b.prevZ,S.x>=f&&S.x<=x&&S.y>=m&&S.y<=y&&S!==i&&S!==o&&Fd(a,u,l,h,c,d,S.x,S.y)&&Xn(S.prev,S,S.next)>=0))return!1;S=S.nextZ}for(;b&&b.z>=v;){if(b.x>=f&&b.x<=x&&b.y>=m&&b.y<=y&&b!==i&&b!==o&&Fd(a,u,l,h,c,d,b.x,b.y)&&Xn(b.prev,b,b.next)>=0)return!1;b=b.prevZ}for(;S&&S.z<=w;){if(S.x>=f&&S.x<=x&&S.y>=m&&S.y<=y&&S!==i&&S!==o&&Fd(a,u,l,h,c,d,S.x,S.y)&&Xn(S.prev,S,S.next)>=0)return!1;S=S.nextZ}return!0}function f_e(n,e,t){let s=n;do{const i=s.prev,r=s.next.next;!Jb(i,r)&&h5(i,s,s.next,r)&&eg(i,r)&&eg(r,i)&&(e.push(i.i/t|0),e.push(s.i/t|0),e.push(r.i/t|0),tg(s),tg(s.next),s=n=r),s=s.next}while(s!==n);return mh(s)}function p_e(n,e,t,s,i,r){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&__e(o,a)){let l=d5(o,a);o=mh(o,o.next),l=mh(l,l.next),Qm(o,e,t,s,i,r,0),Qm(l,e,t,s,i,r,0);return}a=a.next}o=o.next}while(o!==n)}function m_e(n,e,t,s){const i=[];let r,o,a,l,c;for(r=0,o=e.length;r<o;r++)a=e[r]*s,l=r<o-1?e[r+1]*s:n.length,c=u5(n,a,l,s,!1),c===c.next&&(c.steiner=!0),i.push(S_e(c));for(i.sort(g_e),r=0;r<i.length;r++)t=x_e(i[r],t);return t}function g_e(n,e){return n.x-e.x}function x_e(n,e){const t=y_e(n,e);if(!t)return e;const s=d5(t,n);return mh(s,s.next),mh(t,t.next)}function y_e(n,e){let t=e,s=-1/0,i;const r=n.x,o=n.y;do{if(o<=t.y&&o>=t.next.y&&t.next.y!==t.y){const d=t.x+(o-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=r&&d>s&&(s=d,i=t.x<t.next.x?t:t.next,d===r))return i}t=t.next}while(t!==e);if(!i)return null;const a=i,l=i.x,c=i.y;let u=1/0,h;t=i;do r>=t.x&&t.x>=l&&r!==t.x&&Fd(o<c?r:s,o,l,c,o<c?s:r,o,t.x,t.y)&&(h=Math.abs(o-t.y)/(r-t.x),eg(t,n)&&(h<u||h===u&&(t.x>i.x||t.x===i.x&&v_e(i,t)))&&(i=t,u=h)),t=t.next;while(t!==a);return i}function v_e(n,e){return Xn(n.prev,n,e.prev)<0&&Xn(e.next,n,n.next)<0}function w_e(n,e,t,s){let i=n;do i.z===0&&(i.z=sI(i.x,i.y,e,t,s)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==n);i.prevZ.nextZ=null,i.prevZ=null,b_e(i)}function b_e(n){let e,t,s,i,r,o,a,l,c=1;do{for(t=n,n=null,r=null,o=0;t;){for(o++,s=t,a=0,e=0;e<c&&(a++,s=s.nextZ,!!s);e++);for(l=c;a>0||l>0&&s;)a!==0&&(l===0||!s||t.z<=s.z)?(i=t,t=t.nextZ,a--):(i=s,s=s.nextZ,l--),r?r.nextZ=i:n=i,i.prevZ=r,r=i;t=s}r.nextZ=null,c*=2}while(o>1);return n}function sI(n,e,t,s,i){return n=(n-t)*i|0,e=(e-s)*i|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function S_e(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Fd(n,e,t,s,i,r,o,a){return(i-o)*(e-a)>=(n-o)*(r-a)&&(n-o)*(s-a)>=(t-o)*(e-a)&&(t-o)*(r-a)>=(i-o)*(s-a)}function __e(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!C_e(n,e)&&(eg(n,e)&&eg(e,n)&&T_e(n,e)&&(Xn(n.prev,n,e.prev)||Xn(n,e.prev,e))||Jb(n,e)&&Xn(n.prev,n,n.next)>0&&Xn(e.prev,e,e.next)>0)}function Xn(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function Jb(n,e){return n.x===e.x&&n.y===e.y}function h5(n,e,t,s){const i=sv(Xn(n,e,t)),r=sv(Xn(n,e,s)),o=sv(Xn(t,s,n)),a=sv(Xn(t,s,e));return!!(i!==r&&o!==a||i===0&&nv(n,t,e)||r===0&&nv(n,s,e)||o===0&&nv(t,n,s)||a===0&&nv(t,e,s))}function nv(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function sv(n){return n>0?1:n<0?-1:0}function C_e(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&h5(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function eg(n,e){return Xn(n.prev,n,n.next)<0?Xn(n,e,n.next)>=0&&Xn(n,n.prev,e)>=0:Xn(n,e,n.prev)<0||Xn(n,n.next,e)<0}function T_e(n,e){let t=n,s=!1;const i=(n.x+e.x)/2,r=(n.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(s=!s),t=t.next;while(t!==n);return s}function d5(n,e){const t=new iI(n.i,n.x,n.y),s=new iI(e.i,e.x,e.y),i=n.next,r=e.prev;return n.next=e,e.prev=n,t.next=i,i.prev=t,s.next=t,t.prev=s,r.next=s,s.prev=r,s}function aP(n,e,t,s){const i=new iI(n,e,t);return s?(i.next=s.next,i.prev=s,s.next.prev=i,s.next=i):(i.prev=i,i.next=i),i}function tg(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function iI(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function I_e(n,e,t,s){let i=0;for(let r=e,o=t-s;r<t;r+=s)i+=(n[o]-n[r])*(n[r+1]+n[o+1]),o=r;return i}class Ea{static area(e){const t=e.length;let s=0;for(let i=t-1,r=0;r<t;i=r++)s+=e[i].x*e[r].y-e[r].x*e[i].y;return s*.5}static isClockWise(e){return Ea.area(e)<0}static triangulateShape(e,t){const s=[],i=[],r=[];lP(e),cP(s,e);let o=e.length;t.forEach(lP);for(let l=0;l<t.length;l++)i.push(o),o+=t[l].length,cP(s,t[l]);const a=u_e.triangulate(s,i);for(let l=0;l<a.length;l+=3)r.push(a.slice(l,l+3));return r}}function lP(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function cP(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class V0 extends Bt{constructor(e=new Xu([new Ae(.5,.5),new Ae(-.5,.5),new Ae(-.5,-.5),new Ae(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const s=this,i=[],r=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new ut(i,3)),this.setAttribute("uv",new ut(r,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1,h=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,f=t.bevelThickness!==void 0?t.bevelThickness:.2,m=t.bevelSize!==void 0?t.bevelSize:f-.1,x=t.bevelOffset!==void 0?t.bevelOffset:0,y=t.bevelSegments!==void 0?t.bevelSegments:3;const v=t.extrudePath,w=t.UVGenerator!==void 0?t.UVGenerator:E_e;let b,S=!1,C,E,k,I;v&&(b=v.getSpacedPoints(u),S=!0,d=!1,C=v.computeFrenetFrames(u,!1),E=new G,k=new G,I=new G),d||(y=0,f=0,m=0,x=0);const A=a.extractPoints(c);let N=A.shape;const L=A.holes;if(!Ea.isClockWise(N)){N=N.reverse();for(let ye=0,fe=L.length;ye<fe;ye++){const Re=L[ye];Ea.isClockWise(Re)&&(L[ye]=Re.reverse())}}const O=Ea.triangulateShape(N,L),P=N;for(let ye=0,fe=L.length;ye<fe;ye++){const Re=L[ye];N=N.concat(Re)}function W(ye,fe,Re){return fe||console.error("THREE.ExtrudeGeometry: vec does not exist"),fe.clone().multiplyScalar(Re).add(ye)}const H=N.length,Y=O.length;function D(ye,fe,Re){let We,Le,nt;const Ke=ye.x-fe.x,ot=ye.y-fe.y,vt=Re.x-ye.x,Dt=Re.y-ye.y,q=Ke*Ke+ot*ot,z=Ke*Dt-ot*vt;if(Math.abs(z)>Number.EPSILON){const ge=Math.sqrt(q),Pe=Math.sqrt(vt*vt+Dt*Dt),ze=fe.x-ot/ge,Xe=fe.y+Ke/ge,ft=Re.x-Dt/Pe,Ye=Re.y+vt/Pe,Te=((ft-ze)*Dt-(Ye-Xe)*vt)/(Ke*Dt-ot*vt);We=ze+Ke*Te-ye.x,Le=Xe+ot*Te-ye.y;const ht=We*We+Le*Le;if(ht<=2)return new Ae(We,Le);nt=Math.sqrt(ht/2)}else{let ge=!1;Ke>Number.EPSILON?vt>Number.EPSILON&&(ge=!0):Ke<-Number.EPSILON?vt<-Number.EPSILON&&(ge=!0):Math.sign(ot)===Math.sign(Dt)&&(ge=!0),ge?(We=-ot,Le=Ke,nt=Math.sqrt(q)):(We=Ke,Le=ot,nt=Math.sqrt(q/2))}return new Ae(We/nt,Le/nt)}const $=[];for(let ye=0,fe=P.length,Re=fe-1,We=ye+1;ye<fe;ye++,Re++,We++)Re===fe&&(Re=0),We===fe&&(We=0),$[ye]=D(P[ye],P[Re],P[We]);const U=[];let B,X=$.concat();for(let ye=0,fe=L.length;ye<fe;ye++){const Re=L[ye];B=[];for(let We=0,Le=Re.length,nt=Le-1,Ke=We+1;We<Le;We++,nt++,Ke++)nt===Le&&(nt=0),Ke===Le&&(Ke=0),B[We]=D(Re[We],Re[nt],Re[Ke]);U.push(B),X=X.concat(B)}for(let ye=0;ye<y;ye++){const fe=ye/y,Re=f*Math.cos(fe*Math.PI/2),We=m*Math.sin(fe*Math.PI/2)+x;for(let Le=0,nt=P.length;Le<nt;Le++){const Ke=W(P[Le],$[Le],We);ke(Ke.x,Ke.y,-Re)}for(let Le=0,nt=L.length;Le<nt;Le++){const Ke=L[Le];B=U[Le];for(let ot=0,vt=Ke.length;ot<vt;ot++){const Dt=W(Ke[ot],B[ot],We);ke(Dt.x,Dt.y,-Re)}}}const te=m+x;for(let ye=0;ye<H;ye++){const fe=d?W(N[ye],X[ye],te):N[ye];S?(k.copy(C.normals[0]).multiplyScalar(fe.x),E.copy(C.binormals[0]).multiplyScalar(fe.y),I.copy(b[0]).add(k).add(E),ke(I.x,I.y,I.z)):ke(fe.x,fe.y,0)}for(let ye=1;ye<=u;ye++)for(let fe=0;fe<H;fe++){const Re=d?W(N[fe],X[fe],te):N[fe];S?(k.copy(C.normals[ye]).multiplyScalar(Re.x),E.copy(C.binormals[ye]).multiplyScalar(Re.y),I.copy(b[ye]).add(k).add(E),ke(I.x,I.y,I.z)):ke(Re.x,Re.y,h/u*ye)}for(let ye=y-1;ye>=0;ye--){const fe=ye/y,Re=f*Math.cos(fe*Math.PI/2),We=m*Math.sin(fe*Math.PI/2)+x;for(let Le=0,nt=P.length;Le<nt;Le++){const Ke=W(P[Le],$[Le],We);ke(Ke.x,Ke.y,h+Re)}for(let Le=0,nt=L.length;Le<nt;Le++){const Ke=L[Le];B=U[Le];for(let ot=0,vt=Ke.length;ot<vt;ot++){const Dt=W(Ke[ot],B[ot],We);S?ke(Dt.x,Dt.y+b[u-1].y,b[u-1].x+Re):ke(Dt.x,Dt.y,h+Re)}}}oe(),ue();function oe(){const ye=i.length/3;if(d){let fe=0,Re=H*fe;for(let We=0;We<Y;We++){const Le=O[We];Me(Le[2]+Re,Le[1]+Re,Le[0]+Re)}fe=u+y*2,Re=H*fe;for(let We=0;We<Y;We++){const Le=O[We];Me(Le[0]+Re,Le[1]+Re,Le[2]+Re)}}else{for(let fe=0;fe<Y;fe++){const Re=O[fe];Me(Re[2],Re[1],Re[0])}for(let fe=0;fe<Y;fe++){const Re=O[fe];Me(Re[0]+H*u,Re[1]+H*u,Re[2]+H*u)}}s.addGroup(ye,i.length/3-ye,0)}function ue(){const ye=i.length/3;let fe=0;Q(P,fe),fe+=P.length;for(let Re=0,We=L.length;Re<We;Re++){const Le=L[Re];Q(Le,fe),fe+=Le.length}s.addGroup(ye,i.length/3-ye,1)}function Q(ye,fe){let Re=ye.length;for(;--Re>=0;){const We=Re;let Le=Re-1;Le<0&&(Le=ye.length-1);for(let nt=0,Ke=u+y*2;nt<Ke;nt++){const ot=H*nt,vt=H*(nt+1),Dt=fe+We+ot,q=fe+Le+ot,z=fe+Le+vt,ge=fe+We+vt;De(Dt,q,z,ge)}}}function ke(ye,fe,Re){l.push(ye),l.push(fe),l.push(Re)}function Me(ye,fe,Re){Ee(ye),Ee(fe),Ee(Re);const We=i.length/3,Le=w.generateTopUV(s,i,We-3,We-2,We-1);Be(Le[0]),Be(Le[1]),Be(Le[2])}function De(ye,fe,Re,We){Ee(ye),Ee(fe),Ee(We),Ee(fe),Ee(Re),Ee(We);const Le=i.length/3,nt=w.generateSideWallUV(s,i,Le-6,Le-3,Le-2,Le-1);Be(nt[0]),Be(nt[1]),Be(nt[3]),Be(nt[1]),Be(nt[2]),Be(nt[3])}function Ee(ye){i.push(l[ye*3+0]),i.push(l[ye*3+1]),i.push(l[ye*3+2])}function Be(ye){r.push(ye.x),r.push(ye.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,s=this.parameters.options;return M_e(t,s,e)}static fromJSON(e,t){const s=[];for(let r=0,o=e.shapes.length;r<o;r++){const a=t[e.shapes[r]];s.push(a)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new vA[i.type]().fromJSON(i)),new V0(s,e.options)}}const E_e={generateTopUV:function(n,e,t,s,i){const r=e[t*3],o=e[t*3+1],a=e[s*3],l=e[s*3+1],c=e[i*3],u=e[i*3+1];return[new Ae(r,o),new Ae(a,l),new Ae(c,u)]},generateSideWallUV:function(n,e,t,s,i,r){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[s*3],u=e[s*3+1],h=e[s*3+2],d=e[i*3],f=e[i*3+1],m=e[i*3+2],x=e[r*3],y=e[r*3+1],v=e[r*3+2];return Math.abs(a-u)<Math.abs(o-c)?[new Ae(o,1-l),new Ae(c,1-h),new Ae(d,1-m),new Ae(x,1-v)]:[new Ae(a,1-l),new Ae(u,1-h),new Ae(f,1-m),new Ae(y,1-v)]}};function M_e(n,e,t){if(t.shapes=[],Array.isArray(n))for(let s=0,i=n.length;s<i;s++){const r=n[s];t.shapes.push(r.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class W0 extends Il{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,i=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,r,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new W0(e.radius,e.detail)}}class qf extends Il{constructor(e=1,t=0){const s=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(s,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new qf(e.radius,e.detail)}}class G0 extends Bt{constructor(e=.5,t=1,s=8,i=1,r=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:s,phiSegments:i,thetaStart:r,thetaLength:o},s=Math.max(3,s),i=Math.max(1,i);const a=[],l=[],c=[],u=[];let h=e;const d=(t-e)/i,f=new G,m=new Ae;for(let x=0;x<=i;x++){for(let y=0;y<=s;y++){const v=r+y/s*o;f.x=h*Math.cos(v),f.y=h*Math.sin(v),l.push(f.x,f.y,f.z),c.push(0,0,1),m.x=(f.x/t+1)/2,m.y=(f.y/t+1)/2,u.push(m.x,m.y)}h+=d}for(let x=0;x<i;x++){const y=x*(s+1);for(let v=0;v<s;v++){const w=v+y,b=w,S=w+s+1,C=w+s+2,E=w+1;a.push(b,S,E),a.push(S,C,E)}}this.setIndex(a),this.setAttribute("position",new ut(l,3)),this.setAttribute("normal",new ut(c,3)),this.setAttribute("uv",new ut(u,2))}static fromJSON(e){return new G0(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class H0 extends Bt{constructor(e=new Xu([new Ae(0,.5),new Ae(-.5,-.5),new Ae(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const s=[],i=[],r=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(s),this.setAttribute("position",new ut(i,3)),this.setAttribute("normal",new ut(r,3)),this.setAttribute("uv",new ut(o,2));function c(u){const h=i.length/3,d=u.extractPoints(t);let f=d.shape;const m=d.holes;Ea.isClockWise(f)===!1&&(f=f.reverse());for(let y=0,v=m.length;y<v;y++){const w=m[y];Ea.isClockWise(w)===!0&&(m[y]=w.reverse())}const x=Ea.triangulateShape(f,m);for(let y=0,v=m.length;y<v;y++){const w=m[y];f=f.concat(w)}for(let y=0,v=f.length;y<v;y++){const w=f[y];i.push(w.x,w.y,0),r.push(0,0,1),o.push(w.x,w.y)}for(let y=0,v=x.length;y<v;y++){const w=x[y],b=w[0]+h,S=w[1]+h,C=w[2]+h;s.push(b,S,C),l+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return k_e(t,e)}static fromJSON(e,t){const s=[];for(let i=0,r=e.shapes.length;i<r;i++){const o=t[e.shapes[i]];s.push(o)}return new H0(s,e.curveSegments)}}function k_e(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,s=n.length;t<s;t++){const i=n[t];e.shapes.push(i.uuid)}else e.shapes.push(n.uuid);return e}class Kf extends Bt{constructor(e=1,t=32,s=16,i=0,r=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:s,phiStart:i,phiLength:r,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),s=Math.max(2,Math.floor(s));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new G,d=new G,f=[],m=[],x=[],y=[];for(let v=0;v<=s;v++){const w=[],b=v/s;let S=0;v==0&&o==0?S=.5/t:v==s&&l==Math.PI&&(S=-.5/t);for(let C=0;C<=t;C++){const E=C/t;h.x=-e*Math.cos(i+E*r)*Math.sin(o+b*a),h.y=e*Math.cos(o+b*a),h.z=e*Math.sin(i+E*r)*Math.sin(o+b*a),m.push(h.x,h.y,h.z),d.copy(h).normalize(),x.push(d.x,d.y,d.z),y.push(E+S,1-b),w.push(c++)}u.push(w)}for(let v=0;v<s;v++)for(let w=0;w<t;w++){const b=u[v][w+1],S=u[v][w],C=u[v+1][w],E=u[v+1][w+1];(v!==0||o>0)&&f.push(b,S,E),(v!==s-1||l<Math.PI)&&f.push(S,C,E)}this.setIndex(f),this.setAttribute("position",new ut(m,3)),this.setAttribute("normal",new ut(x,3)),this.setAttribute("uv",new ut(y,2))}static fromJSON(e){return new Kf(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class X0 extends Il{constructor(e=1,t=0){const s=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(s,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new X0(e.radius,e.detail)}}class j0 extends Bt{constructor(e=1,t=.4,s=8,i=6,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:s,tubularSegments:i,arc:r},s=Math.floor(s),i=Math.floor(i);const o=[],a=[],l=[],c=[],u=new G,h=new G,d=new G;for(let f=0;f<=s;f++)for(let m=0;m<=i;m++){const x=m/i*r,y=f/s*Math.PI*2;h.x=(e+t*Math.cos(y))*Math.cos(x),h.y=(e+t*Math.cos(y))*Math.sin(x),h.z=t*Math.sin(y),a.push(h.x,h.y,h.z),u.x=e*Math.cos(x),u.y=e*Math.sin(x),d.subVectors(h,u).normalize(),l.push(d.x,d.y,d.z),c.push(m/i),c.push(f/s)}for(let f=1;f<=s;f++)for(let m=1;m<=i;m++){const x=(i+1)*f+m-1,y=(i+1)*(f-1)+m-1,v=(i+1)*(f-1)+m,w=(i+1)*f+m;o.push(x,y,w),o.push(y,v,w)}this.setIndex(o),this.setAttribute("position",new ut(a,3)),this.setAttribute("normal",new ut(l,3)),this.setAttribute("uv",new ut(c,2))}static fromJSON(e){return new j0(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class q0 extends Bt{constructor(e=1,t=.4,s=64,i=8,r=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:s,radialSegments:i,p:r,q:o},s=Math.floor(s),i=Math.floor(i);const a=[],l=[],c=[],u=[],h=new G,d=new G,f=new G,m=new G,x=new G,y=new G,v=new G;for(let b=0;b<=s;++b){const S=b/s*r*Math.PI*2;w(S,r,o,e,f),w(S+.01,r,o,e,m),y.subVectors(m,f),v.addVectors(m,f),x.crossVectors(y,v),v.crossVectors(x,y),x.normalize(),v.normalize();for(let C=0;C<=i;++C){const E=C/i*Math.PI*2,k=-t*Math.cos(E),I=t*Math.sin(E);h.x=f.x+(k*v.x+I*x.x),h.y=f.y+(k*v.y+I*x.y),h.z=f.z+(k*v.z+I*x.z),l.push(h.x,h.y,h.z),d.subVectors(h,f).normalize(),c.push(d.x,d.y,d.z),u.push(b/s),u.push(C/i)}}for(let b=1;b<=s;b++)for(let S=1;S<=i;S++){const C=(i+1)*(b-1)+(S-1),E=(i+1)*b+(S-1),k=(i+1)*b+S,I=(i+1)*(b-1)+S;a.push(C,E,I),a.push(E,k,I)}this.setIndex(a),this.setAttribute("position",new ut(l,3)),this.setAttribute("normal",new ut(c,3)),this.setAttribute("uv",new ut(u,2));function w(b,S,C,E,k){const I=Math.cos(b),A=Math.sin(b),N=C/S*b,L=Math.cos(N);k.x=E*(2+L)*.5*I,k.y=E*(2+L)*A*.5,k.z=E*Math.sin(N)*.5}}static fromJSON(e){return new q0(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class K0 extends Bt{constructor(e=new xA(new G(-1,-1,0),new G(-1,1,0),new G(1,1,0)),t=64,s=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:s,radialSegments:i,closed:r};const o=e.computeFrenetFrames(t,r);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new G,l=new G,c=new Ae;let u=new G;const h=[],d=[],f=[],m=[];x(),this.setIndex(m),this.setAttribute("position",new ut(h,3)),this.setAttribute("normal",new ut(d,3)),this.setAttribute("uv",new ut(f,2));function x(){for(let b=0;b<t;b++)y(b);y(r===!1?t:0),w(),v()}function y(b){u=e.getPointAt(b/t,u);const S=o.normals[b],C=o.binormals[b];for(let E=0;E<=i;E++){const k=E/i*Math.PI*2,I=Math.sin(k),A=-Math.cos(k);l.x=A*S.x+I*C.x,l.y=A*S.y+I*C.y,l.z=A*S.z+I*C.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=u.x+s*l.x,a.y=u.y+s*l.y,a.z=u.z+s*l.z,h.push(a.x,a.y,a.z)}}function v(){for(let b=1;b<=t;b++)for(let S=1;S<=i;S++){const C=(i+1)*(b-1)+(S-1),E=(i+1)*b+(S-1),k=(i+1)*b+S,I=(i+1)*(b-1)+S;m.push(C,E,I),m.push(E,k,I)}}function w(){for(let b=0;b<=t;b++)for(let S=0;S<=i;S++)c.x=b/t,c.y=S/i,f.push(c.x,c.y)}}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new K0(new vA[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class wA extends Bt{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],s=new Set,i=new G,r=new G;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],d=h.start,f=h.count;for(let m=d,x=d+f;m<x;m+=3)for(let y=0;y<3;y++){const v=a.getX(m+y),w=a.getX(m+(y+1)%3);i.fromBufferAttribute(o,v),r.fromBufferAttribute(o,w),uP(i,r,s)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c,h=3*a+(c+1)%3;i.fromBufferAttribute(o,u),r.fromBufferAttribute(o,h),uP(i,r,s)===!0&&(t.push(i.x,i.y,i.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new ut(t,3))}}}function uP(n,e,t){const s=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(s)===!0||t.has(i)===!0?!1:(t.add(s),t.add(i),!0)}var hP=Object.freeze({__proto__:null,BoxGeometry:Tl,CapsuleGeometry:O0,CircleGeometry:z0,ConeGeometry:B0,CylinderGeometry:Rh,DodecahedronGeometry:U0,EdgesGeometry:c5,ExtrudeGeometry:V0,IcosahedronGeometry:W0,LatheGeometry:jf,OctahedronGeometry:qf,PlaneGeometry:Hf,PolyhedronGeometry:Il,RingGeometry:G0,ShapeGeometry:H0,SphereGeometry:Kf,TetrahedronGeometry:X0,TorusGeometry:j0,TorusKnotGeometry:q0,TubeGeometry:K0,WireframeGeometry:wA});class f5 extends li{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Je(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class p5 extends jo{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class bA extends li{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Je(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Je(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wc,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class m5 extends bA{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ae(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return hs(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Je(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Je(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Je(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class g5 extends li{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Je(16777215),this.specular=new Je(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Je(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wc,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=D0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class x5 extends li{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Je(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Je(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wc,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class y5 extends li{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wc,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class v5 extends li{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Je(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Je(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wc,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=D0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class w5 extends li{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Je(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Wc,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class b5 extends ji{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Qr(n,e,t){return SA(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)}function Lu(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function SA(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function S5(n){function e(i,r){return n[i]-n[r]}const t=n.length,s=new Array(t);for(let i=0;i!==t;++i)s[i]=i;return s.sort(e),s}function rI(n,e,t){const s=n.length,i=new n.constructor(s);for(let r=0,o=0;o!==s;++r){const a=t[r]*e;for(let l=0;l!==e;++l)i[o++]=n[a+l]}return i}function _A(n,e,t,s){let i=1,r=n[0];for(;r!==void 0&&r[s]===void 0;)r=n[i++];if(r===void 0)return;let o=r[s];if(o!==void 0)if(Array.isArray(o))do o=r[s],o!==void 0&&(e.push(r.time),t.push.apply(t,o)),r=n[i++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[s],o!==void 0&&(e.push(r.time),o.toArray(t,t.length)),r=n[i++];while(r!==void 0);else do o=r[s],o!==void 0&&(e.push(r.time),t.push(o)),r=n[i++];while(r!==void 0)}function A_e(n,e,t,s,i=30){const r=n.clone();r.name=e;const o=[];for(let l=0;l<r.tracks.length;++l){const c=r.tracks[l],u=c.getValueSize(),h=[],d=[];for(let f=0;f<c.times.length;++f){const m=c.times[f]*i;if(!(m<t||m>=s)){h.push(c.times[f]);for(let x=0;x<u;++x)d.push(c.values[f*u+x])}}h.length!==0&&(c.times=Lu(h,c.times.constructor),c.values=Lu(d,c.values.constructor),o.push(c))}r.tracks=o;let a=1/0;for(let l=0;l<r.tracks.length;++l)a>r.tracks[l].times[0]&&(a=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*a);return r.resetDuration(),r}function N_e(n,e=0,t=n,s=30){s<=0&&(s=30);const i=t.tracks.length,r=e/s;for(let o=0;o<i;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(v){return v.name===a.name&&v.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const m=a.times.length-1;let x;if(r<=a.times[0]){const v=u,w=h-u;x=Qr(a.values,v,w)}else if(r>=a.times[m]){const v=m*h+u,w=v+h-u;x=Qr(a.values,v,w)}else{const v=a.createInterpolant(),w=u,b=h-u;v.evaluate(r),x=Qr(v.resultBuffer,w,b)}l==="quaternion"&&new _i().fromArray(x).normalize().conjugate().toArray(x);const y=c.times.length;for(let v=0;v<y;++v){const w=v*f+d;if(l==="quaternion")_i.multiplyQuaternionsFlat(c.values,w,x,0,c.values,w);else{const b=f-d*2;for(let S=0;S<b;++S)c.values[w+S]-=x[S]}}}return n.blendMode=Qk,n}var R_e=Object.freeze({__proto__:null,arraySlice:Qr,convertArray:Lu,isTypedArray:SA,getKeyframeOrder:S5,sortedArray:rI,flattenJSON:_A,subclip:A_e,makeClipAdditive:N_e});class Y0{constructor(e,t,s,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(s),this.sampleValues=t,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let s=this._cachedIndex,i=t[s],r=t[s-1];e:{t:{let o;n:{s:if(!(e<i)){for(let a=s+2;;){if(i===void 0){if(e<r)break s;return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===a)break;if(r=i,i=t[++s],e<i)break t}o=t.length;break n}if(!(e>=r)){const a=t[1];e<a&&(s=2,r=a);for(let l=s-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===l)break;if(i=r,r=t[--s-1],e>=r)break t}o=s,s=0;break n}break e}for(;s<o;){const a=s+o>>>1;e<t[a]?o=a:s=a+1}if(i=t[s],r=t[s-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,r,i)}return this.interpolate_(s,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=e*i;for(let o=0;o!==i;++o)t[o]=s[r+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class _5 extends Y0{constructor(e,t,s,i){super(e,t,s,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Nu,endingEnd:Nu}}intervalChanged_(e,t,s){const i=this.parameterPositions;let r=e-2,o=e+1,a=i[r],l=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case Ru:r=e,a=2*t-s;break;case qm:r=i.length-2,a=t+i[r]-i[r+1];break;default:r=e,a=s}if(l===void 0)switch(this.getSettings_().endingEnd){case Ru:o=e,l=2*s-t;break;case qm:o=1,l=s+i[1]-i[0];break;default:o=e-1,l=t}const c=(s-t)*.5,u=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-s),this._offsetPrev=r*u,this._offsetNext=o*u}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,f=this._weightNext,m=(s-t)/(i-t),x=m*m,y=x*m,v=-d*y+2*d*x-d*m,w=(1+d)*y+(-1.5-2*d)*x+(-.5+d)*m+1,b=(-1-f)*y+(1.5+f)*x+.5*m,S=f*y-f*x;for(let C=0;C!==a;++C)r[C]=v*o[u+C]+w*o[c+C]+b*o[l+C]+S*o[h+C];return r}}class CA extends Y0{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=(s-t)/(i-t),h=1-u;for(let d=0;d!==a;++d)r[d]=o[c+d]*h+o[l+d]*u;return r}}class C5 extends Y0{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Zo{constructor(e,t,s,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Lu(t,this.TimeBufferType),this.values=Lu(s,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let s;if(t.toJSON!==this.toJSON)s=t.toJSON(e);else{s={name:e.name,times:Lu(e.times,Array),values:Lu(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(s.interpolation=i)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new C5(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new CA(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new _5(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Xm:t=this.InterpolantFactoryMethodDiscrete;break;case jm:t=this.InterpolantFactoryMethodLinear;break;case Pv:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Xm;case this.InterpolantFactoryMethodLinear:return jm;case this.InterpolantFactoryMethodSmooth:return Pv}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]*=e}return this}trim(e,t){const s=this.times,i=s.length;let r=0,o=i-1;for(;r!==i&&s[r]<e;)++r;for(;o!==-1&&s[o]>t;)--o;if(++o,r!==0||o!==i){r>=o&&(o=Math.max(o,1),r=o-1);const a=this.getValueSize();this.times=Qr(s,r,o),this.values=Qr(this.values,r*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,i=this.values,r=s.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==r;a++){const l=s[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(i!==void 0&&SA(i))for(let a=0,l=i.length;a!==l;++a){const c=i[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=Qr(this.times),t=Qr(this.values),s=this.getValueSize(),i=this.getInterpolation()===Pv,r=e.length-1;let o=1;for(let a=1;a<r;++a){let l=!1;const c=e[a],u=e[a+1];if(c!==u&&(a!==1||c!==e[0]))if(i)l=!0;else{const h=a*s,d=h-s,f=h+s;for(let m=0;m!==s;++m){const x=t[h+m];if(x!==t[d+m]||x!==t[f+m]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*s,d=o*s;for(let f=0;f!==s;++f)t[d+f]=t[h+f]}++o}}if(r>0){e[o]=e[r];for(let a=r*s,l=o*s,c=0;c!==s;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=Qr(e,0,o),this.values=Qr(t,0,o*s)):(this.times=e,this.values=t),this}clone(){const e=Qr(this.times,0),t=Qr(this.values,0),s=this.constructor,i=new s(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}Zo.prototype.TimeBufferType=Float32Array;Zo.prototype.ValueBufferType=Float32Array;Zo.prototype.DefaultInterpolation=jm;class Dh extends Zo{}Dh.prototype.ValueTypeName="bool";Dh.prototype.ValueBufferType=Array;Dh.prototype.DefaultInterpolation=Xm;Dh.prototype.InterpolantFactoryMethodLinear=void 0;Dh.prototype.InterpolantFactoryMethodSmooth=void 0;class TA extends Zo{}TA.prototype.ValueTypeName="color";class ng extends Zo{}ng.prototype.ValueTypeName="number";class T5 extends Y0{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(s-t)/(i-t);let c=e*a;for(let u=c+a;c!==u;c+=4)_i.slerpFlat(r,0,o,c-a,o,c,l);return r}}class Yf extends Zo{InterpolantFactoryMethodLinear(e){return new T5(this.times,this.values,this.getValueSize(),e)}}Yf.prototype.ValueTypeName="quaternion";Yf.prototype.DefaultInterpolation=jm;Yf.prototype.InterpolantFactoryMethodSmooth=void 0;class Lh extends Zo{}Lh.prototype.ValueTypeName="string";Lh.prototype.ValueBufferType=Array;Lh.prototype.DefaultInterpolation=Xm;Lh.prototype.InterpolantFactoryMethodLinear=void 0;Lh.prototype.InterpolantFactoryMethodSmooth=void 0;class sg extends Zo{}sg.prototype.ValueTypeName="vector";class ig{constructor(e,t=-1,s,i=Ub){this.name=e,this.tracks=s,this.duration=t,this.blendMode=i,this.uuid=Mr(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],s=e.tracks,i=1/(e.fps||1);for(let o=0,a=s.length;o!==a;++o)t.push(L_e(s[o]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],s=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,o=s.length;r!==o;++r)t.push(Zo.toJSON(s[r]));return i}static CreateFromMorphTargetSequence(e,t,s,i){const r=t.length,o=[];for(let a=0;a<r;a++){let l=[],c=[];l.push((a+r-1)%r,a,(a+1)%r),c.push(0,1,0);const u=S5(l);l=rI(l,1,u),c=rI(c,1,u),!i&&l[0]===0&&(l.push(r),c.push(c[0])),o.push(new ng(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/s))}return new this(e,-1,o)}static findByName(e,t){let s=e;if(!Array.isArray(e)){const i=e;s=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<s.length;i++)if(s[i].name===t)return s[i];return null}static CreateClipsFromMorphTargetSequences(e,t,s){const i={},r=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],u=c.name.match(r);if(u&&u.length>1){const h=u[1];let d=i[h];d||(i[h]=d=[]),d.push(c)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],t,s));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(h,d,f,m,x){if(f.length!==0){const y=[],v=[];_A(f,y,v,m),y.length!==0&&x.push(new h(d,y,v))}},i=[],r=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let m;for(m=0;m<d.length;m++)if(d[m].morphTargets)for(let x=0;x<d[m].morphTargets.length;x++)f[d[m].morphTargets[x]]=-1;for(const x in f){const y=[],v=[];for(let w=0;w!==d[m].morphTargets.length;++w){const b=d[m];y.push(b.time),v.push(b.morphTarget===x?1:0)}i.push(new ng(".morphTargetInfluence["+x+"]",y,v))}l=f.length*o}else{const f=".bones["+t[h].name+"]";s(sg,f+".position",d,"pos",i),s(Yf,f+".quaternion",d,"rot",i),s(sg,f+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,a)}resetDuration(){const e=this.tracks;let t=0;for(let s=0,i=e.length;s!==i;++s){const r=this.tracks[s];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function D_e(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ng;case"vector":case"vector2":case"vector3":case"vector4":return sg;case"color":return TA;case"quaternion":return Yf;case"bool":case"boolean":return Dh;case"string":return Lh}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function L_e(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=D_e(n.type);if(n.times===void 0){const t=[],s=[];_A(n.keys,t,s,"value"),n.times=t,n.values=s}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const gh={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class IA{constructor(e,t,s){const i=this;let r=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this.itemStart=function(u){a++,r===!1&&i.onStart!==void 0&&i.onStart(u,o,a),r=!0},this.itemEnd=function(u){o++,i.onProgress!==void 0&&i.onProgress(u,o,a),o===a&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const f=c[h],m=c[h+1];if(f.global&&(f.lastIndex=0),f.test(u))return m}return null}}}const I5=new IA;class $r{constructor(e){this.manager=e!==void 0?e:I5,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(i,r){s.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const Ka={};class P_e extends Error{constructor(e,t){super(e),this.response=t}}class xl extends $r{constructor(e){super(e)}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=gh.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(Ka[e]!==void 0){Ka[e].push({onLoad:t,onProgress:s,onError:i});return}Ka[e]=[],Ka[e].push({onLoad:t,onProgress:s,onError:i});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const u=Ka[e],h=c.body.getReader(),d=c.headers.get("Content-Length")||c.headers.get("X-File-Size"),f=d?parseInt(d):0,m=f!==0;let x=0;const y=new ReadableStream({start(v){w();function w(){h.read().then(({done:b,value:S})=>{if(b)v.close();else{x+=S.byteLength;const C=new ProgressEvent("progress",{lengthComputable:m,loaded:x,total:f});for(let E=0,k=u.length;E<k;E++){const I=u[E];I.onProgress&&I.onProgress(C)}v.enqueue(S),w()}})}}});return new Response(y)}else throw new P_e(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,a));case"json":return c.json();default:if(a===void 0)return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),d=h&&h[1]?h[1].toLowerCase():void 0,f=new TextDecoder(d);return c.arrayBuffer().then(m=>f.decode(m))}}}).then(c=>{gh.add(e,c);const u=Ka[e];delete Ka[e];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onLoad&&f.onLoad(c)}}).catch(c=>{const u=Ka[e];if(u===void 0)throw this.manager.itemError(e),c;delete Ka[e];for(let h=0,d=u.length;h<d;h++){const f=u[h];f.onError&&f.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class $_e extends $r{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new xl(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},s,i)}parse(e){const t=[];for(let s=0;s<e.length;s++){const i=ig.parse(e[s]);t.push(i)}return t}}class F_e extends $r{constructor(e){super(e)}load(e,t,s,i){const r=this,o=[],a=new fA,l=new xl(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(r.withCredentials);let c=0;function u(h){l.load(e[h],function(d){const f=r.parse(d,!0);o[h]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},c+=1,c===6&&(f.mipmapCount===1&&(a.minFilter=us),a.image=o,a.format=f.format,a.needsUpdate=!0,t&&t(a))},s,i)}if(Array.isArray(e))for(let h=0,d=e.length;h<d;++h)u(h);else l.load(e,function(h){const d=r.parse(h,!0);if(d.isCubemap){const f=d.mipmaps.length/d.mipmapCount;for(let m=0;m<f;m++){o[m]={mipmaps:[]};for(let x=0;x<d.mipmapCount;x++)o[m].mipmaps.push(d.mipmaps[m*d.mipmapCount+x]),o[m].format=d.format,o[m].width=d.width,o[m].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=us),a.format=d.format,a.needsUpdate=!0,t&&t(a)},s,i);return a}}class rg extends $r{constructor(e){super(e)}load(e,t,s,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=gh.get(e);if(o!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const a=Zm("img");function l(){u(),gh.add(e,this),t&&t(this),r.manager.itemEnd(e)}function c(h){u(),i&&i(h),r.manager.itemError(e),r.manager.itemEnd(e)}function u(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(e),a.src=e,a}}class O_e extends $r{constructor(e){super(e)}load(e,t,s,i){const r=new F0,o=new rg(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(e[c],function(u){r.images[c]=u,a++,a===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return r}}class z_e extends $r{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new Kd,a=new xl(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(r.withCredentials),a.load(e,function(l){const c=r.parse(l);!c||(c.image!==void 0?o.image=c.image:c.data!==void 0&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=c.wrapS!==void 0?c.wrapS:Si,o.wrapT=c.wrapT!==void 0?c.wrapT:Si,o.magFilter=c.magFilter!==void 0?c.magFilter:us,o.minFilter=c.minFilter!==void 0?c.minFilter:us,o.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.encoding!==void 0&&(o.encoding=c.encoding),c.flipY!==void 0&&(o.flipY=c.flipY),c.format!==void 0&&(o.format=c.format),c.type!==void 0&&(o.type=c.type),c.mipmaps!==void 0&&(o.mipmaps=c.mipmaps,o.minFilter=Nh),c.mipmapCount===1&&(o.minFilter=us),c.generateMipmaps!==void 0&&(o.generateMipmaps=c.generateMipmaps),o.needsUpdate=!0,t&&t(o,c))},s,i),o}}class B_e extends $r{constructor(e){super(e)}load(e,t,s,i){const r=new ns,o=new rg(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){r.image=a,r.needsUpdate=!0,t!==void 0&&t(r)},s,i),r}}class Gc extends fn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Je(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class E5 extends Gc{constructor(e,t,s){super(e,s),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(fn.DefaultUp),this.updateMatrix(),this.groundColor=new Je(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const NC=new kt,dP=new G,fP=new G;class EA{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ae(512,512),this.map=null,this.mapPass=null,this.matrix=new kt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Gb,this._frameExtents=new Ae(1,1),this._viewportCount=1,this._viewports=[new rn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;dP.setFromMatrixPosition(e.matrixWorld),t.position.copy(dP),fP.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(fP),t.updateMatrixWorld(),NC.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(NC),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(NC)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class U_e extends EA{constructor(){super(new Un(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,s=Ym*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(s!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=s,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class M5 extends Gc{constructor(e,t,s=0,i=Math.PI/3,r=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(fn.DefaultUp),this.updateMatrix(),this.target=new fn,this.distance=s,this.angle=i,this.penumbra=r,this.decay=o,this.map=null,this.shadow=new U_e}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const pP=new kt,$p=new G,RC=new G;class V_e extends EA{constructor(){super(new Un(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ae(4,2),this._viewportCount=6,this._viewports=[new rn(2,1,1,1),new rn(0,1,1,1),new rn(3,1,1,1),new rn(1,1,1,1),new rn(3,0,1,1),new rn(1,0,1,1)],this._cubeDirections=[new G(1,0,0),new G(-1,0,0),new G(0,0,1),new G(0,0,-1),new G(0,1,0),new G(0,-1,0)],this._cubeUps=[new G(0,1,0),new G(0,1,0),new G(0,1,0),new G(0,1,0),new G(0,0,1),new G(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,i=this.matrix,r=e.distance||s.far;r!==s.far&&(s.far=r,s.updateProjectionMatrix()),$p.setFromMatrixPosition(e.matrixWorld),s.position.copy($p),RC.copy(s.position),RC.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(RC),s.updateMatrixWorld(),i.makeTranslation(-$p.x,-$p.y,-$p.z),pP.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(pP)}}class k5 extends Gc{constructor(e,t,s=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=i,this.shadow=new V_e}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class W_e extends EA{constructor(){super(new xc(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class A5 extends Gc{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(fn.DefaultUp),this.updateMatrix(),this.target=new fn,this.shadow=new W_e}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class N5 extends Gc{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class R5 extends Gc{constructor(e,t,s=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=s,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class D5{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new G)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const s=e.x,i=e.y,r=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*i),t.addScaledVector(o[2],.488603*r),t.addScaledVector(o[3],.488603*s),t.addScaledVector(o[4],1.092548*(s*i)),t.addScaledVector(o[5],1.092548*(i*r)),t.addScaledVector(o[6],.315392*(3*r*r-1)),t.addScaledVector(o[7],1.092548*(s*r)),t.addScaledVector(o[8],.546274*(s*s-i*i)),t}getIrradianceAt(e,t){const s=e.x,i=e.y,r=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*i),t.addScaledVector(o[2],2*.511664*r),t.addScaledVector(o[3],2*.511664*s),t.addScaledVector(o[4],2*.429043*s*i),t.addScaledVector(o[5],2*.429043*i*r),t.addScaledVector(o[6],.743125*r*r-.247708),t.addScaledVector(o[7],2*.429043*s*r),t.addScaledVector(o[8],.429043*(s*s-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(e.coefficients[s],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let s=0;s<9;s++)this.coefficients[s].lerp(e.coefficients[s],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const s=this.coefficients;for(let i=0;i<9;i++)s[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const s=e.x,i=e.y,r=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*r,t[3]=.488603*s,t[4]=1.092548*s*i,t[5]=1.092548*i*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*s*r,t[8]=.546274*(s*s-i*i)}}class Qb extends Gc{constructor(e=new D5,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class eS extends $r{constructor(e){super(e),this.textures={}}load(e,t,s,i){const r=this,o=new xl(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(a){try{t(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},s,i)}parse(e){const t=this.textures;function s(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const i=eS.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new Je().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const o=e.uniforms[r];switch(i.uniforms[r]={},o.type){case"t":i.uniforms[r].value=s(o.value);break;case"c":i.uniforms[r].value=new Je().setHex(o.value);break;case"v2":i.uniforms[r].value=new Ae().fromArray(o.value);break;case"v3":i.uniforms[r].value=new G().fromArray(o.value);break;case"v4":i.uniforms[r].value=new rn().fromArray(o.value);break;case"m3":i.uniforms[r].value=new zi().fromArray(o.value);break;case"m4":i.uniforms[r].value=new kt().fromArray(o.value);break;default:i.uniforms[r].value=o.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=s(e.map)),e.matcap!==void 0&&(i.matcap=s(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=s(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=s(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=s(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new Ae().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=s(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=s(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=s(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=s(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=s(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=s(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=s(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=s(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=s(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=s(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=s(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=s(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=s(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=s(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Ae().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=s(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=s(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=s(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=s(e.thicknessMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=s(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=s(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const t={ShadowMaterial:f5,SpriteMaterial:uA,RawShaderMaterial:p5,ShaderMaterial:jo,PointsMaterial:dA,MeshPhysicalMaterial:m5,MeshStandardMaterial:bA,MeshPhongMaterial:g5,MeshToonMaterial:x5,MeshNormalMaterial:y5,MeshLambertMaterial:v5,MeshDepthMaterial:oA,MeshDistanceMaterial:aA,MeshBasicMaterial:Cl,MeshMatcapMaterial:w5,LineDashedMaterial:b5,LineBasicMaterial:ji,Material:li};return new t[e]}}class oI{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class MA extends Bt{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class L5 extends $r{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new xl(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(a){try{t(r.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},s,i)}parse(e){const t={},s={};function i(f,m){if(t[m]!==void 0)return t[m];const y=f.interleavedBuffers[m],v=r(f,y.buffer),w=Ld(y.type,v),b=new qb(w,y.stride);return b.uuid=y.uuid,t[m]=b,b}function r(f,m){if(s[m]!==void 0)return s[m];const y=f.arrayBuffers[m],v=new Uint32Array(y).buffer;return s[m]=v,v}const o=e.isInstancedBufferGeometry?new MA:new Bt,a=e.data.index;if(a!==void 0){const f=Ld(a.type,a.array);o.setIndex(new Cn(f,1))}const l=e.data.attributes;for(const f in l){const m=l[f];let x;if(m.isInterleavedBufferAttribute){const y=i(e.data,m.data);x=new Cr(y,m.itemSize,m.offset,m.normalized)}else{const y=Ld(m.type,m.array),v=m.isInstancedBufferAttribute?Sf:Cn;x=new v(y,m.itemSize,m.normalized)}m.name!==void 0&&(x.name=m.name),m.usage!==void 0&&x.setUsage(m.usage),m.updateRange!==void 0&&(x.updateRange.offset=m.updateRange.offset,x.updateRange.count=m.updateRange.count),o.setAttribute(f,x)}const c=e.data.morphAttributes;if(c)for(const f in c){const m=c[f],x=[];for(let y=0,v=m.length;y<v;y++){const w=m[y];let b;if(w.isInterleavedBufferAttribute){const S=i(e.data,w.data);b=new Cr(S,w.itemSize,w.offset,w.normalized)}else{const S=Ld(w.type,w.array);b=new Cn(S,w.itemSize,w.normalized)}w.name!==void 0&&(b.name=w.name),x.push(b)}o.morphAttributes[f]=x}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let f=0,m=h.length;f!==m;++f){const x=h[f];o.addGroup(x.start,x.count,x.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const f=new G;d.center!==void 0&&f.fromArray(d.center),o.boundingSphere=new _l(f,d.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class G_e extends $r{constructor(e){super(e)}load(e,t,s,i){const r=this,o=this.path===""?oI.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new xl(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){i!==void 0&&i(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}r.parse(c,t)},s,i)}async loadAsync(e,t){const s=this,i=this.path===""?oI.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const r=new xl(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const o=await r.loadAsync(e,t),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await s.parseAsync(a)}parse(e,t){const s=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,i),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,r,l,a,s),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let h=!1;for(const d in o)if(o[d].data instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}async parseAsync(e){const t=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,s),r=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,r),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,i,a,o,t),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),l}parseShapes(e){const t={};if(e!==void 0)for(let s=0,i=e.length;s<i;s++){const r=new Xu().fromJSON(e[s]);t[r.uuid]=r}return t}parseSkeletons(e,t){const s={},i={};if(t.traverse(function(r){r.isBone&&(i[r.uuid]=r)}),e!==void 0)for(let r=0,o=e.length;r<o;r++){const a=new Kb().fromJSON(e[r],i);s[a.uuid]=a}return s}parseGeometries(e,t){const s={};if(e!==void 0){const i=new L5;for(let r=0,o=e.length;r<o;r++){let a;const l=e[r];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(l);break;default:l.type in hP?a=hP[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),a.isBufferGeometry===!0&&l.userData!==void 0&&(a.userData=l.userData),s[l.uuid]=a}}return s}parseMaterials(e,t){const s={},i={};if(e!==void 0){const r=new eS;r.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];s[l.uuid]===void 0&&(s[l.uuid]=r.parse(l)),i[l.uuid]=s[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let s=0;s<e.length;s++){const i=e[s],r=ig.parse(i);t[r.uuid]=r}return t}parseImages(e,t){const s=this,i={};let r;function o(l){return s.manager.itemStart(l),r.load(l,function(){s.manager.itemEnd(l)},void 0,function(){s.manager.itemError(l),s.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:s.resourcePath+c;return o(u)}else return l.data?{data:Ld(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new IA(t);r=new rg(l),r.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],d=h.url;if(Array.isArray(d)){const f=[];for(let m=0,x=d.length;m<x;m++){const y=d[m],v=a(y);v!==null&&(v instanceof HTMLImageElement?f.push(v):f.push(new Kd(v.data,v.width,v.height)))}i[h.uuid]=new Du(f)}else{const f=a(h.url);i[h.uuid]=new Du(f)}}}return i}async parseImagesAsync(e){const t=this,s={};let i;async function r(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await i.loadAsync(l)}else return o.data?{data:Ld(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){i=new rg(this.manager),i.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],c=l.url;if(Array.isArray(c)){const u=[];for(let h=0,d=c.length;h<d;h++){const f=c[h],m=await r(f);m!==null&&(m instanceof HTMLImageElement?u.push(m):u.push(new Kd(m.data,m.width,m.height)))}s[l.uuid]=new Du(u)}else{const u=await r(l.url);s[l.uuid]=new Du(u)}}}return s}parseTextures(e,t){function s(r,o){return typeof r=="number"?r:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",r),o[r])}const i={};if(e!==void 0)for(let r=0,o=e.length;r<o;r++){const a=e[r];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=t[a.image],c=l.data;let u;Array.isArray(c)?(u=new F0,c.length===6&&(u.needsUpdate=!0)):(c&&c.data?u=new Kd:u=new ns,c&&(u.needsUpdate=!0)),u.source=l,u.uuid=a.uuid,a.name!==void 0&&(u.name=a.name),a.mapping!==void 0&&(u.mapping=s(a.mapping,H_e)),a.offset!==void 0&&u.offset.fromArray(a.offset),a.repeat!==void 0&&u.repeat.fromArray(a.repeat),a.center!==void 0&&u.center.fromArray(a.center),a.rotation!==void 0&&(u.rotation=a.rotation),a.wrap!==void 0&&(u.wrapS=s(a.wrap[0],mP),u.wrapT=s(a.wrap[1],mP)),a.format!==void 0&&(u.format=a.format),a.type!==void 0&&(u.type=a.type),a.encoding!==void 0&&(u.encoding=a.encoding),a.minFilter!==void 0&&(u.minFilter=s(a.minFilter,gP)),a.magFilter!==void 0&&(u.magFilter=s(a.magFilter,gP)),a.anisotropy!==void 0&&(u.anisotropy=a.anisotropy),a.flipY!==void 0&&(u.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(u.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(u.unpackAlignment=a.unpackAlignment),a.userData!==void 0&&(u.userData=a.userData),i[a.uuid]=u}return i}parseObject(e,t,s,i,r){let o;function a(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const f=[];for(let m=0,x=d.length;m<x;m++){const y=d[m];s[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",y),f.push(s[y])}return f}return s[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),s[d]}}function c(d){return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),i[d]}let u,h;switch(e.type){case"Scene":o=new cA,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new Je(e.background):o.background=c(e.background)),e.environment!==void 0&&(o.environment=c(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new jb(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new Xb(e.fog.color,e.fog.density))),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness);break;case"PerspectiveCamera":o=new Un(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new xc(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new N5(e.color,e.intensity);break;case"DirectionalLight":o=new A5(e.color,e.intensity);break;case"PointLight":o=new k5(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new R5(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new M5(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new E5(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new Qb().fromJSON(e);break;case"SkinnedMesh":u=a(e.geometry),h=l(e.material),o=new e5(u,h),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":u=a(e.geometry),h=l(e.material),o=new js(u,h);break;case"InstancedMesh":u=a(e.geometry),h=l(e.material);const d=e.count,f=e.instanceMatrix,m=e.instanceColor;o=new t5(u,h,d),o.instanceMatrix=new Sf(new Float32Array(f.array),16),m!==void 0&&(o.instanceColor=new Sf(new Float32Array(m.array),m.itemSize));break;case"LOD":o=new QG;break;case"Line":o=new Ac(a(e.geometry),l(e.material));break;case"LineLoop":o=new n5(a(e.geometry),l(e.material));break;case"LineSegments":o=new Da(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new s5(a(e.geometry),l(e.material));break;case"Sprite":o=new JG(l(e.material));break;case"Group":o=new $d;break;case"Bone":o=new hA;break;default:o=new fn}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let f=0;f<d.length;f++)o.add(this.parseObject(d[f],t,s,i,r))}if(e.animations!==void 0){const d=e.animations;for(let f=0;f<d.length;f++){const m=d[f];o.animations.push(r[m])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const d=e.levels;for(let f=0;f<d.length;f++){const m=d[f],x=o.getObjectByProperty("uuid",m.object);x!==void 0&&o.addLevel(x,m.distance,m.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(s){if(s.isSkinnedMesh===!0&&s.skeleton!==void 0){const i=t[s.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",s.skeleton):s.bind(i,s.bindMatrix)}})}}const H_e={UVMapping:Bb,CubeReflectionMapping:Ec,CubeRefractionMapping:Mc,EquirectangularReflectionMapping:Vm,EquirectangularRefractionMapping:Wm,CubeUVReflectionMapping:Wf},mP={RepeatWrapping:Gm,ClampToEdgeWrapping:Si,MirroredRepeatWrapping:Hm},gP={NearestFilter:ws,NearestMipmapNearestFilter:O1,NearestMipmapLinearFilter:z1,LinearFilter:us,LinearMipmapNearestFilter:Zk,LinearMipmapLinearFilter:Nh};class X_e extends $r{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=gh.get(e);if(o!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){gh.add(e,l),t&&t(l),r.manager.itemEnd(e)}).catch(function(l){i&&i(l),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}let iv;class kA{static getContext(){return iv===void 0&&(iv=new(window.AudioContext||window.webkitAudioContext)),iv}static setContext(e){iv=e}}class j_e extends $r{constructor(e){super(e)}load(e,t,s,i){const r=this,o=new xl(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{const l=a.slice(0);kA.getContext().decodeAudioData(l,function(u){t(u)})}catch(l){i?i(l):console.error(l),r.manager.itemError(e)}},s,i)}}class q_e extends Qb{constructor(e,t,s=1){super(void 0,s),this.isHemisphereLightProbe=!0;const i=new Je().set(e),r=new Je().set(t),o=new G(i.r,i.g,i.b),a=new G(r.r,r.g,r.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}}class K_e extends Qb{constructor(e,t=1){super(void 0,t),this.isAmbientLightProbe=!0;const s=new Je().set(e);this.sh.coefficients[0].set(s.r,s.g,s.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const xP=new kt,yP=new kt,au=new kt;class Y_e{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Un,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Un,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,au.copy(e.projectionMatrix);const i=t.eyeSep/2,r=i*t.near/t.focus,o=t.near*Math.tan(Wu*t.fov*.5)/t.zoom;let a,l;yP.elements[12]=-i,xP.elements[12]=i,a=-o*t.aspect+r,l=o*t.aspect+r,au.elements[0]=2*t.near/(l-a),au.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(au),a=-o*t.aspect-r,l=o*t.aspect-r,au.elements[0]=2*t.near/(l-a),au.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(au)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(yP),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(xP)}}class AA{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=vP(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=vP();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function vP(){return(typeof performance>"u"?Date:performance).now()}const lu=new G,wP=new _i,Z_e=new G,cu=new G;class J_e extends fn{constructor(){super(),this.type="AudioListener",this.context=kA.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new AA}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,s=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(lu,wP,Z_e),cu.set(0,0,-1).applyQuaternion(wP),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(lu.x,i),t.positionY.linearRampToValueAtTime(lu.y,i),t.positionZ.linearRampToValueAtTime(lu.z,i),t.forwardX.linearRampToValueAtTime(cu.x,i),t.forwardY.linearRampToValueAtTime(cu.y,i),t.forwardZ.linearRampToValueAtTime(cu.z,i),t.upX.linearRampToValueAtTime(s.x,i),t.upY.linearRampToValueAtTime(s.y,i),t.upZ.linearRampToValueAtTime(s.z,i)}else t.setPosition(lu.x,lu.y,lu.z),t.setOrientation(cu.x,cu.y,cu.z,s.x,s.y,s.z)}}class P5 extends fn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const uu=new G,bP=new _i,Q_e=new G,hu=new G;class eCe extends P5{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,s){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=s,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(uu,bP,Q_e),hu.set(0,0,1).applyQuaternion(bP);const t=this.panner;if(t.positionX){const s=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(uu.x,s),t.positionY.linearRampToValueAtTime(uu.y,s),t.positionZ.linearRampToValueAtTime(uu.z,s),t.orientationX.linearRampToValueAtTime(hu.x,s),t.orientationY.linearRampToValueAtTime(hu.y,s),t.orientationZ.linearRampToValueAtTime(hu.z,s)}else t.setPosition(uu.x,uu.y,uu.z),t.setOrientation(hu.x,hu.y,hu.z)}}class tCe{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let s=0;s<t.length;s++)e+=t[s];return e/t.length}}class $5{constructor(e,t,s){this.binding=e,this.valueSize=s;let i,r,o;switch(t){case"quaternion":i=this._slerp,r=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:i=this._lerp,r=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const s=this.buffer,i=this.valueSize,r=e*i+i;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==i;++a)s[r+a]=s[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(s,r,0,a,i)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,s=this.valueSize,i=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,s),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,s=this.buffer,i=e*t+t,r=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=t*this._origIndex;this._mixBufferRegion(s,i,l,1-r,t)}o>0&&this._mixBufferRegionAdditive(s,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(s[l]!==s[l+t]){a.setValue(s,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,s=this.valueSize,i=s*this._origIndex;e.getValue(t,i);for(let r=s,o=i;r!==o;++r)t[r]=t[i+r%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let s=e;s<t;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[t+s]=this.buffer[e+s]}_select(e,t,s,i,r){if(i>=.5)for(let o=0;o!==r;++o)e[t+o]=e[s+o]}_slerp(e,t,s,i){_i.slerpFlat(e,t,e,t,e,s,i)}_slerpAdditive(e,t,s,i,r){const o=this._workIndex*r;_i.multiplyQuaternionsFlat(e,o,e,t,e,s),_i.slerpFlat(e,t,e,t,e,o,i)}_lerp(e,t,s,i,r){const o=1-i;for(let a=0;a!==r;++a){const l=t+a;e[l]=e[l]*o+e[s+a]*i}}_lerpAdditive(e,t,s,i,r){for(let o=0;o!==r;++o){const a=t+o;e[a]=e[a]+e[s+o]*i}}}const NA="\\[\\]\\.:\\/",nCe=new RegExp("["+NA+"]","g"),RA="[^"+NA+"]",sCe="[^"+NA.replace("\\.","")+"]",iCe=/((?:WC+[\/:])*)/.source.replace("WC",RA),rCe=/(WCOD+)?/.source.replace("WCOD",sCe),oCe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",RA),aCe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",RA),lCe=new RegExp("^"+iCe+rCe+oCe+aCe+"$"),cCe=["material","materials","bones","map"];class uCe{constructor(e,t,s){const i=s||sn.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const s=this._targetGroup.nCachedObjects_,i=this._bindings[s];i!==void 0&&i.getValue(e,t)}setValue(e,t){const s=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=s.length;i!==r;++i)s[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].unbind()}}class sn{constructor(e,t,s){this.path=t,this.parsedPath=s||sn.parseTrackName(t),this.node=sn.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,s){return e&&e.isAnimationObjectGroup?new sn.Composite(e,t,s):new sn(e,t,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(nCe,"")}static parseTrackName(e){const t=lCe.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=s.nodeName&&s.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=s.nodeName.substring(i+1);cCe.indexOf(r)!==-1&&(s.nodeName=s.nodeName.substring(0,i),s.objectName=r)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(t);if(s!==void 0)return s}if(e.children){const s=function(r){for(let o=0;o<r.length;o++){const a=r[o];if(a.name===t||a.uuid===t)return a;const l=s(a.children);if(l)return l}return null},i=s(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)e[t++]=s[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,s=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=sn.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(s){let c=t.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[i];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}sn.Composite=uCe;sn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};sn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};sn.prototype.GetterByBindingType=[sn.prototype._getValue_direct,sn.prototype._getValue_array,sn.prototype._getValue_arrayElement,sn.prototype._getValue_toArray];sn.prototype.SetterByBindingTypeAndVersioning=[[sn.prototype._setValue_direct,sn.prototype._setValue_direct_setNeedsUpdate,sn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[sn.prototype._setValue_array,sn.prototype._setValue_array_setNeedsUpdate,sn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[sn.prototype._setValue_arrayElement,sn.prototype._setValue_arrayElement_setNeedsUpdate,sn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[sn.prototype._setValue_fromArray,sn.prototype._setValue_fromArray_setNeedsUpdate,sn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class hCe{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Mr(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let s=0,i=arguments.length;s!==i;++s)e[arguments[s].uuid]=s;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,s=this._paths,i=this._parsedPaths,r=this._bindings,o=r.length;let a,l=e.length,c=this.nCachedObjects_;for(let u=0,h=arguments.length;u!==h;++u){const d=arguments[u],f=d.uuid;let m=t[f];if(m===void 0){m=l++,t[f]=m,e.push(d);for(let x=0,y=o;x!==y;++x)r[x].push(new sn(d,s[x],i[x]))}else if(m<c){a=e[m];const x=--c,y=e[x];t[y.uuid]=m,e[m]=y,t[f]=x,e[x]=d;for(let v=0,w=o;v!==w;++v){const b=r[v],S=b[x];let C=b[m];b[m]=S,C===void 0&&(C=new sn(d,s[v],i[v])),b[x]=C}}else e[m]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,i=s.length;let r=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=t[c];if(u!==void 0&&u>=r){const h=r++,d=e[h];t[d.uuid]=u,e[u]=d,t[c]=h,e[h]=l;for(let f=0,m=i;f!==m;++f){const x=s[f],y=x[h],v=x[u];x[u]=y,x[h]=v}}}this.nCachedObjects_=r}uncache(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,i=s.length;let r=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const c=arguments[a],u=c.uuid,h=t[u];if(h!==void 0)if(delete t[u],h<r){const d=--r,f=e[d],m=--o,x=e[m];t[f.uuid]=h,e[h]=f,t[x.uuid]=d,e[d]=x,e.pop();for(let y=0,v=i;y!==v;++y){const w=s[y],b=w[d],S=w[m];w[h]=b,w[d]=S,w.pop()}}else{const d=--o,f=e[d];d>0&&(t[f.uuid]=h),e[h]=f,e.pop();for(let m=0,x=i;m!==x;++m){const y=s[m];y[h]=y[d],y.pop()}}}this.nCachedObjects_=r}subscribe_(e,t){const s=this._bindingsIndicesByPath;let i=s[e];const r=this._bindings;if(i!==void 0)return r[i];const o=this._paths,a=this._parsedPaths,l=this._objects,c=l.length,u=this.nCachedObjects_,h=new Array(c);i=r.length,s[e]=i,o.push(e),a.push(t),r.push(h);for(let d=u,f=l.length;d!==f;++d){const m=l[d];h[d]=new sn(m,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,s=t[e];if(s!==void 0){const i=this._paths,r=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],c=e[a];t[c]=s,o[s]=l,o.pop(),r[s]=r[a],r.pop(),i[s]=i[a],i.pop()}}}class dCe{constructor(e,t,s=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=s,this.blendMode=i;const r=t.tracks,o=r.length,a=new Array(o),l={endingStart:Nu,endingEnd:Nu};for(let c=0;c!==o;++c){const u=r[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=AG,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,s){if(e.fadeOut(t),this.fadeIn(t),s){const i=this._clip.duration,r=e._clip.duration,o=r/i,a=i/r;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,s){return e.crossFadeFrom(this,t,s)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,s){const i=this._mixer,r=i.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=r,l[1]=r+s,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,s,i){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const l=(e-r)*s;l<0||s===0?t=0:(this._startTime=null,t=s*l)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case Qk:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case Ub:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(i,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const s=this._weightInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const s=this._timeScaleInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,s=this.loop;let i=this.time+e,r=this._loopCount;const o=s===NG;if(e===0)return r===-1?i:o&&(r&1)===1?t-i:i;if(s===kG){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),i>=t||i<0){const a=Math.floor(i/t);i-=t*a,r+=Math.abs(a);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=i;if(o&&(r&1)===1)return t-i}return i}_setEndings(e,t,s){const i=this._interpolantSettings;s?(i.endingStart=Ru,i.endingEnd=Ru):(e?i.endingStart=this.zeroSlopeAtStart?Ru:Nu:i.endingStart=qm,t?i.endingEnd=this.zeroSlopeAtEnd?Ru:Nu:i.endingEnd=qm)}_scheduleFading(e,t,s){const i=this._mixer,r=i.time;let o=this._weightInterpolant;o===null&&(o=i._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,l[0]=t,a[1]=r+e,l[1]=s,this}}const fCe=new Float32Array(1);class pCe extends Na{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const s=e._localRoot||this._root,i=e._clip.tracks,r=i.length,o=e._propertyBindings,a=e._interpolants,l=s.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==r;++h){const d=i[h],f=d.name;let m=u[f];if(m!==void 0)++m.referenceCount,o[h]=m;else{if(m=o[h],m!==void 0){m._cacheIndex===null&&(++m.referenceCount,this._addInactiveBinding(m,l,f));continue}const x=t&&t._propertyBindings[h].binding.parsedPath;m=new $5(sn.create(s,f,x),d.ValueTypeName,d.getValueSize()),++m.referenceCount,this._addInactiveBinding(m,l,f),o[h]=m}a[h].resultBuffer=m.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const s=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,s)}const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,s){const i=this._actions,r=this._actionsByClip;let o=r[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=i.length,i.push(e),o.actionByRoot[s]=e}_removeInactiveAction(e){const t=this._actions,s=t[t.length-1],i=e._cacheIndex;s._cacheIndex=i,t[i]=s,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,o=this._actionsByClip,a=o[r],l=a.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete o[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,s=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_takeBackAction(e){const t=this._actions,s=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_addInactiveBinding(e,t,s){const i=this._bindingsByRootAndName,r=this._bindings;let o=i[t];o===void 0&&(o={},i[t]=o),o[s]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,s=e.binding,i=s.rootNode.uuid,r=s.path,o=this._bindingsByRootAndName,a=o[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete a[r],Object.keys(a).length===0&&delete o[i]}_lendBinding(e){const t=this._bindings,s=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_takeBackBinding(e){const t=this._bindings,s=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let s=e[t];return s===void 0&&(s=new CA(new Float32Array(2),new Float32Array(2),1,fCe),s.__cacheIndex=t,e[t]=s),s}_takeBackControlInterpolant(e){const t=this._controlInterpolants,s=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=s,t[s]=r}clipAction(e,t,s){const i=t||this._root,r=i.uuid;let o=typeof e=="string"?ig.findByName(i,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let c=null;if(s===void 0&&(o!==null?s=o.blendMode:s=Ub),l!==void 0){const h=l.actionByRoot[r];if(h!==void 0&&h.blendMode===s)return h;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const u=new dCe(this,o,t,s);return this._bindAction(u,c),this._addInactiveAction(u,a,r),u}existingAction(e,t){const s=t||this._root,i=s.uuid,r=typeof e=="string"?ig.findByName(s,e):e,o=r?r.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let s=t-1;s>=0;--s)e[s].stop();return this}update(e){e*=this.timeScale;const t=this._actions,s=this._nActiveActions,i=this.time+=e,r=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==s;++c)t[c]._update(i,e,r,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,s=e.uuid,i=this._actionsByClip,r=i[s];if(r!==void 0){const o=r.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const u=c._cacheIndex,h=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[s]}}uncacheRoot(e){const t=e.uuid,s=this._actionsByClip;for(const o in s){const a=s[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[t];if(r!==void 0)for(const o in r){const a=r[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const s=this.existingAction(e,t);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}class DA{constructor(e){this.value=e}clone(){return new DA(this.value.clone===void 0?this.value:this.value.clone())}}let mCe=0;class gCe extends Na{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:mCe++}),this.name="",this.usage=Km,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let s=0,i=t.length;s<i;s++)this.uniforms.push(t[s].clone());return this}clone(){return new this.constructor().copy(this)}}class V1 extends qb{constructor(e,t,s=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class xCe{constructor(e,t,s,i,r){this.isGLBufferAttribute=!0,this.buffer=e,this.type=t,this.itemSize=s,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class F5{constructor(e,t,s=0,i=1/0){this.ray=new P0(e,t),this.near=s,this.far=i,this.camera=null,this.layers=new Hu,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,s=[]){return aI(e,this,s,t),s.sort(SP),s}intersectObjects(e,t=!0,s=[]){for(let i=0,r=e.length;i<r;i++)aI(e[i],this,s,t);return s.sort(SP),s}}function SP(n,e){return n.distance-e.distance}function aI(n,e,t,s){if(n.layers.test(e.layers)&&n.raycast(e,t),s===!0){const i=n.children;for(let r=0,o=i.length;r<o;r++)aI(i[r],e,t,!0)}}class lI{constructor(e=1,t=0,s=0){return this.radius=e,this.phi=t,this.theta=s,this}set(e,t,s){return this.radius=e,this.phi=t,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+t*t+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(hs(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class yCe{constructor(e=1,t=0,s=0){return this.radius=e,this.theta=t,this.y=s,this}set(e,t,s){return this.radius=e,this.theta=t,this.y=s,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+s*s),this.theta=Math.atan2(e,s),this.y=t,this}clone(){return new this.constructor().copy(this)}}const _P=new Ae;class vCe{constructor(e=new Ae(1/0,1/0),t=new Ae(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=_P.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return _P.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const CP=new G,rv=new G;class O5{constructor(e=new G,t=new G){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){CP.subVectors(e,this.start),rv.subVectors(this.end,this.start);const s=rv.dot(rv);let r=rv.dot(CP)/s;return t&&(r=hs(r,0,1)),r}closestPointToPoint(e,t,s){const i=this.closestPointToPointParameter(e,t);return this.delta(s).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const TP=new G;class wCe extends fn{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const s=new Bt,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}s.setAttribute("position",new ut(i,3));const r=new ji({fog:!1,toneMapped:!1});this.cone=new Da(s,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),TP.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(TP),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Wl=new G,ov=new kt,DC=new kt;class bCe extends Da{constructor(e){const t=z5(e),s=new Bt,i=[],r=[],o=new Je(0,0,1),a=new Je(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(o.r,o.g,o.b),r.push(a.r,a.g,a.b))}s.setAttribute("position",new ut(i,3)),s.setAttribute("color",new ut(r,3));const l=new ji({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,s=this.geometry,i=s.getAttribute("position");DC.copy(this.root.matrixWorld).invert();for(let r=0,o=0;r<t.length;r++){const a=t[r];a.parent&&a.parent.isBone&&(ov.multiplyMatrices(DC,a.matrixWorld),Wl.setFromMatrixPosition(ov),i.setXYZ(o,Wl.x,Wl.y,Wl.z),ov.multiplyMatrices(DC,a.parent.matrixWorld),Wl.setFromMatrixPosition(ov),i.setXYZ(o+1,Wl.x,Wl.y,Wl.z),o+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function z5(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,z5(n.children[t]));return e}class SCe extends js{constructor(e,t,s){const i=new Kf(t,4,2),r=new Cl({wireframe:!0,fog:!1,toneMapped:!1});super(i,r),this.light=e,this.color=s,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _Ce=new G,IP=new Je,EP=new Je;class CCe extends fn{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="HemisphereLightHelper";const i=new qf(t);i.rotateY(Math.PI*.5),this.material=new Cl({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),o=new Float32Array(r.count*3);i.setAttribute("color",new Cn(o,3)),this.add(new js(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");IP.copy(this.light.color),EP.copy(this.light.groundColor);for(let s=0,i=t.count;s<i;s++){const r=s<i/2?IP:EP;t.setXYZ(s,r.r,r.g,r.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(_Ce.setFromMatrixPosition(this.light.matrixWorld).negate())}}class TCe extends Da{constructor(e=10,t=10,s=4473924,i=8947848){s=new Je(s),i=new Je(i);const r=t/2,o=e/t,a=e/2,l=[],c=[];for(let d=0,f=0,m=-a;d<=t;d++,m+=o){l.push(-a,0,m,a,0,m),l.push(m,0,-a,m,0,a);const x=d===r?s:i;x.toArray(c,f),f+=3,x.toArray(c,f),f+=3,x.toArray(c,f),f+=3,x.toArray(c,f),f+=3}const u=new Bt;u.setAttribute("position",new ut(l,3)),u.setAttribute("color",new ut(c,3));const h=new ji({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class ICe extends Da{constructor(e=10,t=16,s=8,i=64,r=4473924,o=8947848){r=new Je(r),o=new Je(o);const a=[],l=[];if(t>1)for(let h=0;h<t;h++){const d=h/t*(Math.PI*2),f=Math.sin(d)*e,m=Math.cos(d)*e;a.push(0,0,0),a.push(f,0,m);const x=h&1?r:o;l.push(x.r,x.g,x.b),l.push(x.r,x.g,x.b)}for(let h=0;h<s;h++){const d=h&1?r:o,f=e-e/s*h;for(let m=0;m<i;m++){let x=m/i*(Math.PI*2),y=Math.sin(x)*f,v=Math.cos(x)*f;a.push(y,0,v),l.push(d.r,d.g,d.b),x=(m+1)/i*(Math.PI*2),y=Math.sin(x)*f,v=Math.cos(x)*f,a.push(y,0,v),l.push(d.r,d.g,d.b)}}const c=new Bt;c.setAttribute("position",new ut(a,3)),c.setAttribute("color",new ut(l,3));const u=new ji({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const MP=new G,av=new G,kP=new G;class ECe extends fn{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new Bt;i.setAttribute("position",new ut([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const r=new ji({fog:!1,toneMapped:!1});this.lightPlane=new Ac(i,r),this.add(this.lightPlane),i=new Bt,i.setAttribute("position",new ut([0,0,0,0,0,1],3)),this.targetLine=new Ac(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),MP.setFromMatrixPosition(this.light.matrixWorld),av.setFromMatrixPosition(this.light.target.matrixWorld),kP.subVectors(av,MP),this.lightPlane.lookAt(av),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(av),this.targetLine.scale.z=kP.length()}}const lv=new G,Jn=new $0;class MCe extends Da{constructor(e){const t=new Bt,s=new ji({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(m,x){l(m),l(x)}function l(m){i.push(0,0,0),r.push(0,0,0),o[m]===void 0&&(o[m]=[]),o[m].push(i.length/3-1)}t.setAttribute("position",new ut(i,3)),t.setAttribute("color",new ut(r,3)),super(t,s),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const c=new Je(16755200),u=new Je(16711680),h=new Je(43775),d=new Je(16777215),f=new Je(3355443);this.setColors(c,u,h,d,f)}setColors(e,t,s,i,r){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,s.r,s.g,s.b),a.setXYZ(33,s.r,s.g,s.b),a.setXYZ(34,s.r,s.g,s.b),a.setXYZ(35,s.r,s.g,s.b),a.setXYZ(36,s.r,s.g,s.b),a.setXYZ(37,s.r,s.g,s.b),a.setXYZ(38,i.r,i.g,i.b),a.setXYZ(39,i.r,i.g,i.b),a.setXYZ(40,r.r,r.g,r.b),a.setXYZ(41,r.r,r.g,r.b),a.setXYZ(42,r.r,r.g,r.b),a.setXYZ(43,r.r,r.g,r.b),a.setXYZ(44,r.r,r.g,r.b),a.setXYZ(45,r.r,r.g,r.b),a.setXYZ(46,r.r,r.g,r.b),a.setXYZ(47,r.r,r.g,r.b),a.setXYZ(48,r.r,r.g,r.b),a.setXYZ(49,r.r,r.g,r.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,s=1,i=1;Jn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),ls("c",t,e,Jn,0,0,-1),ls("t",t,e,Jn,0,0,1),ls("n1",t,e,Jn,-s,-i,-1),ls("n2",t,e,Jn,s,-i,-1),ls("n3",t,e,Jn,-s,i,-1),ls("n4",t,e,Jn,s,i,-1),ls("f1",t,e,Jn,-s,-i,1),ls("f2",t,e,Jn,s,-i,1),ls("f3",t,e,Jn,-s,i,1),ls("f4",t,e,Jn,s,i,1),ls("u1",t,e,Jn,s*.7,i*1.1,-1),ls("u2",t,e,Jn,-s*.7,i*1.1,-1),ls("u3",t,e,Jn,0,i*2,-1),ls("cf1",t,e,Jn,-s,0,1),ls("cf2",t,e,Jn,s,0,1),ls("cf3",t,e,Jn,0,-i,1),ls("cf4",t,e,Jn,0,i,1),ls("cn1",t,e,Jn,-s,0,-1),ls("cn2",t,e,Jn,s,0,-1),ls("cn3",t,e,Jn,0,-i,-1),ls("cn4",t,e,Jn,0,i,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function ls(n,e,t,s,i,r,o){lv.set(i,r,o).unproject(s);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],lv.x,lv.y,lv.z)}}const cv=new Ra;class kCe extends Da{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(8*3),r=new Bt;r.setIndex(new Cn(s,1)),r.setAttribute("position",new Cn(i,3)),super(r,new ji({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&cv.setFromObject(this.object),cv.isEmpty())return;const t=cv.min,s=cv.max,i=this.geometry.attributes.position,r=i.array;r[0]=s.x,r[1]=s.y,r[2]=s.z,r[3]=t.x,r[4]=s.y,r[5]=s.z,r[6]=t.x,r[7]=t.y,r[8]=s.z,r[9]=s.x,r[10]=t.y,r[11]=s.z,r[12]=s.x,r[13]=s.y,r[14]=t.z,r[15]=t.x,r[16]=s.y,r[17]=t.z,r[18]=t.x,r[19]=t.y,r[20]=t.z,r[21]=s.x,r[22]=t.y,r[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class ACe extends Da{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new Bt;r.setIndex(new Cn(s,1)),r.setAttribute("position",new ut(i,3)),super(r,new ji({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class NCe extends Ac{constructor(e,t=1,s=16776960){const i=s,r=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new Bt;o.setAttribute("position",new ut(r,3)),o.computeBoundingSphere(),super(o,new ji({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new Bt;l.setAttribute("position",new ut(a,3)),l.computeBoundingSphere(),this.add(new js(l,new Cl({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const AP=new G;let uv,LC;class RCe extends fn{constructor(e=new G(0,0,1),t=new G(0,0,0),s=1,i=16776960,r=s*.2,o=r*.2){super(),this.type="ArrowHelper",uv===void 0&&(uv=new Bt,uv.setAttribute("position",new ut([0,0,0,0,1,0],3)),LC=new Rh(0,.5,1,5,1),LC.translate(0,-.5,0)),this.position.copy(t),this.line=new Ac(uv,new ji({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new js(LC,new Cl({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(s,r,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{AP.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(AP,t)}}setLength(e,t=e*.2,s=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(s,t,s),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class DCe extends Da{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Bt;i.setAttribute("position",new ut(t,3)),i.setAttribute("color",new ut(s,3));const r=new ji({vertexColors:!0,toneMapped:!1});super(i,r),this.type="AxesHelper"}setColors(e,t,s){const i=new Je,r=this.geometry.attributes.color.array;return i.set(e),i.toArray(r,0),i.toArray(r,3),i.set(t),i.toArray(r,6),i.toArray(r,9),i.set(s),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class LCe{constructor(){this.type="ShapePath",this.color=new Je,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new Jm,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,s,i){return this.currentPath.quadraticCurveTo(e,t,s,i),this}bezierCurveTo(e,t,s,i,r,o){return this.currentPath.bezierCurveTo(e,t,s,i,r,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(v){const w=[];for(let b=0,S=v.length;b<S;b++){const C=v[b],E=new Xu;E.curves=C.curves,w.push(E)}return w}function s(v,w){const b=w.length;let S=!1;for(let C=b-1,E=0;E<b;C=E++){let k=w[C],I=w[E],A=I.x-k.x,N=I.y-k.y;if(Math.abs(N)>Number.EPSILON){if(N<0&&(k=w[E],A=-A,I=w[C],N=-N),v.y<k.y||v.y>I.y)continue;if(v.y===k.y){if(v.x===k.x)return!0}else{const L=N*(v.x-k.x)-A*(v.y-k.y);if(L===0)return!0;if(L<0)continue;S=!S}}else{if(v.y!==k.y)continue;if(I.x<=v.x&&v.x<=k.x||k.x<=v.x&&v.x<=I.x)return!0}}return S}const i=Ea.isClockWise,r=this.subPaths;if(r.length===0)return[];let o,a,l;const c=[];if(r.length===1)return a=r[0],l=new Xu,l.curves=a.curves,c.push(l),c;let u=!i(r[0].getPoints());u=e?!u:u;const h=[],d=[];let f=[],m=0,x;d[m]=void 0,f[m]=[];for(let v=0,w=r.length;v<w;v++)a=r[v],x=a.getPoints(),o=i(x),o=e?!o:o,o?(!u&&d[m]&&m++,d[m]={s:new Xu,p:x},d[m].s.curves=a.curves,u&&m++,f[m]=[]):f[m].push({h:a,p:x[0]});if(!d[0])return t(r);if(d.length>1){let v=!1,w=0;for(let b=0,S=d.length;b<S;b++)h[b]=[];for(let b=0,S=d.length;b<S;b++){const C=f[b];for(let E=0;E<C.length;E++){const k=C[E];let I=!0;for(let A=0;A<d.length;A++)s(k.p,d[A].p)&&(b!==A&&w++,I?(I=!1,h[A].push(k)):v=!0);I&&h[b].push(k)}}w>0&&v===!1&&(f=h)}let y;for(let v=0,w=d.length;v<w;v++){l=d[v].s,c.push(l),y=f[v];for(let b=0,S=y.length;b<S;b++)l.holes.push(y[b].h)}return c}}const el=PCe();function PCe(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),s=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(s[l]=0,s[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(s[l]=1024>>-c-14,s[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(s[l]=c+15<<10,s[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(s[l]=31744,s[l|256]=64512,i[l]=24,i[l|256]=24):(s[l]=31744,s[l|256]=64512,i[l]=13,i[l|256]=13)}const r=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,u=0;for(;(c&8388608)===0;)c<<=1,u-=8388608;c&=-8388609,u+=947912704,r[l]=c|u}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:s,shiftTable:i,mantissaTable:r,exponentTable:o,offsetTable:a}}function $Ce(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=hs(n,-65504,65504),el.floatView[0]=n;const e=el.uint32View[0],t=e>>23&511;return el.baseTable[t]+((e&8388607)>>el.shiftTable[t])}function FCe(n){const e=n>>10;return el.uint32View[0]=el.mantissaTable[el.offsetTable[e]+(n&1023)]+el.exponentTable[e],el.floatView[0]}var OCe=Object.freeze({__proto__:null,toHalfFloat:$Ce,fromHalfFloat:FCe});function zCe(){console.error("THREE.ImmediateRenderObject has been removed.")}class BCe extends mo{constructor(e,t,s){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(e,t,s),this.samples=4}}class UCe extends L0{constructor(e,t,s,i){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(e,t,s,i)}}class VCe extends Vb{constructor(e,t,s,i){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(e,t,s,i)}}class WCe extends Tl{constructor(e,t,s,i,r,o){console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),super(e,t,s,i,r,o)}}class GCe extends O0{constructor(e,t,s,i){console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),super(e,t,s,i)}}class HCe extends z0{constructor(e,t,s,i){console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),super(e,t,s,i)}}class XCe extends B0{constructor(e,t,s,i,r,o,a){console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),super(e,t,s,i,r,o,a)}}class jCe extends Rh{constructor(e,t,s,i,r,o,a,l){console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),super(e,t,s,i,r,o,a,l)}}class qCe extends U0{constructor(e,t){console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),super(e,t)}}class KCe extends V0{constructor(e,t){console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),super(e,t)}}class YCe extends W0{constructor(e,t){console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),super(e,t)}}class ZCe extends jf{constructor(e,t,s,i){console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),super(e,t,s,i)}}class JCe extends qf{constructor(e,t){console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),super(e,t)}}class QCe extends Hf{constructor(e,t,s,i){console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),super(e,t,s,i)}}class e2e extends Il{constructor(e,t,s,i){console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),super(e,t,s,i)}}class t2e extends G0{constructor(e,t,s,i,r,o){console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),super(e,t,s,i,r,o)}}class n2e extends H0{constructor(e,t){console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),super(e,t)}}class s2e extends Kf{constructor(e,t,s,i,r,o,a){console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),super(e,t,s,i,r,o,a)}}class i2e extends X0{constructor(e,t){console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),super(e,t)}}class r2e extends j0{constructor(e,t,s,i,r){console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),super(e,t,s,i,r)}}class o2e extends q0{constructor(e,t,s,i,r,o){console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),super(e,t,s,i,r,o)}}class a2e extends K0{constructor(e,t,s,i,r){console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),super(e,t,s,i,r)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Ob}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Ob);const W1=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:Yk,AddEquation:Su,AddOperation:cG,AdditiveAnimationBlendMode:Qk,AdditiveBlending:IT,AlphaFormat:vG,AlwaysDepth:nG,AlwaysStencilFunc:PG,AmbientLight:N5,AmbientLightProbe:K_e,AnimationClip:ig,AnimationLoader:$_e,AnimationMixer:pCe,AnimationObjectGroup:hCe,AnimationUtils:R_e,ArcCurve:i5,ArrayCamera:qG,ArrowHelper:RCe,Audio:P5,AudioAnalyser:tCe,AudioContext:kA,AudioListener:J_e,AudioLoader:j_e,AxesHelper:DCe,BackSide:Er,BasicDepthPacking:RG,BasicShadowMap:VW,Bone:hA,BooleanKeyframeTrack:Dh,Box2:vCe,Box3:Ra,Box3Helper:ACe,BoxBufferGeometry:WCe,BoxGeometry:Tl,BoxHelper:kCe,BufferAttribute:Cn,BufferGeometry:Bt,BufferGeometryLoader:L5,ByteType:pG,Cache:gh,Camera:$0,CameraHelper:MCe,CanvasTexture:n_e,CapsuleBufferGeometry:GCe,CapsuleGeometry:O0,CatmullRomCurve3:r5,CineonToneMapping:dG,CircleBufferGeometry:HCe,CircleGeometry:z0,ClampToEdgeWrapping:Si,Clock:AA,Color:Je,ColorKeyframeTrack:TA,ColorManagement:gi,CompressedArrayTexture:t_e,CompressedTexture:fA,CompressedTextureLoader:F_e,ConeBufferGeometry:XCe,ConeGeometry:B0,CubeCamera:BG,CubeReflectionMapping:Ec,CubeRefractionMapping:Mc,CubeTexture:F0,CubeTextureLoader:O_e,CubeUVReflectionMapping:Wf,CubicBezierCurve:mA,CubicBezierCurve3:o5,CubicInterpolant:_5,CullFaceBack:TT,CullFaceFront:UW,CullFaceFrontBack:rye,CullFaceNone:BW,Curve:Yo,CurvePath:l5,CustomBlending:WW,CustomToneMapping:fG,CylinderBufferGeometry:jCe,CylinderGeometry:Rh,Cylindrical:yCe,Data3DTexture:Vb,DataArrayTexture:L0,DataTexture:Kd,DataTexture2DArray:UCe,DataTexture3D:VCe,DataTextureLoader:z_e,DataUtils:OCe,DecrementStencilOp:xye,DecrementWrapStencilOp:vye,DefaultLoadingManager:I5,DepthFormat:gc,DepthStencilFormat:ph,DepthTexture:KG,DirectionalLight:A5,DirectionalLightHelper:ECe,DiscreteInterpolant:C5,DodecahedronBufferGeometry:qCe,DodecahedronGeometry:U0,DoubleSide:sl,DstAlphaFactor:YW,DstColorFactor:JW,DynamicCopyUsage:Lye,DynamicDrawUsage:Mye,DynamicReadUsage:Nye,EdgesGeometry:c5,EllipseCurve:Yb,EqualDepth:iG,EqualStencilFunc:_ye,EquirectangularReflectionMapping:Vm,EquirectangularRefractionMapping:Wm,Euler:Gf,EventDispatcher:Na,ExtrudeBufferGeometry:KCe,ExtrudeGeometry:V0,FileLoader:xl,Float16BufferAttribute:pve,Float32BufferAttribute:ut,Float64BufferAttribute:mve,FloatType:il,Fog:jb,FogExp2:Xb,FramebufferTexture:e_e,FrontSide:fh,Frustum:Gb,GLBufferAttribute:xCe,GLSL1:$ye,GLSL3:JT,GreaterDepth:oG,GreaterEqualDepth:rG,GreaterEqualStencilFunc:Eye,GreaterStencilFunc:Tye,GridHelper:TCe,Group:$d,HalfFloatType:vf,HemisphereLight:E5,HemisphereLightHelper:CCe,HemisphereLightProbe:q_e,IcosahedronBufferGeometry:YCe,IcosahedronGeometry:W0,ImageBitmapLoader:X_e,ImageLoader:rg,ImageUtils:nA,ImmediateRenderObject:zCe,IncrementStencilOp:gye,IncrementWrapStencilOp:yye,InstancedBufferAttribute:Sf,InstancedBufferGeometry:MA,InstancedInterleavedBuffer:V1,InstancedMesh:t5,Int16BufferAttribute:dve,Int32BufferAttribute:fve,Int8BufferAttribute:cve,IntType:gG,InterleavedBuffer:qb,InterleavedBufferAttribute:Cr,Interpolant:Y0,InterpolateDiscrete:Xm,InterpolateLinear:jm,InterpolateSmooth:Pv,InvertStencilOp:wye,KeepStencilOp:$v,KeyframeTrack:Zo,LOD:QG,LatheBufferGeometry:ZCe,LatheGeometry:jf,Layers:Hu,LessDepth:sG,LessEqualDepth:F1,LessEqualStencilFunc:Cye,LessStencilFunc:Sye,Light:Gc,LightProbe:Qb,Line:Ac,Line3:O5,LineBasicMaterial:ji,LineCurve:Zb,LineCurve3:a5,LineDashedMaterial:b5,LineLoop:n5,LineSegments:Da,LinearEncoding:gl,LinearFilter:us,LinearInterpolant:CA,LinearMipMapLinearFilter:cye,LinearMipMapNearestFilter:lye,LinearMipmapLinearFilter:Nh,LinearMipmapNearestFilter:Zk,LinearSRGBColorSpace:wf,LinearToneMapping:uG,Loader:$r,LoaderUtils:oI,LoadingManager:IA,LoopOnce:kG,LoopPingPong:NG,LoopRepeat:AG,LuminanceAlphaFormat:SG,LuminanceFormat:bG,MOUSE:gu,Material:li,MaterialLoader:eS,MathUtils:tA,Matrix3:zi,Matrix4:kt,MaxEquation:AT,Mesh:js,MeshBasicMaterial:Cl,MeshDepthMaterial:oA,MeshDistanceMaterial:aA,MeshLambertMaterial:v5,MeshMatcapMaterial:w5,MeshNormalMaterial:y5,MeshPhongMaterial:g5,MeshPhysicalMaterial:m5,MeshStandardMaterial:bA,MeshToonMaterial:x5,MinEquation:kT,MirroredRepeatWrapping:Hm,MixOperation:lG,MultiplyBlending:MT,MultiplyOperation:D0,NearestFilter:ws,NearestMipMapLinearFilter:aye,NearestMipMapNearestFilter:oye,NearestMipmapLinearFilter:z1,NearestMipmapNearestFilter:O1,NeverDepth:tG,NeverStencilFunc:bye,NoBlending:ll,NoColorSpace:fye,NoToneMapping:Uo,NormalAnimationBlendMode:Ub,NormalBlending:Uu,NotEqualDepth:aG,NotEqualStencilFunc:Iye,NumberKeyframeTrack:ng,Object3D:fn,ObjectLoader:G_e,ObjectSpaceNormalMap:LG,OctahedronBufferGeometry:JCe,OctahedronGeometry:qf,OneFactor:jW,OneMinusDstAlphaFactor:ZW,OneMinusDstColorFactor:QW,OneMinusSrcAlphaFactor:Kk,OneMinusSrcColorFactor:KW,OrthographicCamera:xc,PCFShadowMap:zb,PCFSoftShadowMap:um,PMREMGenerator:eI,Path:Jm,PerspectiveCamera:Un,Plane:ql,PlaneBufferGeometry:QCe,PlaneGeometry:Hf,PlaneHelper:NCe,PointLight:k5,PointLightHelper:SCe,Points:s5,PointsMaterial:dA,PolarGridHelper:ICe,PolyhedronBufferGeometry:e2e,PolyhedronGeometry:Il,PositionalAudio:eCe,PropertyBinding:sn,PropertyMixer:$5,QuadraticBezierCurve:gA,QuadraticBezierCurve3:xA,Quaternion:_i,QuaternionKeyframeTrack:Yf,QuaternionLinearInterpolant:T5,REVISION:Ob,RGBADepthPacking:DG,RGBAFormat:br,RGBAIntegerFormat:EG,RGBA_ASTC_10x10_Format:qT,RGBA_ASTC_10x5_Format:HT,RGBA_ASTC_10x6_Format:XT,RGBA_ASTC_10x8_Format:jT,RGBA_ASTC_12x10_Format:KT,RGBA_ASTC_12x12_Format:YT,RGBA_ASTC_4x4_Format:FT,RGBA_ASTC_5x4_Format:OT,RGBA_ASTC_5x5_Format:zT,RGBA_ASTC_6x5_Format:BT,RGBA_ASTC_6x6_Format:UT,RGBA_ASTC_8x5_Format:VT,RGBA_ASTC_8x6_Format:WT,RGBA_ASTC_8x8_Format:GT,RGBA_BPTC_Format:ZT,RGBA_ETC2_EAC_Format:$T,RGBA_PVRTC_2BPPV1_Format:LT,RGBA_PVRTC_4BPPV1_Format:DT,RGBA_S3TC_DXT1_Format:Rv,RGBA_S3TC_DXT3_Format:Dv,RGBA_S3TC_DXT5_Format:Lv,RGBFormat:wG,RGB_ETC1_Format:MG,RGB_ETC2_Format:PT,RGB_PVRTC_2BPPV1_Format:RT,RGB_PVRTC_4BPPV1_Format:NT,RGB_S3TC_DXT1_Format:Nv,RGFormat:TG,RGIntegerFormat:IG,RawShaderMaterial:p5,Ray:P0,Raycaster:F5,RectAreaLight:R5,RedFormat:_G,RedIntegerFormat:CG,ReinhardToneMapping:hG,RepeatWrapping:Gm,ReplaceStencilOp:mye,ReverseSubtractEquation:HW,RingBufferGeometry:t2e,RingGeometry:G0,SRGBColorSpace:No,Scene:cA,ShaderChunk:Ot,ShaderLib:Fi,ShaderMaterial:jo,ShadowMaterial:f5,Shape:Xu,ShapeBufferGeometry:n2e,ShapeGeometry:H0,ShapePath:LCe,ShapeUtils:Ea,ShortType:mG,Skeleton:Kb,SkeletonHelper:bCe,SkinnedMesh:e5,Source:Du,Sphere:_l,SphereBufferGeometry:s2e,SphereGeometry:Kf,Spherical:lI,SphericalHarmonics3:D5,SplineCurve:yA,SpotLight:M5,SpotLightHelper:wCe,Sprite:JG,SpriteMaterial:uA,SrcAlphaFactor:qk,SrcAlphaSaturateFactor:eG,SrcColorFactor:qW,StaticCopyUsage:Dye,StaticDrawUsage:Km,StaticReadUsage:Aye,StereoCamera:Y_e,StreamCopyUsage:Pye,StreamDrawUsage:kye,StreamReadUsage:Rye,StringKeyframeTrack:Lh,SubtractEquation:GW,SubtractiveBlending:ET,TOUCH:xu,TangentSpaceNormalMap:Wc,TetrahedronBufferGeometry:i2e,TetrahedronGeometry:X0,Texture:ns,TextureLoader:B_e,TorusBufferGeometry:r2e,TorusGeometry:j0,TorusKnotBufferGeometry:o2e,TorusKnotGeometry:q0,Triangle:so,TriangleFanDrawMode:dye,TriangleStripDrawMode:hye,TrianglesDrawMode:uye,TubeBufferGeometry:a2e,TubeGeometry:K0,UVMapping:Bb,Uint16BufferAttribute:sA,Uint32BufferAttribute:iA,Uint8BufferAttribute:uve,Uint8ClampedBufferAttribute:hve,Uniform:DA,UniformsGroup:gCe,UniformsLib:je,UniformsUtils:Wb,UnsignedByteType:kc,UnsignedInt248Type:Vu,UnsignedIntType:sc,UnsignedShort4444Type:xG,UnsignedShort5551Type:yG,UnsignedShortType:Jk,VSMShadowMap:Au,Vector2:Ae,Vector3:G,Vector4:rn,VectorKeyframeTrack:sg,VideoTexture:QSe,WebGL1Renderer:YG,WebGL3DRenderTarget:Qye,WebGLArrayRenderTarget:Jye,WebGLCubeRenderTarget:UG,WebGLMultipleRenderTargets:eve,WebGLMultisampleRenderTarget:BCe,WebGLRenderTarget:mo,WebGLRenderer:lA,WebGLUtils:jG,WireframeGeometry:wA,WrapAroundEnding:qm,ZeroCurvatureEnding:Nu,ZeroFactor:XW,ZeroSlopeEnding:Ru,ZeroStencilOp:pye,_SRGBAFormat:B1,sRGBEncoding:En},Symbol.toStringTag,{value:"Module"}));var Pu={exports:{}},Ph={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */Ph.ConcurrentRoot=1;Ph.ContinuousEventPriority=4;Ph.DefaultEventPriority=16;Ph.DiscreteEventPriority=1;Ph.IdleEventPriority=536870912;Ph.LegacyRoot=0;(function(n){n.exports=Ph})(Pu);function l2e(n){let e;const t=new Set,s=(c,u)=>{const h=typeof c=="function"?c(e):c;if(h!==e){const d=e;e=u?h:Object.assign({},e,h),t.forEach(f=>f(e,d))}},i=()=>e,r=(c,u=i,h=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let d=u(e);function f(){const m=u(e);if(!h(d,m)){const x=d;c(d=m,x)}}return t.add(f),()=>t.delete(f)},l={setState:s,getState:i,subscribe:(c,u,h)=>u||h?r(c,u,h):(t.add(c),()=>t.delete(c)),destroy:()=>t.clear()};return e=n(s,i,l),l}const c2e=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),NP=c2e?qe.exports.useEffect:qe.exports.useLayoutEffect;function u2e(n){const e=typeof n=="function"?l2e(n):n,t=(s=e.getState,i=Object.is)=>{const[,r]=qe.exports.useReducer(y=>y+1,0),o=e.getState(),a=qe.exports.useRef(o),l=qe.exports.useRef(s),c=qe.exports.useRef(i),u=qe.exports.useRef(!1),h=qe.exports.useRef();h.current===void 0&&(h.current=s(o));let d,f=!1;(a.current!==o||l.current!==s||c.current!==i||u.current)&&(d=s(o),f=!i(h.current,d)),NP(()=>{f&&(h.current=d),a.current=o,l.current=s,c.current=i,u.current=!1});const m=qe.exports.useRef(o);NP(()=>{const y=()=>{try{const w=e.getState(),b=l.current(w);c.current(h.current,b)||(a.current=w,h.current=b,r())}catch{u.current=!0,r()}},v=e.subscribe(y);return e.getState()!==m.current&&y(),v},[]);const x=f?d:h.current;return qe.exports.useDebugValue(x),x};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const s=[t,e];return{next(){const i=s.length<=0;return{value:s.shift(),done:i}}}},t}var B5={exports:{}},G1={exports:{}},U5={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(n){function e(D,$){var U=D.length;D.push($);e:for(;0<U;){var B=U-1>>>1,X=D[B];if(0<i(X,$))D[B]=$,D[U]=X,U=B;else break e}}function t(D){return D.length===0?null:D[0]}function s(D){if(D.length===0)return null;var $=D[0],U=D.pop();if(U!==$){D[0]=U;e:for(var B=0,X=D.length,te=X>>>1;B<te;){var oe=2*(B+1)-1,ue=D[oe],Q=oe+1,ke=D[Q];if(0>i(ue,U))Q<X&&0>i(ke,ue)?(D[B]=ke,D[Q]=U,B=Q):(D[B]=ue,D[oe]=U,B=oe);else if(Q<X&&0>i(ke,U))D[B]=ke,D[Q]=U,B=Q;else break e}}return $}function i(D,$){var U=D.sortIndex-$.sortIndex;return U!==0?U:D.id-$.id}if(typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],c=[],u=1,h=null,d=3,f=!1,m=!1,x=!1,y=typeof setTimeout=="function"?setTimeout:null,v=typeof clearTimeout=="function"?clearTimeout:null,w=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function b(D){for(var $=t(c);$!==null;){if($.callback===null)s(c);else if($.startTime<=D)s(c),$.sortIndex=$.expirationTime,e(l,$);else break;$=t(c)}}function S(D){if(x=!1,b(D),!m)if(t(l)!==null)m=!0,H(C);else{var $=t(c);$!==null&&Y(S,$.startTime-D)}}function C(D,$){m=!1,x&&(x=!1,v(I),I=-1),f=!0;var U=d;try{for(b($),h=t(l);h!==null&&(!(h.expirationTime>$)||D&&!L());){var B=h.callback;if(typeof B=="function"){h.callback=null,d=h.priorityLevel;var X=B(h.expirationTime<=$);$=n.unstable_now(),typeof X=="function"?h.callback=X:h===t(l)&&s(l),b($)}else s(l);h=t(l)}if(h!==null)var te=!0;else{var oe=t(c);oe!==null&&Y(S,oe.startTime-$),te=!1}return te}finally{h=null,d=U,f=!1}}var E=!1,k=null,I=-1,A=5,N=-1;function L(){return!(n.unstable_now()-N<A)}function V(){if(k!==null){var D=n.unstable_now();N=D;var $=!0;try{$=k(!0,D)}finally{$?O():(E=!1,k=null)}}else E=!1}var O;if(typeof w=="function")O=function(){w(V)};else if(typeof MessageChannel<"u"){var P=new MessageChannel,W=P.port2;P.port1.onmessage=V,O=function(){W.postMessage(null)}}else O=function(){y(V,0)};function H(D){k=D,E||(E=!0,O())}function Y(D,$){I=y(function(){D(n.unstable_now())},$)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(D){D.callback=null},n.unstable_continueExecution=function(){m||f||(m=!0,H(C))},n.unstable_forceFrameRate=function(D){0>D||125<D?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):A=0<D?Math.floor(1e3/D):5},n.unstable_getCurrentPriorityLevel=function(){return d},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(D){switch(d){case 1:case 2:case 3:var $=3;break;default:$=d}var U=d;d=$;try{return D()}finally{d=U}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(D,$){switch(D){case 1:case 2:case 3:case 4:case 5:break;default:D=3}var U=d;d=D;try{return $()}finally{d=U}},n.unstable_scheduleCallback=function(D,$,U){var B=n.unstable_now();switch(typeof U=="object"&&U!==null?(U=U.delay,U=typeof U=="number"&&0<U?B+U:B):U=B,D){case 1:var X=-1;break;case 2:X=250;break;case 5:X=1073741823;break;case 4:X=1e4;break;default:X=5e3}return X=U+X,D={id:u++,callback:$,priorityLevel:D,startTime:U,expirationTime:X,sortIndex:-1},U>B?(D.sortIndex=U,e(c,D),t(l)===null&&D===t(c)&&(x?(v(I),I=-1):x=!0,Y(S,U-B))):(D.sortIndex=X,e(l,D),m||f||(m=!0,H(C))),D},n.unstable_shouldYield=L,n.unstable_wrapCallback=function(D){var $=d;return function(){var U=d;d=$;try{return D.apply(this,arguments)}finally{d=U}}}})(U5);(function(n){n.exports=U5})(G1);/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var h2e=function(e){var t={},s=qe.exports,i=G1.exports,r=Object.assign;function o(p){for(var g="https://reactjs.org/docs/error-decoder.html?invariant="+p,_=1;_<arguments.length;_++)g+="&args[]="+encodeURIComponent(arguments[_]);return"Minified React error #"+p+"; visit "+g+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,l=Symbol.for("react.element"),c=Symbol.for("react.portal"),u=Symbol.for("react.fragment"),h=Symbol.for("react.strict_mode"),d=Symbol.for("react.profiler"),f=Symbol.for("react.provider"),m=Symbol.for("react.context"),x=Symbol.for("react.forward_ref"),y=Symbol.for("react.suspense"),v=Symbol.for("react.suspense_list"),w=Symbol.for("react.memo"),b=Symbol.for("react.lazy"),S=Symbol.for("react.offscreen"),C=Symbol.iterator;function E(p){return p===null||typeof p!="object"?null:(p=C&&p[C]||p["@@iterator"],typeof p=="function"?p:null)}function k(p){if(p==null)return null;if(typeof p=="function")return p.displayName||p.name||null;if(typeof p=="string")return p;switch(p){case u:return"Fragment";case c:return"Portal";case d:return"Profiler";case h:return"StrictMode";case y:return"Suspense";case v:return"SuspenseList"}if(typeof p=="object")switch(p.$$typeof){case m:return(p.displayName||"Context")+".Consumer";case f:return(p._context.displayName||"Context")+".Provider";case x:var g=p.render;return p=p.displayName,p||(p=g.displayName||g.name||"",p=p!==""?"ForwardRef("+p+")":"ForwardRef"),p;case w:return g=p.displayName||null,g!==null?g:k(p.type)||"Memo";case b:g=p._payload,p=p._init;try{return k(p(g))}catch{}}return null}function I(p){var g=p.type;switch(p.tag){case 24:return"Cache";case 9:return(g.displayName||"Context")+".Consumer";case 10:return(g._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return p=g.render,p=p.displayName||p.name||"",g.displayName||(p!==""?"ForwardRef("+p+")":"ForwardRef");case 7:return"Fragment";case 5:return g;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return k(g);case 8:return g===h?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof g=="function")return g.displayName||g.name||null;if(typeof g=="string")return g}return null}function A(p){var g=p,_=p;if(p.alternate)for(;g.return;)g=g.return;else{p=g;do g=p,(g.flags&4098)!==0&&(_=g.return),p=g.return;while(p)}return g.tag===3?_:null}function N(p){if(A(p)!==p)throw Error(o(188))}function L(p){var g=p.alternate;if(!g){if(g=A(p),g===null)throw Error(o(188));return g!==p?null:p}for(var _=p,T=g;;){var M=_.return;if(M===null)break;var R=M.alternate;if(R===null){if(T=M.return,T!==null){_=T;continue}break}if(M.child===R.child){for(R=M.child;R;){if(R===_)return N(M),p;if(R===T)return N(M),g;R=R.sibling}throw Error(o(188))}if(_.return!==T.return)_=M,T=R;else{for(var K=!1,re=M.child;re;){if(re===_){K=!0,_=M,T=R;break}if(re===T){K=!0,T=M,_=R;break}re=re.sibling}if(!K){for(re=R.child;re;){if(re===_){K=!0,_=R,T=M;break}if(re===T){K=!0,T=R,_=M;break}re=re.sibling}if(!K)throw Error(o(189))}}if(_.alternate!==T)throw Error(o(190))}if(_.tag!==3)throw Error(o(188));return _.stateNode.current===_?p:g}function V(p){return p=L(p),p!==null?O(p):null}function O(p){if(p.tag===5||p.tag===6)return p;for(p=p.child;p!==null;){var g=O(p);if(g!==null)return g;p=p.sibling}return null}function P(p){if(p.tag===5||p.tag===6)return p;for(p=p.child;p!==null;){if(p.tag!==4){var g=P(p);if(g!==null)return g}p=p.sibling}return null}var W=Array.isArray,H=e.getPublicInstance,Y=e.getRootHostContext,D=e.getChildHostContext,$=e.prepareForCommit,U=e.resetAfterCommit,B=e.createInstance,X=e.appendInitialChild,te=e.finalizeInitialChildren,oe=e.prepareUpdate,ue=e.shouldSetTextContent,Q=e.createTextInstance,ke=e.scheduleTimeout,Me=e.cancelTimeout,De=e.noTimeout,Ee=e.isPrimaryRenderer,Be=e.supportsMutation,ye=e.supportsPersistence,fe=e.supportsHydration,Re=e.getInstanceFromNode,We=e.preparePortalMount,Le=e.getCurrentEventPriority,nt=e.detachDeletedInstance,Ke=e.supportsMicrotasks,ot=e.scheduleMicrotask,vt=e.supportsTestSelectors,Dt=e.findFiberRoot,q=e.getBoundingRect,z=e.getTextContent,ge=e.isHiddenSubtree,Pe=e.matchAccessibilityRole,ze=e.setFocusIfFocusable,Xe=e.setupIntersectionObserver,ft=e.appendChild,Ye=e.appendChildToContainer,Te=e.commitTextUpdate,ht=e.commitMount,J=e.commitUpdate,ve=e.insertBefore,Oe=e.insertInContainerBefore,Ge=e.removeChild,St=e.removeChildFromContainer,Xt=e.resetTextContent,Dn=e.hideInstance,ie=e.hideTextInstance,_e=e.unhideInstance,Fe=e.unhideTextInstance,rt=e.clearContainer,gt=e.cloneInstance,nn=e.createContainerChildSet,os=e.appendChildToContainerChildSet,zs=e.finalizeContainerChildren,Jo=e.replaceContainerChildren,vn=e.cloneHiddenInstance,Fr=e.cloneHiddenTextInstance,qi=e.canHydrateInstance,J0=e.canHydrateTextInstance,iS=e.canHydrateSuspenseInstance,Q0=e.isSuspenseInstancePending,Zf=e.isSuspenseInstanceFallback,j=e.registerSuspenseInstanceRetry,pe=e.getNextHydratableSibling,Ie=e.getFirstHydratableChild,he=e.getFirstHydratableChildWithinContainer,Ne=e.getFirstHydratableChildWithinSuspenseInstance,wt=e.hydrateInstance,It=e.hydrateTextInstance,Pt=e.hydrateSuspenseInstance,Vt=e.getNextHydratableInstanceAfterSuspenseInstance,Jt=e.commitHydratedContainer,jt=e.commitHydratedSuspenseInstance,qt=e.clearSuspenseBoundary,Kn=e.clearSuspenseBoundaryFromContainer,ki=e.shouldDeleteUnhydratedTailInstances,vo=e.didNotMatchHydratedContainerTextInstance,La=e.didNotMatchHydratedTextInstance,On;function $t(p){if(On===void 0)try{throw Error()}catch(_){var g=_.stack.trim().match(/\n( *(at )?)/);On=g&&g[1]||""}return`
`+On+p}var Hc=!1;function Yn(p,g){if(!p||Hc)return"";Hc=!0;var _=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(g)if(g=function(){throw Error()},Object.defineProperty(g.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(g,[])}catch(He){var T=He}Reflect.construct(p,[],g)}else{try{g.call()}catch(He){T=He}p.call(g.prototype)}else{try{throw Error()}catch(He){T=He}p()}}catch(He){if(He&&T&&typeof He.stack=="string"){for(var M=He.stack.split(`
`),R=T.stack.split(`
`),K=M.length-1,re=R.length-1;1<=K&&0<=re&&M[K]!==R[re];)re--;for(;1<=K&&0<=re;K--,re--)if(M[K]!==R[re]){if(K!==1||re!==1)do if(K--,re--,0>re||M[K]!==R[re]){var Ce=`
`+M[K].replace(" at new "," at ");return p.displayName&&Ce.includes("<anonymous>")&&(Ce=Ce.replace("<anonymous>",p.displayName)),Ce}while(1<=K&&0<=re);break}}}finally{Hc=!1,Error.prepareStackTrace=_}return(p=p?p.displayName||p.name:"")?$t(p):""}var Pa=Object.prototype.hasOwnProperty,$h=[],Or=-1;function zr(p){return{current:p}}function Lt(p){0>Or||(p.current=$h[Or],$h[Or]=null,Or--)}function tn(p,g){Or++,$h[Or]=p.current,p.current=g}var Br={},mn=zr(Br),Bs=zr(!1),$a=Br;function Fa(p,g){var _=p.type.contextTypes;if(!_)return Br;var T=p.stateNode;if(T&&T.__reactInternalMemoizedUnmaskedChildContext===g)return T.__reactInternalMemoizedMaskedChildContext;var M={},R;for(R in _)M[R]=g[R];return T&&(p=p.stateNode,p.__reactInternalMemoizedUnmaskedChildContext=g,p.__reactInternalMemoizedMaskedChildContext=M),M}function Ki(p){return p=p.childContextTypes,p!=null}function ex(){Lt(Bs),Lt(mn)}function FA(p,g,_){if(mn.current!==Br)throw Error(o(168));tn(mn,g),tn(Bs,_)}function OA(p,g,_){var T=p.stateNode;if(g=g.childContextTypes,typeof T.getChildContext!="function")return _;T=T.getChildContext();for(var M in T)if(!(M in g))throw Error(o(108,I(p)||"Unknown",M));return r({},_,T)}function tx(p){return p=(p=p.stateNode)&&p.__reactInternalMemoizedMergedChildContext||Br,$a=mn.current,tn(mn,p),tn(Bs,Bs.current),!0}function zA(p,g,_){var T=p.stateNode;if(!T)throw Error(o(169));_?(p=OA(p,g,$a),T.__reactInternalMemoizedMergedChildContext=p,Lt(Bs),Lt(mn),tn(mn,p)):Lt(Bs),tn(Bs,_)}var wo=Math.clz32?Math.clz32:fH,hH=Math.log,dH=Math.LN2;function fH(p){return p>>>=0,p===0?32:31-(hH(p)/dH|0)|0}var nx=64,sx=4194304;function Jf(p){switch(p&-p){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return p&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return p&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return p}}function ix(p,g){var _=p.pendingLanes;if(_===0)return 0;var T=0,M=p.suspendedLanes,R=p.pingedLanes,K=_&268435455;if(K!==0){var re=K&~M;re!==0?T=Jf(re):(R&=K,R!==0&&(T=Jf(R)))}else K=_&~M,K!==0?T=Jf(K):R!==0&&(T=Jf(R));if(T===0)return 0;if(g!==0&&g!==T&&(g&M)===0&&(M=T&-T,R=g&-g,M>=R||M===16&&(R&4194240)!==0))return g;if((T&4)!==0&&(T|=_&16),g=p.entangledLanes,g!==0)for(p=p.entanglements,g&=T;0<g;)_=31-wo(g),M=1<<_,T|=p[_],g&=~M;return T}function pH(p,g){switch(p){case 1:case 2:case 4:return g+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return g+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function mH(p,g){for(var _=p.suspendedLanes,T=p.pingedLanes,M=p.expirationTimes,R=p.pendingLanes;0<R;){var K=31-wo(R),re=1<<K,Ce=M[K];Ce===-1?((re&_)===0||(re&T)!==0)&&(M[K]=pH(re,g)):Ce<=g&&(p.expiredLanes|=re),R&=~re}}function rS(p){return p=p.pendingLanes&-1073741825,p!==0?p:p&1073741824?1073741824:0}function oS(p){for(var g=[],_=0;31>_;_++)g.push(p);return g}function Qf(p,g,_){p.pendingLanes|=g,g!==536870912&&(p.suspendedLanes=0,p.pingedLanes=0),p=p.eventTimes,g=31-wo(g),p[g]=_}function gH(p,g){var _=p.pendingLanes&~g;p.pendingLanes=g,p.suspendedLanes=0,p.pingedLanes=0,p.expiredLanes&=g,p.mutableReadLanes&=g,p.entangledLanes&=g,g=p.entanglements;var T=p.eventTimes;for(p=p.expirationTimes;0<_;){var M=31-wo(_),R=1<<M;g[M]=0,T[M]=-1,p[M]=-1,_&=~R}}function aS(p,g){var _=p.entangledLanes|=g;for(p=p.entanglements;_;){var T=31-wo(_),M=1<<T;M&g|p[T]&g&&(p[T]|=g),_&=~M}}var ln=0;function BA(p){return p&=-p,1<p?4<p?(p&268435455)!==0?16:536870912:4:1}var lS=i.unstable_scheduleCallback,UA=i.unstable_cancelCallback,xH=i.unstable_shouldYield,yH=i.unstable_requestPaint,Us=i.unstable_now,cS=i.unstable_ImmediatePriority,vH=i.unstable_UserBlockingPriority,uS=i.unstable_NormalPriority,wH=i.unstable_IdlePriority,rx=null,Qo=null;function bH(p){if(Qo&&typeof Qo.onCommitFiberRoot=="function")try{Qo.onCommitFiberRoot(rx,p,void 0,(p.current.flags&128)===128)}catch{}}function SH(p,g){return p===g&&(p!==0||1/p===1/g)||p!==p&&g!==g}var ea=typeof Object.is=="function"?Object.is:SH,Oa=null,ox=!1,hS=!1;function VA(p){Oa===null?Oa=[p]:Oa.push(p)}function _H(p){ox=!0,VA(p)}function ta(){if(!hS&&Oa!==null){hS=!0;var p=0,g=ln;try{var _=Oa;for(ln=1;p<_.length;p++){var T=_[p];do T=T(!0);while(T!==null)}Oa=null,ox=!1}catch(M){throw Oa!==null&&(Oa=Oa.slice(p+1)),lS(cS,ta),M}finally{ln=g,hS=!1}}return null}var CH=a.ReactCurrentBatchConfig;function ax(p,g){if(ea(p,g))return!0;if(typeof p!="object"||p===null||typeof g!="object"||g===null)return!1;var _=Object.keys(p),T=Object.keys(g);if(_.length!==T.length)return!1;for(T=0;T<_.length;T++){var M=_[T];if(!Pa.call(g,M)||!ea(p[M],g[M]))return!1}return!0}function TH(p){switch(p.tag){case 5:return $t(p.type);case 16:return $t("Lazy");case 13:return $t("Suspense");case 19:return $t("SuspenseList");case 0:case 2:case 15:return p=Yn(p.type,!1),p;case 11:return p=Yn(p.type.render,!1),p;case 1:return p=Yn(p.type,!0),p;default:return""}}function bo(p,g){if(p&&p.defaultProps){g=r({},g),p=p.defaultProps;for(var _ in p)g[_]===void 0&&(g[_]=p[_]);return g}return g}var lx=zr(null),cx=null,Fh=null,dS=null;function fS(){dS=Fh=cx=null}function WA(p,g,_){Ee?(tn(lx,g._currentValue),g._currentValue=_):(tn(lx,g._currentValue2),g._currentValue2=_)}function pS(p){var g=lx.current;Lt(lx),Ee?p._currentValue=g:p._currentValue2=g}function mS(p,g,_){for(;p!==null;){var T=p.alternate;if((p.childLanes&g)!==g?(p.childLanes|=g,T!==null&&(T.childLanes|=g)):T!==null&&(T.childLanes&g)!==g&&(T.childLanes|=g),p===_)break;p=p.return}}function Oh(p,g){cx=p,dS=Fh=null,p=p.dependencies,p!==null&&p.firstContext!==null&&((p.lanes&g)!==0&&(mr=!0),p.firstContext=null)}function Ur(p){var g=Ee?p._currentValue:p._currentValue2;if(dS!==p)if(p={context:p,memoizedValue:g,next:null},Fh===null){if(cx===null)throw Error(o(308));Fh=p,cx.dependencies={lanes:0,firstContext:p}}else Fh=Fh.next=p;return g}var na=null,El=!1;function gS(p){p.updateQueue={baseState:p.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function GA(p,g){p=p.updateQueue,g.updateQueue===p&&(g.updateQueue={baseState:p.baseState,firstBaseUpdate:p.firstBaseUpdate,lastBaseUpdate:p.lastBaseUpdate,shared:p.shared,effects:p.effects})}function za(p,g){return{eventTime:p,lane:g,tag:0,payload:null,callback:null,next:null}}function Ml(p,g){var _=p.updateQueue;_!==null&&(_=_.shared,xs!==null&&(p.mode&1)!==0&&(Wt&2)===0?(p=_.interleaved,p===null?(g.next=g,na===null?na=[_]:na.push(_)):(g.next=p.next,p.next=g),_.interleaved=g):(p=_.pending,p===null?g.next=g:(g.next=p.next,p.next=g),_.pending=g))}function ux(p,g,_){if(g=g.updateQueue,g!==null&&(g=g.shared,(_&4194240)!==0)){var T=g.lanes;T&=p.pendingLanes,_|=T,g.lanes=_,aS(p,_)}}function HA(p,g){var _=p.updateQueue,T=p.alternate;if(T!==null&&(T=T.updateQueue,_===T)){var M=null,R=null;if(_=_.firstBaseUpdate,_!==null){do{var K={eventTime:_.eventTime,lane:_.lane,tag:_.tag,payload:_.payload,callback:_.callback,next:null};R===null?M=R=K:R=R.next=K,_=_.next}while(_!==null);R===null?M=R=g:R=R.next=g}else M=R=g;_={baseState:T.baseState,firstBaseUpdate:M,lastBaseUpdate:R,shared:T.shared,effects:T.effects},p.updateQueue=_;return}p=_.lastBaseUpdate,p===null?_.firstBaseUpdate=g:p.next=g,_.lastBaseUpdate=g}function hx(p,g,_,T){var M=p.updateQueue;El=!1;var R=M.firstBaseUpdate,K=M.lastBaseUpdate,re=M.shared.pending;if(re!==null){M.shared.pending=null;var Ce=re,He=Ce.next;Ce.next=null,K===null?R=He:K.next=He,K=Ce;var ct=p.alternate;ct!==null&&(ct=ct.updateQueue,re=ct.lastBaseUpdate,re!==K&&(re===null?ct.firstBaseUpdate=He:re.next=He,ct.lastBaseUpdate=Ce))}if(R!==null){var At=M.baseState;K=0,ct=He=Ce=null,re=R;do{var _t=re.lane,wn=re.eventTime;if((T&_t)===_t){ct!==null&&(ct=ct.next={eventTime:wn,lane:0,tag:re.tag,payload:re.payload,callback:re.callback,next:null});e:{var xt=p,di=re;switch(_t=g,wn=_,di.tag){case 1:if(xt=di.payload,typeof xt=="function"){At=xt.call(wn,At,_t);break e}At=xt;break e;case 3:xt.flags=xt.flags&-65537|128;case 0:if(xt=di.payload,_t=typeof xt=="function"?xt.call(wn,At,_t):xt,_t==null)break e;At=r({},At,_t);break e;case 2:El=!0}}re.callback!==null&&re.lane!==0&&(p.flags|=64,_t=M.effects,_t===null?M.effects=[re]:_t.push(re))}else wn={eventTime:wn,lane:_t,tag:re.tag,payload:re.payload,callback:re.callback,next:null},ct===null?(He=ct=wn,Ce=At):ct=ct.next=wn,K|=_t;if(re=re.next,re===null){if(re=M.shared.pending,re===null)break;_t=re,re=_t.next,_t.next=null,M.lastBaseUpdate=_t,M.shared.pending=null}}while(1);if(ct===null&&(Ce=At),M.baseState=Ce,M.firstBaseUpdate=He,M.lastBaseUpdate=ct,g=M.shared.interleaved,g!==null){M=g;do K|=M.lane,M=M.next;while(M!==g)}else R===null&&(M.shared.lanes=0);jh|=K,p.lanes=K,p.memoizedState=At}}function XA(p,g,_){if(p=g.effects,g.effects=null,p!==null)for(g=0;g<p.length;g++){var T=p[g],M=T.callback;if(M!==null){if(T.callback=null,T=_,typeof M!="function")throw Error(o(191,M));M.call(T)}}}var jA=new s.Component().refs;function xS(p,g,_,T){g=p.memoizedState,_=_(T,g),_=_==null?g:r({},g,_),p.memoizedState=_,p.lanes===0&&(p.updateQueue.baseState=_)}var dx={isMounted:function(p){return(p=p._reactInternals)?A(p)===p:!1},enqueueSetState:function(p,g,_){p=p._reactInternals;var T=Ni(),M=Nl(p),R=za(T,M);R.payload=g,_!=null&&(R.callback=_),Ml(p,R),g=Xr(p,M,T),g!==null&&ux(g,p,M)},enqueueReplaceState:function(p,g,_){p=p._reactInternals;var T=Ni(),M=Nl(p),R=za(T,M);R.tag=1,R.payload=g,_!=null&&(R.callback=_),Ml(p,R),g=Xr(p,M,T),g!==null&&ux(g,p,M)},enqueueForceUpdate:function(p,g){p=p._reactInternals;var _=Ni(),T=Nl(p),M=za(_,T);M.tag=2,g!=null&&(M.callback=g),Ml(p,M),g=Xr(p,T,_),g!==null&&ux(g,p,T)}};function qA(p,g,_,T,M,R,K){return p=p.stateNode,typeof p.shouldComponentUpdate=="function"?p.shouldComponentUpdate(T,R,K):g.prototype&&g.prototype.isPureReactComponent?!ax(_,T)||!ax(M,R):!0}function KA(p,g,_){var T=!1,M=Br,R=g.contextType;return typeof R=="object"&&R!==null?R=Ur(R):(M=Ki(g)?$a:mn.current,T=g.contextTypes,R=(T=T!=null)?Fa(p,M):Br),g=new g(_,R),p.memoizedState=g.state!==null&&g.state!==void 0?g.state:null,g.updater=dx,p.stateNode=g,g._reactInternals=p,T&&(p=p.stateNode,p.__reactInternalMemoizedUnmaskedChildContext=M,p.__reactInternalMemoizedMaskedChildContext=R),g}function YA(p,g,_,T){p=g.state,typeof g.componentWillReceiveProps=="function"&&g.componentWillReceiveProps(_,T),typeof g.UNSAFE_componentWillReceiveProps=="function"&&g.UNSAFE_componentWillReceiveProps(_,T),g.state!==p&&dx.enqueueReplaceState(g,g.state,null)}function yS(p,g,_,T){var M=p.stateNode;M.props=_,M.state=p.memoizedState,M.refs=jA,gS(p);var R=g.contextType;typeof R=="object"&&R!==null?M.context=Ur(R):(R=Ki(g)?$a:mn.current,M.context=Fa(p,R)),M.state=p.memoizedState,R=g.getDerivedStateFromProps,typeof R=="function"&&(xS(p,g,R,_),M.state=p.memoizedState),typeof g.getDerivedStateFromProps=="function"||typeof M.getSnapshotBeforeUpdate=="function"||typeof M.UNSAFE_componentWillMount!="function"&&typeof M.componentWillMount!="function"||(g=M.state,typeof M.componentWillMount=="function"&&M.componentWillMount(),typeof M.UNSAFE_componentWillMount=="function"&&M.UNSAFE_componentWillMount(),g!==M.state&&dx.enqueueReplaceState(M,M.state,null),hx(p,_,M,T),M.state=p.memoizedState),typeof M.componentDidMount=="function"&&(p.flags|=4194308)}var zh=[],Bh=0,fx=null,px=0,Vr=[],Wr=0,Xc=null,Ba=1,Ua="";function jc(p,g){zh[Bh++]=px,zh[Bh++]=fx,fx=p,px=g}function ZA(p,g,_){Vr[Wr++]=Ba,Vr[Wr++]=Ua,Vr[Wr++]=Xc,Xc=p;var T=Ba;p=Ua;var M=32-wo(T)-1;T&=~(1<<M),_+=1;var R=32-wo(g)+M;if(30<R){var K=M-M%5;R=(T&(1<<K)-1).toString(32),T>>=K,M-=K,Ba=1<<32-wo(g)+M|_<<M|T,Ua=R+p}else Ba=1<<R|_<<M|T,Ua=p}function vS(p){p.return!==null&&(jc(p,1),ZA(p,1,0))}function wS(p){for(;p===fx;)fx=zh[--Bh],zh[Bh]=null,px=zh[--Bh],zh[Bh]=null;for(;p===Xc;)Xc=Vr[--Wr],Vr[Wr]=null,Ua=Vr[--Wr],Vr[Wr]=null,Ba=Vr[--Wr],Vr[Wr]=null}var fr=null,pr=null,zn=!1,ep=!1,So=null;function JA(p,g){var _=jr(5,null,null,0);_.elementType="DELETED",_.stateNode=g,_.return=p,g=p.deletions,g===null?(p.deletions=[_],p.flags|=16):g.push(_)}function QA(p,g){switch(p.tag){case 5:return g=qi(g,p.type,p.pendingProps),g!==null?(p.stateNode=g,fr=p,pr=Ie(g),!0):!1;case 6:return g=J0(g,p.pendingProps),g!==null?(p.stateNode=g,fr=p,pr=null,!0):!1;case 13:if(g=iS(g),g!==null){var _=Xc!==null?{id:Ba,overflow:Ua}:null;return p.memoizedState={dehydrated:g,treeContext:_,retryLane:1073741824},_=jr(18,null,null,0),_.stateNode=g,_.return=p,p.child=_,fr=p,pr=null,!0}return!1;default:return!1}}function bS(p){return(p.mode&1)!==0&&(p.flags&128)===0}function SS(p){if(zn){var g=pr;if(g){var _=g;if(!QA(p,g)){if(bS(p))throw Error(o(418));g=pe(_);var T=fr;g&&QA(p,g)?JA(T,_):(p.flags=p.flags&-4097|2,zn=!1,fr=p)}}else{if(bS(p))throw Error(o(418));p.flags=p.flags&-4097|2,zn=!1,fr=p}}}function eN(p){for(p=p.return;p!==null&&p.tag!==5&&p.tag!==3&&p.tag!==13;)p=p.return;fr=p}function tp(p){if(!fe||p!==fr)return!1;if(!zn)return eN(p),zn=!0,!1;if(p.tag!==3&&(p.tag!==5||ki(p.type)&&!ue(p.type,p.memoizedProps))){var g=pr;if(g){if(bS(p)){for(p=pr;p;)p=pe(p);throw Error(o(418))}for(;g;)JA(p,g),g=pe(g)}}if(eN(p),p.tag===13){if(!fe)throw Error(o(316));if(p=p.memoizedState,p=p!==null?p.dehydrated:null,!p)throw Error(o(317));pr=Vt(p)}else pr=fr?pe(p.stateNode):null;return!0}function Uh(){fe&&(pr=fr=null,ep=zn=!1)}function _S(p){So===null?So=[p]:So.push(p)}function np(p,g,_){if(p=_.ref,p!==null&&typeof p!="function"&&typeof p!="object"){if(_._owner){if(_=_._owner,_){if(_.tag!==1)throw Error(o(309));var T=_.stateNode}if(!T)throw Error(o(147,p));var M=T,R=""+p;return g!==null&&g.ref!==null&&typeof g.ref=="function"&&g.ref._stringRef===R?g.ref:(g=function(K){var re=M.refs;re===jA&&(re=M.refs={}),K===null?delete re[R]:re[R]=K},g._stringRef=R,g)}if(typeof p!="string")throw Error(o(284));if(!_._owner)throw Error(o(290,p))}return p}function mx(p,g){throw p=Object.prototype.toString.call(g),Error(o(31,p==="[object Object]"?"object with keys {"+Object.keys(g).join(", ")+"}":p))}function tN(p){var g=p._init;return g(p._payload)}function nN(p){function g(me,le){if(p){var be=me.deletions;be===null?(me.deletions=[le],me.flags|=16):be.push(le)}}function _(me,le){if(!p)return null;for(;le!==null;)g(me,le),le=le.sibling;return null}function T(me,le){for(me=new Map;le!==null;)le.key!==null?me.set(le.key,le):me.set(le.index,le),le=le.sibling;return me}function M(me,le){return me=Dl(me,le),me.index=0,me.sibling=null,me}function R(me,le,be){return me.index=be,p?(be=me.alternate,be!==null?(be=be.index,be<le?(me.flags|=2,le):be):(me.flags|=2,le)):(me.flags|=1048576,le)}function K(me){return p&&me.alternate===null&&(me.flags|=2),me}function re(me,le,be,st){return le===null||le.tag!==6?(le=o_(be,me.mode,st),le.return=me,le):(le=M(le,be),le.return=me,le)}function Ce(me,le,be,st){var pt=be.type;return pt===u?ct(me,le,be.props.children,st,be.key):le!==null&&(le.elementType===pt||typeof pt=="object"&&pt!==null&&pt.$$typeof===b&&tN(pt)===le.type)?(st=M(le,be.props),st.ref=np(me,le,be),st.return=me,st):(st=Xx(be.type,be.key,be.props,null,me.mode,st),st.ref=np(me,le,be),st.return=me,st)}function He(me,le,be,st){return le===null||le.tag!==4||le.stateNode.containerInfo!==be.containerInfo||le.stateNode.implementation!==be.implementation?(le=a_(be,me.mode,st),le.return=me,le):(le=M(le,be.children||[]),le.return=me,le)}function ct(me,le,be,st,pt){return le===null||le.tag!==7?(le=eu(be,me.mode,st,pt),le.return=me,le):(le=M(le,be),le.return=me,le)}function At(me,le,be){if(typeof le=="string"&&le!==""||typeof le=="number")return le=o_(""+le,me.mode,be),le.return=me,le;if(typeof le=="object"&&le!==null){switch(le.$$typeof){case l:return be=Xx(le.type,le.key,le.props,null,me.mode,be),be.ref=np(me,null,le),be.return=me,be;case c:return le=a_(le,me.mode,be),le.return=me,le;case b:var st=le._init;return At(me,st(le._payload),be)}if(W(le)||E(le))return le=eu(le,me.mode,be,null),le.return=me,le;mx(me,le)}return null}function _t(me,le,be,st){var pt=le!==null?le.key:null;if(typeof be=="string"&&be!==""||typeof be=="number")return pt!==null?null:re(me,le,""+be,st);if(typeof be=="object"&&be!==null){switch(be.$$typeof){case l:return be.key===pt?Ce(me,le,be,st):null;case c:return be.key===pt?He(me,le,be,st):null;case b:return pt=be._init,_t(me,le,pt(be._payload),st)}if(W(be)||E(be))return pt!==null?null:ct(me,le,be,st,null);mx(me,be)}return null}function wn(me,le,be,st,pt){if(typeof st=="string"&&st!==""||typeof st=="number")return me=me.get(be)||null,re(le,me,""+st,pt);if(typeof st=="object"&&st!==null){switch(st.$$typeof){case l:return me=me.get(st.key===null?be:st.key)||null,Ce(le,me,st,pt);case c:return me=me.get(st.key===null?be:st.key)||null,He(le,me,st,pt);case b:var Ft=st._init;return wn(me,le,be,Ft(st._payload),pt)}if(W(st)||E(st))return me=me.get(be)||null,ct(le,me,st,pt,null);mx(le,st)}return null}function xt(me,le,be,st){for(var pt=null,Ft=null,Nt=le,cn=le=0,Ws=null;Nt!==null&&cn<be.length;cn++){Nt.index>cn?(Ws=Nt,Nt=null):Ws=Nt.sibling;var un=_t(me,Nt,be[cn],st);if(un===null){Nt===null&&(Nt=Ws);break}p&&Nt&&un.alternate===null&&g(me,Nt),le=R(un,le,cn),Ft===null?pt=un:Ft.sibling=un,Ft=un,Nt=Ws}if(cn===be.length)return _(me,Nt),zn&&jc(me,cn),pt;if(Nt===null){for(;cn<be.length;cn++)Nt=At(me,be[cn],st),Nt!==null&&(le=R(Nt,le,cn),Ft===null?pt=Nt:Ft.sibling=Nt,Ft=Nt);return zn&&jc(me,cn),pt}for(Nt=T(me,Nt);cn<be.length;cn++)Ws=wn(Nt,me,cn,be[cn],st),Ws!==null&&(p&&Ws.alternate!==null&&Nt.delete(Ws.key===null?cn:Ws.key),le=R(Ws,le,cn),Ft===null?pt=Ws:Ft.sibling=Ws,Ft=Ws);return p&&Nt.forEach(function(Ll){return g(me,Ll)}),zn&&jc(me,cn),pt}function di(me,le,be,st){var pt=E(be);if(typeof pt!="function")throw Error(o(150));if(be=pt.call(be),be==null)throw Error(o(151));for(var Ft=pt=null,Nt=le,cn=le=0,Ws=null,un=be.next();Nt!==null&&!un.done;cn++,un=be.next()){Nt.index>cn?(Ws=Nt,Nt=null):Ws=Nt.sibling;var Ll=_t(me,Nt,un.value,st);if(Ll===null){Nt===null&&(Nt=Ws);break}p&&Nt&&Ll.alternate===null&&g(me,Nt),le=R(Ll,le,cn),Ft===null?pt=Ll:Ft.sibling=Ll,Ft=Ll,Nt=Ws}if(un.done)return _(me,Nt),zn&&jc(me,cn),pt;if(Nt===null){for(;!un.done;cn++,un=be.next())un=At(me,un.value,st),un!==null&&(le=R(un,le,cn),Ft===null?pt=un:Ft.sibling=un,Ft=un);return zn&&jc(me,cn),pt}for(Nt=T(me,Nt);!un.done;cn++,un=be.next())un=wn(Nt,me,cn,un.value,st),un!==null&&(p&&un.alternate!==null&&Nt.delete(un.key===null?cn:un.key),le=R(un,le,cn),Ft===null?pt=un:Ft.sibling=un,Ft=un);return p&&Nt.forEach(function(t6){return g(me,t6)}),zn&&jc(me,cn),pt}function qr(me,le,be,st){if(typeof be=="object"&&be!==null&&be.type===u&&be.key===null&&(be=be.props.children),typeof be=="object"&&be!==null){switch(be.$$typeof){case l:e:{for(var pt=be.key,Ft=le;Ft!==null;){if(Ft.key===pt){if(pt=be.type,pt===u){if(Ft.tag===7){_(me,Ft.sibling),le=M(Ft,be.props.children),le.return=me,me=le;break e}}else if(Ft.elementType===pt||typeof pt=="object"&&pt!==null&&pt.$$typeof===b&&tN(pt)===Ft.type){_(me,Ft.sibling),le=M(Ft,be.props),le.ref=np(me,Ft,be),le.return=me,me=le;break e}_(me,Ft);break}else g(me,Ft);Ft=Ft.sibling}be.type===u?(le=eu(be.props.children,me.mode,st,be.key),le.return=me,me=le):(st=Xx(be.type,be.key,be.props,null,me.mode,st),st.ref=np(me,le,be),st.return=me,me=st)}return K(me);case c:e:{for(Ft=be.key;le!==null;){if(le.key===Ft)if(le.tag===4&&le.stateNode.containerInfo===be.containerInfo&&le.stateNode.implementation===be.implementation){_(me,le.sibling),le=M(le,be.children||[]),le.return=me,me=le;break e}else{_(me,le);break}else g(me,le);le=le.sibling}le=a_(be,me.mode,st),le.return=me,me=le}return K(me);case b:return Ft=be._init,qr(me,le,Ft(be._payload),st)}if(W(be))return xt(me,le,be,st);if(E(be))return di(me,le,be,st);mx(me,be)}return typeof be=="string"&&be!==""||typeof be=="number"?(be=""+be,le!==null&&le.tag===6?(_(me,le.sibling),le=M(le,be),le.return=me,me=le):(_(me,le),le=o_(be,me.mode,st),le.return=me,me=le),K(me)):_(me,le)}return qr}var Vh=nN(!0),sN=nN(!1),sp={},Gr=zr(sp),ip=zr(sp),Wh=zr(sp);function sa(p){if(p===sp)throw Error(o(174));return p}function CS(p,g){tn(Wh,g),tn(ip,p),tn(Gr,sp),p=Y(g),Lt(Gr),tn(Gr,p)}function Gh(){Lt(Gr),Lt(ip),Lt(Wh)}function iN(p){var g=sa(Wh.current),_=sa(Gr.current);g=D(_,p.type,g),_!==g&&(tn(ip,p),tn(Gr,g))}function TS(p){ip.current===p&&(Lt(Gr),Lt(ip))}var Gn=zr(0);function gx(p){for(var g=p;g!==null;){if(g.tag===13){var _=g.memoizedState;if(_!==null&&(_=_.dehydrated,_===null||Q0(_)||Zf(_)))return g}else if(g.tag===19&&g.memoizedProps.revealOrder!==void 0){if((g.flags&128)!==0)return g}else if(g.child!==null){g.child.return=g,g=g.child;continue}if(g===p)break;for(;g.sibling===null;){if(g.return===null||g.return===p)return null;g=g.return}g.sibling.return=g.return,g=g.sibling}return null}var IS=[];function ES(){for(var p=0;p<IS.length;p++){var g=IS[p];Ee?g._workInProgressVersionPrimary=null:g._workInProgressVersionSecondary=null}IS.length=0}var xx=a.ReactCurrentDispatcher,Hr=a.ReactCurrentBatchConfig,Hh=0,Zn=null,ci=null,Vs=null,yx=!1,rp=!1,op=0,IH=0;function ui(){throw Error(o(321))}function MS(p,g){if(g===null)return!1;for(var _=0;_<g.length&&_<p.length;_++)if(!ea(p[_],g[_]))return!1;return!0}function kS(p,g,_,T,M,R){if(Hh=R,Zn=g,g.memoizedState=null,g.updateQueue=null,g.lanes=0,xx.current=p===null||p.memoizedState===null?AH:NH,p=_(T,M),rp){R=0;do{if(rp=!1,op=0,25<=R)throw Error(o(301));R+=1,Vs=ci=null,g.updateQueue=null,xx.current=RH,p=_(T,M)}while(rp)}if(xx.current=_x,g=ci!==null&&ci.next!==null,Hh=0,Vs=ci=Zn=null,yx=!1,g)throw Error(o(300));return p}function AS(){var p=op!==0;return op=0,p}function Va(){var p={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Vs===null?Zn.memoizedState=Vs=p:Vs=Vs.next=p,Vs}function ia(){if(ci===null){var p=Zn.alternate;p=p!==null?p.memoizedState:null}else p=ci.next;var g=Vs===null?Zn.memoizedState:Vs.next;if(g!==null)Vs=g,ci=p;else{if(p===null)throw Error(o(310));ci=p,p={memoizedState:ci.memoizedState,baseState:ci.baseState,baseQueue:ci.baseQueue,queue:ci.queue,next:null},Vs===null?Zn.memoizedState=Vs=p:Vs=Vs.next=p}return Vs}function qc(p,g){return typeof g=="function"?g(p):g}function vx(p){var g=ia(),_=g.queue;if(_===null)throw Error(o(311));_.lastRenderedReducer=p;var T=ci,M=T.baseQueue,R=_.pending;if(R!==null){if(M!==null){var K=M.next;M.next=R.next,R.next=K}T.baseQueue=M=R,_.pending=null}if(M!==null){R=M.next,T=T.baseState;var re=K=null,Ce=null,He=R;do{var ct=He.lane;if((Hh&ct)===ct)Ce!==null&&(Ce=Ce.next={lane:0,action:He.action,hasEagerState:He.hasEagerState,eagerState:He.eagerState,next:null}),T=He.hasEagerState?He.eagerState:p(T,He.action);else{var At={lane:ct,action:He.action,hasEagerState:He.hasEagerState,eagerState:He.eagerState,next:null};Ce===null?(re=Ce=At,K=T):Ce=Ce.next=At,Zn.lanes|=ct,jh|=ct}He=He.next}while(He!==null&&He!==R);Ce===null?K=T:Ce.next=re,ea(T,g.memoizedState)||(mr=!0),g.memoizedState=T,g.baseState=K,g.baseQueue=Ce,_.lastRenderedState=T}if(p=_.interleaved,p!==null){M=p;do R=M.lane,Zn.lanes|=R,jh|=R,M=M.next;while(M!==p)}else M===null&&(_.lanes=0);return[g.memoizedState,_.dispatch]}function wx(p){var g=ia(),_=g.queue;if(_===null)throw Error(o(311));_.lastRenderedReducer=p;var T=_.dispatch,M=_.pending,R=g.memoizedState;if(M!==null){_.pending=null;var K=M=M.next;do R=p(R,K.action),K=K.next;while(K!==M);ea(R,g.memoizedState)||(mr=!0),g.memoizedState=R,g.baseQueue===null&&(g.baseState=R),_.lastRenderedState=R}return[R,T]}function rN(){}function oN(p,g){var _=Zn,T=ia(),M=g(),R=!ea(T.memoizedState,M);if(R&&(T.memoizedState=M,mr=!0),T=T.queue,lp(cN.bind(null,_,T,p),[p]),T.getSnapshot!==g||R||Vs!==null&&Vs.memoizedState.tag&1){if(_.flags|=2048,ap(9,lN.bind(null,_,T,M,g),void 0,null),xs===null)throw Error(o(349));(Hh&30)!==0||aN(_,g,M)}return M}function aN(p,g,_){p.flags|=16384,p={getSnapshot:g,value:_},g=Zn.updateQueue,g===null?(g={lastEffect:null,stores:null},Zn.updateQueue=g,g.stores=[p]):(_=g.stores,_===null?g.stores=[p]:_.push(p))}function lN(p,g,_,T){g.value=_,g.getSnapshot=T,uN(g)&&Xr(p,1,-1)}function cN(p,g,_){return _(function(){uN(g)&&Xr(p,1,-1)})}function uN(p){var g=p.getSnapshot;p=p.value;try{var _=g();return!ea(p,_)}catch{return!0}}function NS(p){var g=Va();return typeof p=="function"&&(p=p()),g.memoizedState=g.baseState=p,p={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:qc,lastRenderedState:p},g.queue=p,p=p.dispatch=kH.bind(null,Zn,p),[g.memoizedState,p]}function ap(p,g,_,T){return p={tag:p,create:g,destroy:_,deps:T,next:null},g=Zn.updateQueue,g===null?(g={lastEffect:null,stores:null},Zn.updateQueue=g,g.lastEffect=p.next=p):(_=g.lastEffect,_===null?g.lastEffect=p.next=p:(T=_.next,_.next=p,p.next=T,g.lastEffect=p)),p}function hN(){return ia().memoizedState}function bx(p,g,_,T){var M=Va();Zn.flags|=p,M.memoizedState=ap(1|g,_,void 0,T===void 0?null:T)}function Sx(p,g,_,T){var M=ia();T=T===void 0?null:T;var R=void 0;if(ci!==null){var K=ci.memoizedState;if(R=K.destroy,T!==null&&MS(T,K.deps)){M.memoizedState=ap(g,_,R,T);return}}Zn.flags|=p,M.memoizedState=ap(1|g,_,R,T)}function RS(p,g){return bx(8390656,8,p,g)}function lp(p,g){return Sx(2048,8,p,g)}function dN(p,g){return Sx(4,2,p,g)}function fN(p,g){return Sx(4,4,p,g)}function pN(p,g){if(typeof g=="function")return p=p(),g(p),function(){g(null)};if(g!=null)return p=p(),g.current=p,function(){g.current=null}}function mN(p,g,_){return _=_!=null?_.concat([p]):null,Sx(4,4,pN.bind(null,g,p),_)}function DS(){}function gN(p,g){var _=ia();g=g===void 0?null:g;var T=_.memoizedState;return T!==null&&g!==null&&MS(g,T[1])?T[0]:(_.memoizedState=[p,g],p)}function xN(p,g){var _=ia();g=g===void 0?null:g;var T=_.memoizedState;return T!==null&&g!==null&&MS(g,T[1])?T[0]:(p=p(),_.memoizedState=[p,g],p)}function EH(p,g){var _=ln;ln=_!==0&&4>_?_:4,p(!0);var T=Hr.transition;Hr.transition={};try{p(!1),g()}finally{ln=_,Hr.transition=T}}function yN(){return ia().memoizedState}function MH(p,g,_){var T=Nl(p);_={lane:T,action:_,hasEagerState:!1,eagerState:null,next:null},vN(p)?wN(g,_):(bN(p,g,_),_=Ni(),p=Xr(p,T,_),p!==null&&SN(p,g,T))}function kH(p,g,_){var T=Nl(p),M={lane:T,action:_,hasEagerState:!1,eagerState:null,next:null};if(vN(p))wN(g,M);else{bN(p,g,M);var R=p.alternate;if(p.lanes===0&&(R===null||R.lanes===0)&&(R=g.lastRenderedReducer,R!==null))try{var K=g.lastRenderedState,re=R(K,_);if(M.hasEagerState=!0,M.eagerState=re,ea(re,K))return}catch{}finally{}_=Ni(),p=Xr(p,T,_),p!==null&&SN(p,g,T)}}function vN(p){var g=p.alternate;return p===Zn||g!==null&&g===Zn}function wN(p,g){rp=yx=!0;var _=p.pending;_===null?g.next=g:(g.next=_.next,_.next=g),p.pending=g}function bN(p,g,_){xs!==null&&(p.mode&1)!==0&&(Wt&2)===0?(p=g.interleaved,p===null?(_.next=_,na===null?na=[g]:na.push(g)):(_.next=p.next,p.next=_),g.interleaved=_):(p=g.pending,p===null?_.next=_:(_.next=p.next,p.next=_),g.pending=_)}function SN(p,g,_){if((_&4194240)!==0){var T=g.lanes;T&=p.pendingLanes,_|=T,g.lanes=_,aS(p,_)}}var _x={readContext:Ur,useCallback:ui,useContext:ui,useEffect:ui,useImperativeHandle:ui,useInsertionEffect:ui,useLayoutEffect:ui,useMemo:ui,useReducer:ui,useRef:ui,useState:ui,useDebugValue:ui,useDeferredValue:ui,useTransition:ui,useMutableSource:ui,useSyncExternalStore:ui,useId:ui,unstable_isNewReconciler:!1},AH={readContext:Ur,useCallback:function(p,g){return Va().memoizedState=[p,g===void 0?null:g],p},useContext:Ur,useEffect:RS,useImperativeHandle:function(p,g,_){return _=_!=null?_.concat([p]):null,bx(4194308,4,pN.bind(null,g,p),_)},useLayoutEffect:function(p,g){return bx(4194308,4,p,g)},useInsertionEffect:function(p,g){return bx(4,2,p,g)},useMemo:function(p,g){var _=Va();return g=g===void 0?null:g,p=p(),_.memoizedState=[p,g],p},useReducer:function(p,g,_){var T=Va();return g=_!==void 0?_(g):g,T.memoizedState=T.baseState=g,p={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:p,lastRenderedState:g},T.queue=p,p=p.dispatch=MH.bind(null,Zn,p),[T.memoizedState,p]},useRef:function(p){var g=Va();return p={current:p},g.memoizedState=p},useState:NS,useDebugValue:DS,useDeferredValue:function(p){var g=NS(p),_=g[0],T=g[1];return RS(function(){var M=Hr.transition;Hr.transition={};try{T(p)}finally{Hr.transition=M}},[p]),_},useTransition:function(){var p=NS(!1),g=p[0];return p=EH.bind(null,p[1]),Va().memoizedState=p,[g,p]},useMutableSource:function(){},useSyncExternalStore:function(p,g,_){var T=Zn,M=Va();if(zn){if(_===void 0)throw Error(o(407));_=_()}else{if(_=g(),xs===null)throw Error(o(349));(Hh&30)!==0||aN(T,g,_)}M.memoizedState=_;var R={value:_,getSnapshot:g};return M.queue=R,RS(cN.bind(null,T,R,p),[p]),T.flags|=2048,ap(9,lN.bind(null,T,R,_,g),void 0,null),_},useId:function(){var p=Va(),g=xs.identifierPrefix;if(zn){var _=Ua,T=Ba;_=(T&~(1<<32-wo(T)-1)).toString(32)+_,g=":"+g+"R"+_,_=op++,0<_&&(g+="H"+_.toString(32)),g+=":"}else _=IH++,g=":"+g+"r"+_.toString(32)+":";return p.memoizedState=g},unstable_isNewReconciler:!1},NH={readContext:Ur,useCallback:gN,useContext:Ur,useEffect:lp,useImperativeHandle:mN,useInsertionEffect:dN,useLayoutEffect:fN,useMemo:xN,useReducer:vx,useRef:hN,useState:function(){return vx(qc)},useDebugValue:DS,useDeferredValue:function(p){var g=vx(qc),_=g[0],T=g[1];return lp(function(){var M=Hr.transition;Hr.transition={};try{T(p)}finally{Hr.transition=M}},[p]),_},useTransition:function(){var p=vx(qc)[0],g=ia().memoizedState;return[p,g]},useMutableSource:rN,useSyncExternalStore:oN,useId:yN,unstable_isNewReconciler:!1},RH={readContext:Ur,useCallback:gN,useContext:Ur,useEffect:lp,useImperativeHandle:mN,useInsertionEffect:dN,useLayoutEffect:fN,useMemo:xN,useReducer:wx,useRef:hN,useState:function(){return wx(qc)},useDebugValue:DS,useDeferredValue:function(p){var g=wx(qc),_=g[0],T=g[1];return lp(function(){var M=Hr.transition;Hr.transition={};try{T(p)}finally{Hr.transition=M}},[p]),_},useTransition:function(){var p=wx(qc)[0],g=ia().memoizedState;return[p,g]},useMutableSource:rN,useSyncExternalStore:oN,useId:yN,unstable_isNewReconciler:!1};function LS(p,g){try{var _="",T=g;do _+=TH(T),T=T.return;while(T);var M=_}catch(R){M=`
Error generating stack: `+R.message+`
`+R.stack}return{value:p,source:g,stack:M}}function PS(p,g){try{console.error(g.value)}catch(_){setTimeout(function(){throw _})}}var DH=typeof WeakMap=="function"?WeakMap:Map;function _N(p,g,_){_=za(-1,_),_.tag=3,_.payload={element:null};var T=g.value;return _.callback=function(){zx||(zx=!0,QS=T),PS(p,g)},_}function CN(p,g,_){_=za(-1,_),_.tag=3;var T=p.type.getDerivedStateFromError;if(typeof T=="function"){var M=g.value;_.payload=function(){return T(M)},_.callback=function(){PS(p,g)}}var R=p.stateNode;return R!==null&&typeof R.componentDidCatch=="function"&&(_.callback=function(){PS(p,g),typeof T!="function"&&(kl===null?kl=new Set([this]):kl.add(this));var K=g.stack;this.componentDidCatch(g.value,{componentStack:K!==null?K:""})}),_}function TN(p,g,_){var T=p.pingCache;if(T===null){T=p.pingCache=new DH;var M=new Set;T.set(g,M)}else M=T.get(g),M===void 0&&(M=new Set,T.set(g,M));M.has(_)||(M.add(_),p=jH.bind(null,p,g,_),g.then(p,p))}function IN(p){do{var g;if((g=p.tag===13)&&(g=p.memoizedState,g=g!==null?g.dehydrated!==null:!0),g)return p;p=p.return}while(p!==null);return null}function EN(p,g,_,T,M){return(p.mode&1)===0?(p===g?p.flags|=65536:(p.flags|=128,_.flags|=131072,_.flags&=-52805,_.tag===1&&(_.alternate===null?_.tag=17:(g=za(-1,1),g.tag=2,Ml(_,g))),_.lanes|=1),p):(p.flags|=65536,p.lanes=M,p)}function ra(p){p.flags|=4}function MN(p,g){if(p!==null&&p.child===g.child)return!0;if((g.flags&16)!==0)return!1;for(p=g.child;p!==null;){if((p.flags&12854)!==0||(p.subtreeFlags&12854)!==0)return!1;p=p.sibling}return!0}var cp,up,Cx,Tx;if(Be)cp=function(p,g){for(var _=g.child;_!==null;){if(_.tag===5||_.tag===6)X(p,_.stateNode);else if(_.tag!==4&&_.child!==null){_.child.return=_,_=_.child;continue}if(_===g)break;for(;_.sibling===null;){if(_.return===null||_.return===g)return;_=_.return}_.sibling.return=_.return,_=_.sibling}},up=function(){},Cx=function(p,g,_,T,M){if(p=p.memoizedProps,p!==T){var R=g.stateNode,K=sa(Gr.current);_=oe(R,_,p,T,M,K),(g.updateQueue=_)&&ra(g)}},Tx=function(p,g,_,T){_!==T&&ra(g)};else if(ye){cp=function(p,g,_,T){for(var M=g.child;M!==null;){if(M.tag===5){var R=M.stateNode;_&&T&&(R=vn(R,M.type,M.memoizedProps,M)),X(p,R)}else if(M.tag===6)R=M.stateNode,_&&T&&(R=Fr(R,M.memoizedProps,M)),X(p,R);else if(M.tag!==4){if(M.tag===22&&M.memoizedState!==null)R=M.child,R!==null&&(R.return=M),cp(p,M,!0,!0);else if(M.child!==null){M.child.return=M,M=M.child;continue}}if(M===g)break;for(;M.sibling===null;){if(M.return===null||M.return===g)return;M=M.return}M.sibling.return=M.return,M=M.sibling}};var kN=function(p,g,_,T){for(var M=g.child;M!==null;){if(M.tag===5){var R=M.stateNode;_&&T&&(R=vn(R,M.type,M.memoizedProps,M)),os(p,R)}else if(M.tag===6)R=M.stateNode,_&&T&&(R=Fr(R,M.memoizedProps,M)),os(p,R);else if(M.tag!==4){if(M.tag===22&&M.memoizedState!==null)R=M.child,R!==null&&(R.return=M),kN(p,M,!0,!0);else if(M.child!==null){M.child.return=M,M=M.child;continue}}if(M===g)break;for(;M.sibling===null;){if(M.return===null||M.return===g)return;M=M.return}M.sibling.return=M.return,M=M.sibling}};up=function(p,g){var _=g.stateNode;if(!MN(p,g)){p=_.containerInfo;var T=nn(p);kN(T,g,!1,!1),_.pendingChildren=T,ra(g),zs(p,T)}},Cx=function(p,g,_,T,M){var R=p.stateNode,K=p.memoizedProps;if((p=MN(p,g))&&K===T)g.stateNode=R;else{var re=g.stateNode,Ce=sa(Gr.current),He=null;K!==T&&(He=oe(re,_,K,T,M,Ce)),p&&He===null?g.stateNode=R:(R=gt(R,He,_,K,T,g,p,re),te(R,_,T,M,Ce)&&ra(g),g.stateNode=R,p?ra(g):cp(R,g,!1,!1))}},Tx=function(p,g,_,T){_!==T?(p=sa(Wh.current),_=sa(Gr.current),g.stateNode=Q(T,p,_,g),ra(g)):g.stateNode=p.stateNode}}else up=function(){},Cx=function(){},Tx=function(){};function hp(p,g){if(!zn)switch(p.tailMode){case"hidden":g=p.tail;for(var _=null;g!==null;)g.alternate!==null&&(_=g),g=g.sibling;_===null?p.tail=null:_.sibling=null;break;case"collapsed":_=p.tail;for(var T=null;_!==null;)_.alternate!==null&&(T=_),_=_.sibling;T===null?g||p.tail===null?p.tail=null:p.tail.sibling=null:T.sibling=null}}function hi(p){var g=p.alternate!==null&&p.alternate.child===p.child,_=0,T=0;if(g)for(var M=p.child;M!==null;)_|=M.lanes|M.childLanes,T|=M.subtreeFlags&14680064,T|=M.flags&14680064,M.return=p,M=M.sibling;else for(M=p.child;M!==null;)_|=M.lanes|M.childLanes,T|=M.subtreeFlags,T|=M.flags,M.return=p,M=M.sibling;return p.subtreeFlags|=T,p.childLanes=_,g}function LH(p,g,_){var T=g.pendingProps;switch(wS(g),g.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return hi(g),null;case 1:return Ki(g.type)&&ex(),hi(g),null;case 3:return T=g.stateNode,Gh(),Lt(Bs),Lt(mn),ES(),T.pendingContext&&(T.context=T.pendingContext,T.pendingContext=null),(p===null||p.child===null)&&(tp(g)?ra(g):p===null||p.memoizedState.isDehydrated&&(g.flags&256)===0||(g.flags|=1024,So!==null&&(n_(So),So=null))),up(p,g),hi(g),null;case 5:TS(g),_=sa(Wh.current);var M=g.type;if(p!==null&&g.stateNode!=null)Cx(p,g,M,T,_),p.ref!==g.ref&&(g.flags|=512,g.flags|=2097152);else{if(!T){if(g.stateNode===null)throw Error(o(166));return hi(g),null}if(p=sa(Gr.current),tp(g)){if(!fe)throw Error(o(175));p=wt(g.stateNode,g.type,g.memoizedProps,_,p,g,!ep),g.updateQueue=p,p!==null&&ra(g)}else{var R=B(M,T,_,p,g);cp(R,g,!1,!1),g.stateNode=R,te(R,M,T,_,p)&&ra(g)}g.ref!==null&&(g.flags|=512,g.flags|=2097152)}return hi(g),null;case 6:if(p&&g.stateNode!=null)Tx(p,g,p.memoizedProps,T);else{if(typeof T!="string"&&g.stateNode===null)throw Error(o(166));if(p=sa(Wh.current),_=sa(Gr.current),tp(g)){if(!fe)throw Error(o(176));if(p=g.stateNode,T=g.memoizedProps,(_=It(p,T,g,!ep))&&(M=fr,M!==null))switch(R=(M.mode&1)!==0,M.tag){case 3:vo(M.stateNode.containerInfo,p,T,R);break;case 5:La(M.type,M.memoizedProps,M.stateNode,p,T,R)}_&&ra(g)}else g.stateNode=Q(T,p,_,g)}return hi(g),null;case 13:if(Lt(Gn),T=g.memoizedState,zn&&pr!==null&&(g.mode&1)!==0&&(g.flags&128)===0){for(p=pr;p;)p=pe(p);return Uh(),g.flags|=98560,g}if(T!==null&&T.dehydrated!==null){if(T=tp(g),p===null){if(!T)throw Error(o(318));if(!fe)throw Error(o(344));if(p=g.memoizedState,p=p!==null?p.dehydrated:null,!p)throw Error(o(317));Pt(p,g)}else Uh(),(g.flags&128)===0&&(g.memoizedState=null),g.flags|=4;return hi(g),null}return So!==null&&(n_(So),So=null),(g.flags&128)!==0?(g.lanes=_,g):(T=T!==null,_=!1,p===null?tp(g):_=p.memoizedState!==null,T&&!_&&(g.child.flags|=8192,(g.mode&1)!==0&&(p===null||(Gn.current&1)!==0?Es===0&&(Es=3):i_())),g.updateQueue!==null&&(g.flags|=4),hi(g),null);case 4:return Gh(),up(p,g),p===null&&We(g.stateNode.containerInfo),hi(g),null;case 10:return pS(g.type._context),hi(g),null;case 17:return Ki(g.type)&&ex(),hi(g),null;case 19:if(Lt(Gn),M=g.memoizedState,M===null)return hi(g),null;if(T=(g.flags&128)!==0,R=M.rendering,R===null)if(T)hp(M,!1);else{if(Es!==0||p!==null&&(p.flags&128)!==0)for(p=g.child;p!==null;){if(R=gx(p),R!==null){for(g.flags|=128,hp(M,!1),p=R.updateQueue,p!==null&&(g.updateQueue=p,g.flags|=4),g.subtreeFlags=0,p=_,T=g.child;T!==null;)_=T,M=p,_.flags&=14680066,R=_.alternate,R===null?(_.childLanes=0,_.lanes=M,_.child=null,_.subtreeFlags=0,_.memoizedProps=null,_.memoizedState=null,_.updateQueue=null,_.dependencies=null,_.stateNode=null):(_.childLanes=R.childLanes,_.lanes=R.lanes,_.child=R.child,_.subtreeFlags=0,_.deletions=null,_.memoizedProps=R.memoizedProps,_.memoizedState=R.memoizedState,_.updateQueue=R.updateQueue,_.type=R.type,M=R.dependencies,_.dependencies=M===null?null:{lanes:M.lanes,firstContext:M.firstContext}),T=T.sibling;return tn(Gn,Gn.current&1|2),g.child}p=p.sibling}M.tail!==null&&Us()>JS&&(g.flags|=128,T=!0,hp(M,!1),g.lanes=4194304)}else{if(!T)if(p=gx(R),p!==null){if(g.flags|=128,T=!0,p=p.updateQueue,p!==null&&(g.updateQueue=p,g.flags|=4),hp(M,!0),M.tail===null&&M.tailMode==="hidden"&&!R.alternate&&!zn)return hi(g),null}else 2*Us()-M.renderingStartTime>JS&&_!==1073741824&&(g.flags|=128,T=!0,hp(M,!1),g.lanes=4194304);M.isBackwards?(R.sibling=g.child,g.child=R):(p=M.last,p!==null?p.sibling=R:g.child=R,M.last=R)}return M.tail!==null?(g=M.tail,M.rendering=g,M.tail=g.sibling,M.renderingStartTime=Us(),g.sibling=null,p=Gn.current,tn(Gn,T?p&1|2:p&1),g):(hi(g),null);case 22:case 23:return s_(),T=g.memoizedState!==null,p!==null&&p.memoizedState!==null!==T&&(g.flags|=8192),T&&(g.mode&1)!==0?(gr&1073741824)!==0&&(hi(g),Be&&g.subtreeFlags&6&&(g.flags|=8192)):hi(g),null;case 24:return null;case 25:return null}throw Error(o(156,g.tag))}var PH=a.ReactCurrentOwner,mr=!1;function Ai(p,g,_,T){g.child=p===null?sN(g,null,_,T):Vh(g,p.child,_,T)}function AN(p,g,_,T,M){_=_.render;var R=g.ref;return Oh(g,M),T=kS(p,g,_,T,R,M),_=AS(),p!==null&&!mr?(g.updateQueue=p.updateQueue,g.flags&=-2053,p.lanes&=~M,Wa(p,g,M)):(zn&&_&&vS(g),g.flags|=1,Ai(p,g,T,M),g.child)}function NN(p,g,_,T,M){if(p===null){var R=_.type;return typeof R=="function"&&!r_(R)&&R.defaultProps===void 0&&_.compare===null&&_.defaultProps===void 0?(g.tag=15,g.type=R,RN(p,g,R,T,M)):(p=Xx(_.type,null,T,g,g.mode,M),p.ref=g.ref,p.return=g,g.child=p)}if(R=p.child,(p.lanes&M)===0){var K=R.memoizedProps;if(_=_.compare,_=_!==null?_:ax,_(K,T)&&p.ref===g.ref)return Wa(p,g,M)}return g.flags|=1,p=Dl(R,T),p.ref=g.ref,p.return=g,g.child=p}function RN(p,g,_,T,M){if(p!==null&&ax(p.memoizedProps,T)&&p.ref===g.ref)if(mr=!1,(p.lanes&M)!==0)(p.flags&131072)!==0&&(mr=!0);else return g.lanes=p.lanes,Wa(p,g,M);return $S(p,g,_,T,M)}function DN(p,g,_){var T=g.pendingProps,M=T.children,R=p!==null?p.memoizedState:null;if(T.mode==="hidden")if((g.mode&1)===0)g.memoizedState={baseLanes:0,cachePool:null},tn(Xh,gr),gr|=_;else if((_&1073741824)!==0)g.memoizedState={baseLanes:0,cachePool:null},T=R!==null?R.baseLanes:_,tn(Xh,gr),gr|=T;else return p=R!==null?R.baseLanes|_:_,g.lanes=g.childLanes=1073741824,g.memoizedState={baseLanes:p,cachePool:null},g.updateQueue=null,tn(Xh,gr),gr|=p,null;else R!==null?(T=R.baseLanes|_,g.memoizedState=null):T=_,tn(Xh,gr),gr|=T;return Ai(p,g,M,_),g.child}function LN(p,g){var _=g.ref;(p===null&&_!==null||p!==null&&p.ref!==_)&&(g.flags|=512,g.flags|=2097152)}function $S(p,g,_,T,M){var R=Ki(_)?$a:mn.current;return R=Fa(g,R),Oh(g,M),_=kS(p,g,_,T,R,M),T=AS(),p!==null&&!mr?(g.updateQueue=p.updateQueue,g.flags&=-2053,p.lanes&=~M,Wa(p,g,M)):(zn&&T&&vS(g),g.flags|=1,Ai(p,g,_,M),g.child)}function PN(p,g,_,T,M){if(Ki(_)){var R=!0;tx(g)}else R=!1;if(Oh(g,M),g.stateNode===null)p!==null&&(p.alternate=null,g.alternate=null,g.flags|=2),KA(g,_,T),yS(g,_,T,M),T=!0;else if(p===null){var K=g.stateNode,re=g.memoizedProps;K.props=re;var Ce=K.context,He=_.contextType;typeof He=="object"&&He!==null?He=Ur(He):(He=Ki(_)?$a:mn.current,He=Fa(g,He));var ct=_.getDerivedStateFromProps,At=typeof ct=="function"||typeof K.getSnapshotBeforeUpdate=="function";At||typeof K.UNSAFE_componentWillReceiveProps!="function"&&typeof K.componentWillReceiveProps!="function"||(re!==T||Ce!==He)&&YA(g,K,T,He),El=!1;var _t=g.memoizedState;K.state=_t,hx(g,T,K,M),Ce=g.memoizedState,re!==T||_t!==Ce||Bs.current||El?(typeof ct=="function"&&(xS(g,_,ct,T),Ce=g.memoizedState),(re=El||qA(g,_,re,T,_t,Ce,He))?(At||typeof K.UNSAFE_componentWillMount!="function"&&typeof K.componentWillMount!="function"||(typeof K.componentWillMount=="function"&&K.componentWillMount(),typeof K.UNSAFE_componentWillMount=="function"&&K.UNSAFE_componentWillMount()),typeof K.componentDidMount=="function"&&(g.flags|=4194308)):(typeof K.componentDidMount=="function"&&(g.flags|=4194308),g.memoizedProps=T,g.memoizedState=Ce),K.props=T,K.state=Ce,K.context=He,T=re):(typeof K.componentDidMount=="function"&&(g.flags|=4194308),T=!1)}else{K=g.stateNode,GA(p,g),re=g.memoizedProps,He=g.type===g.elementType?re:bo(g.type,re),K.props=He,At=g.pendingProps,_t=K.context,Ce=_.contextType,typeof Ce=="object"&&Ce!==null?Ce=Ur(Ce):(Ce=Ki(_)?$a:mn.current,Ce=Fa(g,Ce));var wn=_.getDerivedStateFromProps;(ct=typeof wn=="function"||typeof K.getSnapshotBeforeUpdate=="function")||typeof K.UNSAFE_componentWillReceiveProps!="function"&&typeof K.componentWillReceiveProps!="function"||(re!==At||_t!==Ce)&&YA(g,K,T,Ce),El=!1,_t=g.memoizedState,K.state=_t,hx(g,T,K,M);var xt=g.memoizedState;re!==At||_t!==xt||Bs.current||El?(typeof wn=="function"&&(xS(g,_,wn,T),xt=g.memoizedState),(He=El||qA(g,_,He,T,_t,xt,Ce)||!1)?(ct||typeof K.UNSAFE_componentWillUpdate!="function"&&typeof K.componentWillUpdate!="function"||(typeof K.componentWillUpdate=="function"&&K.componentWillUpdate(T,xt,Ce),typeof K.UNSAFE_componentWillUpdate=="function"&&K.UNSAFE_componentWillUpdate(T,xt,Ce)),typeof K.componentDidUpdate=="function"&&(g.flags|=4),typeof K.getSnapshotBeforeUpdate=="function"&&(g.flags|=1024)):(typeof K.componentDidUpdate!="function"||re===p.memoizedProps&&_t===p.memoizedState||(g.flags|=4),typeof K.getSnapshotBeforeUpdate!="function"||re===p.memoizedProps&&_t===p.memoizedState||(g.flags|=1024),g.memoizedProps=T,g.memoizedState=xt),K.props=T,K.state=xt,K.context=Ce,T=He):(typeof K.componentDidUpdate!="function"||re===p.memoizedProps&&_t===p.memoizedState||(g.flags|=4),typeof K.getSnapshotBeforeUpdate!="function"||re===p.memoizedProps&&_t===p.memoizedState||(g.flags|=1024),T=!1)}return FS(p,g,_,T,R,M)}function FS(p,g,_,T,M,R){LN(p,g);var K=(g.flags&128)!==0;if(!T&&!K)return M&&zA(g,_,!1),Wa(p,g,R);T=g.stateNode,PH.current=g;var re=K&&typeof _.getDerivedStateFromError!="function"?null:T.render();return g.flags|=1,p!==null&&K?(g.child=Vh(g,p.child,null,R),g.child=Vh(g,null,re,R)):Ai(p,g,re,R),g.memoizedState=T.state,M&&zA(g,_,!0),g.child}function $N(p){var g=p.stateNode;g.pendingContext?FA(p,g.pendingContext,g.pendingContext!==g.context):g.context&&FA(p,g.context,!1),CS(p,g.containerInfo)}function FN(p,g,_,T,M){return Uh(),_S(M),g.flags|=256,Ai(p,g,_,T),g.child}var Ix={dehydrated:null,treeContext:null,retryLane:0};function Ex(p){return{baseLanes:p,cachePool:null}}function ON(p,g,_){var T=g.pendingProps,M=Gn.current,R=!1,K=(g.flags&128)!==0,re;if((re=K)||(re=p!==null&&p.memoizedState===null?!1:(M&2)!==0),re?(R=!0,g.flags&=-129):(p===null||p.memoizedState!==null)&&(M|=1),tn(Gn,M&1),p===null)return SS(g),p=g.memoizedState,p!==null&&(p=p.dehydrated,p!==null)?((g.mode&1)===0?g.lanes=1:Zf(p)?g.lanes=8:g.lanes=1073741824,null):(M=T.children,p=T.fallback,R?(T=g.mode,R=g.child,M={mode:"hidden",children:M},(T&1)===0&&R!==null?(R.childLanes=0,R.pendingProps=M):R=jx(M,T,0,null),p=eu(p,T,_,null),R.return=g,p.return=g,R.sibling=p,g.child=R,g.child.memoizedState=Ex(_),g.memoizedState=Ix,p):OS(g,M));if(M=p.memoizedState,M!==null){if(re=M.dehydrated,re!==null){if(K)return g.flags&256?(g.flags&=-257,Mx(p,g,_,Error(o(422)))):g.memoizedState!==null?(g.child=p.child,g.flags|=128,null):(R=T.fallback,M=g.mode,T=jx({mode:"visible",children:T.children},M,0,null),R=eu(R,M,_,null),R.flags|=2,T.return=g,R.return=g,T.sibling=R,g.child=T,(g.mode&1)!==0&&Vh(g,p.child,null,_),g.child.memoizedState=Ex(_),g.memoizedState=Ix,R);if((g.mode&1)===0)g=Mx(p,g,_,null);else if(Zf(re))g=Mx(p,g,_,Error(o(419)));else if(T=(_&p.childLanes)!==0,mr||T){if(T=xs,T!==null){switch(_&-_){case 4:R=2;break;case 16:R=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:R=32;break;case 536870912:R=268435456;break;default:R=0}T=(R&(T.suspendedLanes|_))!==0?0:R,T!==0&&T!==M.retryLane&&(M.retryLane=T,Xr(p,T,-1))}i_(),g=Mx(p,g,_,Error(o(421)))}else Q0(re)?(g.flags|=128,g.child=p.child,g=qH.bind(null,p),j(re,g),g=null):(_=M.treeContext,fe&&(pr=Ne(re),fr=g,zn=!0,So=null,ep=!1,_!==null&&(Vr[Wr++]=Ba,Vr[Wr++]=Ua,Vr[Wr++]=Xc,Ba=_.id,Ua=_.overflow,Xc=g)),g=OS(g,g.pendingProps.children),g.flags|=4096);return g}return R?(T=BN(p,g,T.children,T.fallback,_),R=g.child,M=p.child.memoizedState,R.memoizedState=M===null?Ex(_):{baseLanes:M.baseLanes|_,cachePool:null},R.childLanes=p.childLanes&~_,g.memoizedState=Ix,T):(_=zN(p,g,T.children,_),g.memoizedState=null,_)}return R?(T=BN(p,g,T.children,T.fallback,_),R=g.child,M=p.child.memoizedState,R.memoizedState=M===null?Ex(_):{baseLanes:M.baseLanes|_,cachePool:null},R.childLanes=p.childLanes&~_,g.memoizedState=Ix,T):(_=zN(p,g,T.children,_),g.memoizedState=null,_)}function OS(p,g){return g=jx({mode:"visible",children:g},p.mode,0,null),g.return=p,p.child=g}function zN(p,g,_,T){var M=p.child;return p=M.sibling,_=Dl(M,{mode:"visible",children:_}),(g.mode&1)===0&&(_.lanes=T),_.return=g,_.sibling=null,p!==null&&(T=g.deletions,T===null?(g.deletions=[p],g.flags|=16):T.push(p)),g.child=_}function BN(p,g,_,T,M){var R=g.mode;p=p.child;var K=p.sibling,re={mode:"hidden",children:_};return(R&1)===0&&g.child!==p?(_=g.child,_.childLanes=0,_.pendingProps=re,g.deletions=null):(_=Dl(p,re),_.subtreeFlags=p.subtreeFlags&14680064),K!==null?T=Dl(K,T):(T=eu(T,R,M,null),T.flags|=2),T.return=g,_.return=g,_.sibling=T,g.child=_,T}function Mx(p,g,_,T){return T!==null&&_S(T),Vh(g,p.child,null,_),p=OS(g,g.pendingProps.children),p.flags|=2,g.memoizedState=null,p}function UN(p,g,_){p.lanes|=g;var T=p.alternate;T!==null&&(T.lanes|=g),mS(p.return,g,_)}function zS(p,g,_,T,M){var R=p.memoizedState;R===null?p.memoizedState={isBackwards:g,rendering:null,renderingStartTime:0,last:T,tail:_,tailMode:M}:(R.isBackwards=g,R.rendering=null,R.renderingStartTime=0,R.last=T,R.tail=_,R.tailMode=M)}function VN(p,g,_){var T=g.pendingProps,M=T.revealOrder,R=T.tail;if(Ai(p,g,T.children,_),T=Gn.current,(T&2)!==0)T=T&1|2,g.flags|=128;else{if(p!==null&&(p.flags&128)!==0)e:for(p=g.child;p!==null;){if(p.tag===13)p.memoizedState!==null&&UN(p,_,g);else if(p.tag===19)UN(p,_,g);else if(p.child!==null){p.child.return=p,p=p.child;continue}if(p===g)break e;for(;p.sibling===null;){if(p.return===null||p.return===g)break e;p=p.return}p.sibling.return=p.return,p=p.sibling}T&=1}if(tn(Gn,T),(g.mode&1)===0)g.memoizedState=null;else switch(M){case"forwards":for(_=g.child,M=null;_!==null;)p=_.alternate,p!==null&&gx(p)===null&&(M=_),_=_.sibling;_=M,_===null?(M=g.child,g.child=null):(M=_.sibling,_.sibling=null),zS(g,!1,M,_,R);break;case"backwards":for(_=null,M=g.child,g.child=null;M!==null;){if(p=M.alternate,p!==null&&gx(p)===null){g.child=M;break}p=M.sibling,M.sibling=_,_=M,M=p}zS(g,!0,_,null,R);break;case"together":zS(g,!1,null,null,void 0);break;default:g.memoizedState=null}return g.child}function Wa(p,g,_){if(p!==null&&(g.dependencies=p.dependencies),jh|=g.lanes,(_&g.childLanes)===0)return null;if(p!==null&&g.child!==p.child)throw Error(o(153));if(g.child!==null){for(p=g.child,_=Dl(p,p.pendingProps),g.child=_,_.return=g;p.sibling!==null;)p=p.sibling,_=_.sibling=Dl(p,p.pendingProps),_.return=g;_.sibling=null}return g.child}function $H(p,g,_){switch(g.tag){case 3:$N(g),Uh();break;case 5:iN(g);break;case 1:Ki(g.type)&&tx(g);break;case 4:CS(g,g.stateNode.containerInfo);break;case 10:WA(g,g.type._context,g.memoizedProps.value);break;case 13:var T=g.memoizedState;if(T!==null)return T.dehydrated!==null?(tn(Gn,Gn.current&1),g.flags|=128,null):(_&g.child.childLanes)!==0?ON(p,g,_):(tn(Gn,Gn.current&1),p=Wa(p,g,_),p!==null?p.sibling:null);tn(Gn,Gn.current&1);break;case 19:if(T=(_&g.childLanes)!==0,(p.flags&128)!==0){if(T)return VN(p,g,_);g.flags|=128}var M=g.memoizedState;if(M!==null&&(M.rendering=null,M.tail=null,M.lastEffect=null),tn(Gn,Gn.current),T)break;return null;case 22:case 23:return g.lanes=0,DN(p,g,_)}return Wa(p,g,_)}function FH(p,g){switch(wS(g),g.tag){case 1:return Ki(g.type)&&ex(),p=g.flags,p&65536?(g.flags=p&-65537|128,g):null;case 3:return Gh(),Lt(Bs),Lt(mn),ES(),p=g.flags,(p&65536)!==0&&(p&128)===0?(g.flags=p&-65537|128,g):null;case 5:return TS(g),null;case 13:if(Lt(Gn),p=g.memoizedState,p!==null&&p.dehydrated!==null){if(g.alternate===null)throw Error(o(340));Uh()}return p=g.flags,p&65536?(g.flags=p&-65537|128,g):null;case 19:return Lt(Gn),null;case 4:return Gh(),null;case 10:return pS(g.type._context),null;case 22:case 23:return s_(),null;case 24:return null;default:return null}}var kx=!1,Kc=!1,OH=typeof WeakSet=="function"?WeakSet:Set,et=null;function Ax(p,g){var _=p.ref;if(_!==null)if(typeof _=="function")try{_(null)}catch(T){Ji(p,g,T)}else _.current=null}function BS(p,g,_){try{_()}catch(T){Ji(p,g,T)}}var WN=!1;function zH(p,g){for($(p.containerInfo),et=g;et!==null;)if(p=et,g=p.child,(p.subtreeFlags&1028)!==0&&g!==null)g.return=p,et=g;else for(;et!==null;){p=et;try{var _=p.alternate;if((p.flags&1024)!==0)switch(p.tag){case 0:case 11:case 15:break;case 1:if(_!==null){var T=_.memoizedProps,M=_.memoizedState,R=p.stateNode,K=R.getSnapshotBeforeUpdate(p.elementType===p.type?T:bo(p.type,T),M);R.__reactInternalSnapshotBeforeUpdate=K}break;case 3:Be&&rt(p.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(o(163))}}catch(re){Ji(p,p.return,re)}if(g=p.sibling,g!==null){g.return=p.return,et=g;break}et=p.return}return _=WN,WN=!1,_}function Yc(p,g,_){var T=g.updateQueue;if(T=T!==null?T.lastEffect:null,T!==null){var M=T=T.next;do{if((M.tag&p)===p){var R=M.destroy;M.destroy=void 0,R!==void 0&&BS(g,_,R)}M=M.next}while(M!==T)}}function dp(p,g){if(g=g.updateQueue,g=g!==null?g.lastEffect:null,g!==null){var _=g=g.next;do{if((_.tag&p)===p){var T=_.create;_.destroy=T()}_=_.next}while(_!==g)}}function US(p){var g=p.ref;if(g!==null){var _=p.stateNode;switch(p.tag){case 5:p=H(_);break;default:p=_}typeof g=="function"?g(p):g.current=p}}function GN(p,g,_){if(Qo&&typeof Qo.onCommitFiberUnmount=="function")try{Qo.onCommitFiberUnmount(rx,g)}catch{}switch(g.tag){case 0:case 11:case 14:case 15:if(p=g.updateQueue,p!==null&&(p=p.lastEffect,p!==null)){var T=p=p.next;do{var M=T,R=M.destroy;M=M.tag,R!==void 0&&((M&2)!==0||(M&4)!==0)&&BS(g,_,R),T=T.next}while(T!==p)}break;case 1:if(Ax(g,_),p=g.stateNode,typeof p.componentWillUnmount=="function")try{p.props=g.memoizedProps,p.state=g.memoizedState,p.componentWillUnmount()}catch(K){Ji(g,_,K)}break;case 5:Ax(g,_);break;case 4:Be?YN(p,g,_):ye&&ye&&(g=g.stateNode.containerInfo,_=nn(g),Jo(g,_))}}function HN(p,g,_){for(var T=g;;)if(GN(p,T,_),T.child===null||Be&&T.tag===4){if(T===g)break;for(;T.sibling===null;){if(T.return===null||T.return===g)return;T=T.return}T.sibling.return=T.return,T=T.sibling}else T.child.return=T,T=T.child}function XN(p){var g=p.alternate;g!==null&&(p.alternate=null,XN(g)),p.child=null,p.deletions=null,p.sibling=null,p.tag===5&&(g=p.stateNode,g!==null&&nt(g)),p.stateNode=null,p.return=null,p.dependencies=null,p.memoizedProps=null,p.memoizedState=null,p.pendingProps=null,p.stateNode=null,p.updateQueue=null}function jN(p){return p.tag===5||p.tag===3||p.tag===4}function qN(p){e:for(;;){for(;p.sibling===null;){if(p.return===null||jN(p.return))return null;p=p.return}for(p.sibling.return=p.return,p=p.sibling;p.tag!==5&&p.tag!==6&&p.tag!==18;){if(p.flags&2||p.child===null||p.tag===4)continue e;p.child.return=p,p=p.child}if(!(p.flags&2))return p.stateNode}}function KN(p){if(Be){e:{for(var g=p.return;g!==null;){if(jN(g))break e;g=g.return}throw Error(o(160))}var _=g;switch(_.tag){case 5:g=_.stateNode,_.flags&32&&(Xt(g),_.flags&=-33),_=qN(p),WS(p,_,g);break;case 3:case 4:g=_.stateNode.containerInfo,_=qN(p),VS(p,_,g);break;default:throw Error(o(161))}}}function VS(p,g,_){var T=p.tag;if(T===5||T===6)p=p.stateNode,g?Oe(_,p,g):Ye(_,p);else if(T!==4&&(p=p.child,p!==null))for(VS(p,g,_),p=p.sibling;p!==null;)VS(p,g,_),p=p.sibling}function WS(p,g,_){var T=p.tag;if(T===5||T===6)p=p.stateNode,g?ve(_,p,g):ft(_,p);else if(T!==4&&(p=p.child,p!==null))for(WS(p,g,_),p=p.sibling;p!==null;)WS(p,g,_),p=p.sibling}function YN(p,g,_){for(var T=g,M=!1,R,K;;){if(!M){M=T.return;e:for(;;){if(M===null)throw Error(o(160));switch(R=M.stateNode,M.tag){case 5:K=!1;break e;case 3:R=R.containerInfo,K=!0;break e;case 4:R=R.containerInfo,K=!0;break e}M=M.return}M=!0}if(T.tag===5||T.tag===6)HN(p,T,_),K?St(R,T.stateNode):Ge(R,T.stateNode);else if(T.tag===18)K?Kn(R,T.stateNode):qt(R,T.stateNode);else if(T.tag===4){if(T.child!==null){R=T.stateNode.containerInfo,K=!0,T.child.return=T,T=T.child;continue}}else if(GN(p,T,_),T.child!==null){T.child.return=T,T=T.child;continue}if(T===g)break;for(;T.sibling===null;){if(T.return===null||T.return===g)return;T=T.return,T.tag===4&&(M=!1)}T.sibling.return=T.return,T=T.sibling}}function GS(p,g){if(Be){switch(g.tag){case 0:case 11:case 14:case 15:Yc(3,g,g.return),dp(3,g),Yc(5,g,g.return);return;case 1:return;case 5:var _=g.stateNode;if(_!=null){var T=g.memoizedProps;p=p!==null?p.memoizedProps:T;var M=g.type,R=g.updateQueue;g.updateQueue=null,R!==null&&J(_,R,M,p,T,g)}return;case 6:if(g.stateNode===null)throw Error(o(162));_=g.memoizedProps,Te(g.stateNode,p!==null?p.memoizedProps:_,_);return;case 3:fe&&p!==null&&p.memoizedState.isDehydrated&&Jt(g.stateNode.containerInfo);return;case 12:return;case 13:Nx(g);return;case 19:Nx(g);return;case 17:return}throw Error(o(163))}switch(g.tag){case 0:case 11:case 14:case 15:Yc(3,g,g.return),dp(3,g),Yc(5,g,g.return);return;case 12:return;case 13:Nx(g);return;case 19:Nx(g);return;case 3:fe&&p!==null&&p.memoizedState.isDehydrated&&Jt(g.stateNode.containerInfo);break;case 22:case 23:return}e:if(ye){switch(g.tag){case 1:case 5:case 6:break e;case 3:case 4:g=g.stateNode,Jo(g.containerInfo,g.pendingChildren);break e}throw Error(o(163))}}function Nx(p){var g=p.updateQueue;if(g!==null){p.updateQueue=null;var _=p.stateNode;_===null&&(_=p.stateNode=new OH),g.forEach(function(T){var M=KH.bind(null,p,T);_.has(T)||(_.add(T),T.then(M,M))})}}function BH(p,g){for(et=g;et!==null;){g=et;var _=g.deletions;if(_!==null)for(var T=0;T<_.length;T++){var M=_[T];try{var R=p;Be?YN(R,M,g):HN(R,M,g);var K=M.alternate;K!==null&&(K.return=null),M.return=null}catch(pt){Ji(M,g,pt)}}if(_=g.child,(g.subtreeFlags&12854)!==0&&_!==null)_.return=g,et=_;else for(;et!==null;){g=et;try{var re=g.flags;if(re&32&&Be&&Xt(g.stateNode),re&512){var Ce=g.alternate;if(Ce!==null){var He=Ce.ref;He!==null&&(typeof He=="function"?He(null):He.current=null)}}if(re&8192)switch(g.tag){case 13:if(g.memoizedState!==null){var ct=g.alternate;(ct===null||ct.memoizedState===null)&&(ZS=Us())}break;case 22:var At=g.memoizedState!==null,_t=g.alternate,wn=_t!==null&&_t.memoizedState!==null;if(_=g,Be){e:if(T=_,M=At,R=null,Be)for(var xt=T;;){if(xt.tag===5){if(R===null){R=xt;var di=xt.stateNode;M?Dn(di):_e(xt.stateNode,xt.memoizedProps)}}else if(xt.tag===6){if(R===null){var qr=xt.stateNode;M?ie(qr):Fe(qr,xt.memoizedProps)}}else if((xt.tag!==22&&xt.tag!==23||xt.memoizedState===null||xt===T)&&xt.child!==null){xt.child.return=xt,xt=xt.child;continue}if(xt===T)break;for(;xt.sibling===null;){if(xt.return===null||xt.return===T)break e;R===xt&&(R=null),xt=xt.return}R===xt&&(R=null),xt.sibling.return=xt.return,xt=xt.sibling}}if(At&&!wn&&(_.mode&1)!==0){et=_;for(var me=_.child;me!==null;){for(_=et=me;et!==null;){T=et;var le=T.child;switch(T.tag){case 0:case 11:case 14:case 15:Yc(4,T,T.return);break;case 1:Ax(T,T.return);var be=T.stateNode;if(typeof be.componentWillUnmount=="function"){var st=T.return;try{be.props=T.memoizedProps,be.state=T.memoizedState,be.componentWillUnmount()}catch(pt){Ji(T,st,pt)}}break;case 5:Ax(T,T.return);break;case 22:if(T.memoizedState!==null){QN(_);continue}}le!==null?(le.return=T,et=le):QN(_)}me=me.sibling}}}switch(re&4102){case 2:KN(g),g.flags&=-3;break;case 6:KN(g),g.flags&=-3,GS(g.alternate,g);break;case 4096:g.flags&=-4097;break;case 4100:g.flags&=-4097,GS(g.alternate,g);break;case 4:GS(g.alternate,g)}}catch(pt){Ji(g,g.return,pt)}if(_=g.sibling,_!==null){_.return=g.return,et=_;break}et=g.return}}}function UH(p,g,_){et=p,ZN(p)}function ZN(p,g,_){for(var T=(p.mode&1)!==0;et!==null;){var M=et,R=M.child;if(M.tag===22&&T){var K=M.memoizedState!==null||kx;if(!K){var re=M.alternate,Ce=re!==null&&re.memoizedState!==null||Kc;re=kx;var He=Kc;if(kx=K,(Kc=Ce)&&!He)for(et=M;et!==null;)K=et,Ce=K.child,K.tag===22&&K.memoizedState!==null?eR(M):Ce!==null?(Ce.return=K,et=Ce):eR(M);for(;R!==null;)et=R,ZN(R),R=R.sibling;et=M,kx=re,Kc=He}JN(p)}else(M.subtreeFlags&8772)!==0&&R!==null?(R.return=M,et=R):JN(p)}}function JN(p){for(;et!==null;){var g=et;if((g.flags&8772)!==0){var _=g.alternate;try{if((g.flags&8772)!==0)switch(g.tag){case 0:case 11:case 15:Kc||dp(5,g);break;case 1:var T=g.stateNode;if(g.flags&4&&!Kc)if(_===null)T.componentDidMount();else{var M=g.elementType===g.type?_.memoizedProps:bo(g.type,_.memoizedProps);T.componentDidUpdate(M,_.memoizedState,T.__reactInternalSnapshotBeforeUpdate)}var R=g.updateQueue;R!==null&&XA(g,R,T);break;case 3:var K=g.updateQueue;if(K!==null){if(_=null,g.child!==null)switch(g.child.tag){case 5:_=H(g.child.stateNode);break;case 1:_=g.child.stateNode}XA(g,K,_)}break;case 5:var re=g.stateNode;_===null&&g.flags&4&&ht(re,g.type,g.memoizedProps,g);break;case 6:break;case 4:break;case 12:break;case 13:if(fe&&g.memoizedState===null){var Ce=g.alternate;if(Ce!==null){var He=Ce.memoizedState;if(He!==null){var ct=He.dehydrated;ct!==null&&jt(ct)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(o(163))}Kc||g.flags&512&&US(g)}catch(At){Ji(g,g.return,At)}}if(g===p){et=null;break}if(_=g.sibling,_!==null){_.return=g.return,et=_;break}et=g.return}}function QN(p){for(;et!==null;){var g=et;if(g===p){et=null;break}var _=g.sibling;if(_!==null){_.return=g.return,et=_;break}et=g.return}}function eR(p){for(;et!==null;){var g=et;try{switch(g.tag){case 0:case 11:case 15:var _=g.return;try{dp(4,g)}catch(Ce){Ji(g,_,Ce)}break;case 1:var T=g.stateNode;if(typeof T.componentDidMount=="function"){var M=g.return;try{T.componentDidMount()}catch(Ce){Ji(g,M,Ce)}}var R=g.return;try{US(g)}catch(Ce){Ji(g,R,Ce)}break;case 5:var K=g.return;try{US(g)}catch(Ce){Ji(g,K,Ce)}}}catch(Ce){Ji(g,g.return,Ce)}if(g===p){et=null;break}var re=g.sibling;if(re!==null){re.return=g.return,et=re;break}et=g.return}}var Rx=0,Dx=1,Lx=2,Px=3,$x=4;if(typeof Symbol=="function"&&Symbol.for){var fp=Symbol.for;Rx=fp("selector.component"),Dx=fp("selector.has_pseudo_class"),Lx=fp("selector.role"),Px=fp("selector.test_id"),$x=fp("selector.text")}function HS(p){var g=Re(p);if(g!=null){if(typeof g.memoizedProps["data-testname"]!="string")throw Error(o(364));return g}if(p=Dt(p),p===null)throw Error(o(362));return p.stateNode.current}function XS(p,g){switch(g.$$typeof){case Rx:if(p.type===g.value)return!0;break;case Dx:e:{g=g.value,p=[p,0];for(var _=0;_<p.length;){var T=p[_++],M=p[_++],R=g[M];if(T.tag!==5||!ge(T)){for(;R!=null&&XS(T,R);)M++,R=g[M];if(M===g.length){g=!0;break e}else for(T=T.child;T!==null;)p.push(T,M),T=T.sibling}}g=!1}return g;case Lx:if(p.tag===5&&Pe(p.stateNode,g.value))return!0;break;case $x:if((p.tag===5||p.tag===6)&&(p=z(p),p!==null&&0<=p.indexOf(g.value)))return!0;break;case Px:if(p.tag===5&&(p=p.memoizedProps["data-testname"],typeof p=="string"&&p.toLowerCase()===g.value.toLowerCase()))return!0;break;default:throw Error(o(365))}return!1}function jS(p){switch(p.$$typeof){case Rx:return"<"+(k(p.value)||"Unknown")+">";case Dx:return":has("+(jS(p)||"")+")";case Lx:return'[role="'+p.value+'"]';case $x:return'"'+p.value+'"';case Px:return'[data-testname="'+p.value+'"]';default:throw Error(o(365))}}function tR(p,g){var _=[];p=[p,0];for(var T=0;T<p.length;){var M=p[T++],R=p[T++],K=g[R];if(M.tag!==5||!ge(M)){for(;K!=null&&XS(M,K);)R++,K=g[R];if(R===g.length)_.push(M);else for(M=M.child;M!==null;)p.push(M,R),M=M.sibling}}return _}function qS(p,g){if(!vt)throw Error(o(363));p=HS(p),p=tR(p,g),g=[],p=Array.from(p);for(var _=0;_<p.length;){var T=p[_++];if(T.tag===5)ge(T)||g.push(T.stateNode);else for(T=T.child;T!==null;)p.push(T),T=T.sibling}return g}var VH=Math.ceil,Fx=a.ReactCurrentDispatcher,KS=a.ReactCurrentOwner,as=a.ReactCurrentBatchConfig,Wt=0,xs=null,ys=null,Qs=0,gr=0,Xh=zr(0),Es=0,pp=null,jh=0,Ox=0,YS=0,mp=null,Yi=null,ZS=0,JS=1/0;function qh(){JS=Us()+500}var zx=!1,QS=null,kl=null,Bx=!1,Al=null,Ux=0,gp=0,e_=null,Vx=-1,Wx=0;function Ni(){return(Wt&6)!==0?Us():Vx!==-1?Vx:Vx=Us()}function Nl(p){return(p.mode&1)===0?1:(Wt&2)!==0&&Qs!==0?Qs&-Qs:CH.transition!==null?(Wx===0&&(p=nx,nx<<=1,(nx&4194240)===0&&(nx=64),Wx=p),Wx):(p=ln,p!==0?p:Le())}function Xr(p,g,_){if(50<gp)throw gp=0,e_=null,Error(o(185));var T=Gx(p,g);return T===null?null:(Qf(T,g,_),((Wt&2)===0||T!==xs)&&(T===xs&&((Wt&2)===0&&(Ox|=g),Es===4&&Rl(T,Qs)),Zi(T,_),g===1&&Wt===0&&(p.mode&1)===0&&(qh(),ox&&ta())),T)}function Gx(p,g){p.lanes|=g;var _=p.alternate;for(_!==null&&(_.lanes|=g),_=p,p=p.return;p!==null;)p.childLanes|=g,_=p.alternate,_!==null&&(_.childLanes|=g),_=p,p=p.return;return _.tag===3?_.stateNode:null}function Zi(p,g){var _=p.callbackNode;mH(p,g);var T=ix(p,p===xs?Qs:0);if(T===0)_!==null&&UA(_),p.callbackNode=null,p.callbackPriority=0;else if(g=T&-T,p.callbackPriority!==g){if(_!=null&&UA(_),g===1)p.tag===0?_H(sR.bind(null,p)):VA(sR.bind(null,p)),Ke?ot(function(){Wt===0&&ta()}):lS(cS,ta),_=null;else{switch(BA(T)){case 1:_=cS;break;case 4:_=vH;break;case 16:_=uS;break;case 536870912:_=wH;break;default:_=uS}_=dR(_,nR.bind(null,p))}p.callbackPriority=g,p.callbackNode=_}}function nR(p,g){if(Vx=-1,Wx=0,(Wt&6)!==0)throw Error(o(327));var _=p.callbackNode;if(Qc()&&p.callbackNode!==_)return null;var T=ix(p,p===xs?Qs:0);if(T===0)return null;if((T&30)!==0||(T&p.expiredLanes)!==0||g)g=Hx(p,T);else{g=T;var M=Wt;Wt|=2;var R=oR();(xs!==p||Qs!==g)&&(qh(),Zc(p,g));do try{HH();break}catch(re){rR(p,re)}while(1);fS(),Fx.current=R,Wt=M,ys!==null?g=0:(xs=null,Qs=0,g=Es)}if(g!==0){if(g===2&&(M=rS(p),M!==0&&(T=M,g=t_(p,M))),g===1)throw _=pp,Zc(p,0),Rl(p,T),Zi(p,Us()),_;if(g===6)Rl(p,T);else{if(M=p.current.alternate,(T&30)===0&&!WH(M)&&(g=Hx(p,T),g===2&&(R=rS(p),R!==0&&(T=R,g=t_(p,R))),g===1))throw _=pp,Zc(p,0),Rl(p,T),Zi(p,Us()),_;switch(p.finishedWork=M,p.finishedLanes=T,g){case 0:case 1:throw Error(o(345));case 2:Jc(p,Yi);break;case 3:if(Rl(p,T),(T&130023424)===T&&(g=ZS+500-Us(),10<g)){if(ix(p,0)!==0)break;if(M=p.suspendedLanes,(M&T)!==T){Ni(),p.pingedLanes|=p.suspendedLanes&M;break}p.timeoutHandle=ke(Jc.bind(null,p,Yi),g);break}Jc(p,Yi);break;case 4:if(Rl(p,T),(T&4194240)===T)break;for(g=p.eventTimes,M=-1;0<T;){var K=31-wo(T);R=1<<K,K=g[K],K>M&&(M=K),T&=~R}if(T=M,T=Us()-T,T=(120>T?120:480>T?480:1080>T?1080:1920>T?1920:3e3>T?3e3:4320>T?4320:1960*VH(T/1960))-T,10<T){p.timeoutHandle=ke(Jc.bind(null,p,Yi),T);break}Jc(p,Yi);break;case 5:Jc(p,Yi);break;default:throw Error(o(329))}}}return Zi(p,Us()),p.callbackNode===_?nR.bind(null,p):null}function t_(p,g){var _=mp;return p.current.memoizedState.isDehydrated&&(Zc(p,g).flags|=256),p=Hx(p,g),p!==2&&(g=Yi,Yi=_,g!==null&&n_(g)),p}function n_(p){Yi===null?Yi=p:Yi.push.apply(Yi,p)}function WH(p){for(var g=p;;){if(g.flags&16384){var _=g.updateQueue;if(_!==null&&(_=_.stores,_!==null))for(var T=0;T<_.length;T++){var M=_[T],R=M.getSnapshot;M=M.value;try{if(!ea(R(),M))return!1}catch{return!1}}}if(_=g.child,g.subtreeFlags&16384&&_!==null)_.return=g,g=_;else{if(g===p)break;for(;g.sibling===null;){if(g.return===null||g.return===p)return!0;g=g.return}g.sibling.return=g.return,g=g.sibling}}return!0}function Rl(p,g){for(g&=~YS,g&=~Ox,p.suspendedLanes|=g,p.pingedLanes&=~g,p=p.expirationTimes;0<g;){var _=31-wo(g),T=1<<_;p[_]=-1,g&=~T}}function sR(p){if((Wt&6)!==0)throw Error(o(327));Qc();var g=ix(p,0);if((g&1)===0)return Zi(p,Us()),null;var _=Hx(p,g);if(p.tag!==0&&_===2){var T=rS(p);T!==0&&(g=T,_=t_(p,T))}if(_===1)throw _=pp,Zc(p,0),Rl(p,g),Zi(p,Us()),_;if(_===6)throw Error(o(345));return p.finishedWork=p.current.alternate,p.finishedLanes=g,Jc(p,Yi),Zi(p,Us()),null}function iR(p){Al!==null&&Al.tag===0&&(Wt&6)===0&&Qc();var g=Wt;Wt|=1;var _=as.transition,T=ln;try{if(as.transition=null,ln=1,p)return p()}finally{ln=T,as.transition=_,Wt=g,(Wt&6)===0&&ta()}}function s_(){gr=Xh.current,Lt(Xh)}function Zc(p,g){p.finishedWork=null,p.finishedLanes=0;var _=p.timeoutHandle;if(_!==De&&(p.timeoutHandle=De,Me(_)),ys!==null)for(_=ys.return;_!==null;){var T=_;switch(wS(T),T.tag){case 1:T=T.type.childContextTypes,T!=null&&ex();break;case 3:Gh(),Lt(Bs),Lt(mn),ES();break;case 5:TS(T);break;case 4:Gh();break;case 13:Lt(Gn);break;case 19:Lt(Gn);break;case 10:pS(T.type._context);break;case 22:case 23:s_()}_=_.return}if(xs=p,ys=p=Dl(p.current,null),Qs=gr=g,Es=0,pp=null,YS=Ox=jh=0,Yi=mp=null,na!==null){for(g=0;g<na.length;g++)if(_=na[g],T=_.interleaved,T!==null){_.interleaved=null;var M=T.next,R=_.pending;if(R!==null){var K=R.next;R.next=M,T.next=K}_.pending=T}na=null}return p}function rR(p,g){do{var _=ys;try{if(fS(),xx.current=_x,yx){for(var T=Zn.memoizedState;T!==null;){var M=T.queue;M!==null&&(M.pending=null),T=T.next}yx=!1}if(Hh=0,Vs=ci=Zn=null,rp=!1,op=0,KS.current=null,_===null||_.return===null){Es=1,pp=g,ys=null;break}e:{var R=p,K=_.return,re=_,Ce=g;if(g=Qs,re.flags|=32768,Ce!==null&&typeof Ce=="object"&&typeof Ce.then=="function"){var He=Ce,ct=re,At=ct.tag;if((ct.mode&1)===0&&(At===0||At===11||At===15)){var _t=ct.alternate;_t?(ct.updateQueue=_t.updateQueue,ct.memoizedState=_t.memoizedState,ct.lanes=_t.lanes):(ct.updateQueue=null,ct.memoizedState=null)}var wn=IN(K);if(wn!==null){wn.flags&=-257,EN(wn,K,re,R,g),wn.mode&1&&TN(R,He,g),g=wn,Ce=He;var xt=g.updateQueue;if(xt===null){var di=new Set;di.add(Ce),g.updateQueue=di}else xt.add(Ce);break e}else{if((g&1)===0){TN(R,He,g),i_();break e}Ce=Error(o(426))}}else if(zn&&re.mode&1){var qr=IN(K);if(qr!==null){(qr.flags&65536)===0&&(qr.flags|=256),EN(qr,K,re,R,g),_S(Ce);break e}}R=Ce,Es!==4&&(Es=2),mp===null?mp=[R]:mp.push(R),Ce=LS(Ce,re),re=K;do{switch(re.tag){case 3:re.flags|=65536,g&=-g,re.lanes|=g;var me=_N(re,Ce,g);HA(re,me);break e;case 1:R=Ce;var le=re.type,be=re.stateNode;if((re.flags&128)===0&&(typeof le.getDerivedStateFromError=="function"||be!==null&&typeof be.componentDidCatch=="function"&&(kl===null||!kl.has(be)))){re.flags|=65536,g&=-g,re.lanes|=g;var st=CN(re,R,g);HA(re,st);break e}}re=re.return}while(re!==null)}lR(_)}catch(pt){g=pt,ys===_&&_!==null&&(ys=_=_.return);continue}break}while(1)}function oR(){var p=Fx.current;return Fx.current=_x,p===null?_x:p}function i_(){(Es===0||Es===3||Es===2)&&(Es=4),xs===null||(jh&268435455)===0&&(Ox&268435455)===0||Rl(xs,Qs)}function Hx(p,g){var _=Wt;Wt|=2;var T=oR();xs===p&&Qs===g||Zc(p,g);do try{GH();break}catch(M){rR(p,M)}while(1);if(fS(),Wt=_,Fx.current=T,ys!==null)throw Error(o(261));return xs=null,Qs=0,Es}function GH(){for(;ys!==null;)aR(ys)}function HH(){for(;ys!==null&&!xH();)aR(ys)}function aR(p){var g=hR(p.alternate,p,gr);p.memoizedProps=p.pendingProps,g===null?lR(p):ys=g,KS.current=null}function lR(p){var g=p;do{var _=g.alternate;if(p=g.return,(g.flags&32768)===0){if(_=LH(_,g,gr),_!==null){ys=_;return}}else{if(_=FH(_,g),_!==null){_.flags&=32767,ys=_;return}if(p!==null)p.flags|=32768,p.subtreeFlags=0,p.deletions=null;else{Es=6,ys=null;return}}if(g=g.sibling,g!==null){ys=g;return}ys=g=p}while(g!==null);Es===0&&(Es=5)}function Jc(p,g){var _=ln,T=as.transition;try{as.transition=null,ln=1,XH(p,g,_)}finally{as.transition=T,ln=_}return null}function XH(p,g,_){do Qc();while(Al!==null);if((Wt&6)!==0)throw Error(o(327));var T=p.finishedWork,M=p.finishedLanes;if(T===null)return null;if(p.finishedWork=null,p.finishedLanes=0,T===p.current)throw Error(o(177));p.callbackNode=null,p.callbackPriority=0;var R=T.lanes|T.childLanes;if(gH(p,R),p===xs&&(ys=xs=null,Qs=0),(T.subtreeFlags&2064)===0&&(T.flags&2064)===0||Bx||(Bx=!0,dR(uS,function(){return Qc(),null})),R=(T.flags&15990)!==0,(T.subtreeFlags&15990)!==0||R){R=as.transition,as.transition=null;var K=ln;ln=1;var re=Wt;Wt|=4,KS.current=null,zH(p,T),BH(p,T),U(p.containerInfo),p.current=T,UH(T),yH(),Wt=re,ln=K,as.transition=R}else p.current=T;if(Bx&&(Bx=!1,Al=p,Ux=M),R=p.pendingLanes,R===0&&(kl=null),bH(T.stateNode),Zi(p,Us()),g!==null)for(_=p.onRecoverableError,T=0;T<g.length;T++)_(g[T]);if(zx)throw zx=!1,p=QS,QS=null,p;return(Ux&1)!==0&&p.tag!==0&&Qc(),R=p.pendingLanes,(R&1)!==0?p===e_?gp++:(gp=0,e_=p):gp=0,ta(),null}function Qc(){if(Al!==null){var p=BA(Ux),g=as.transition,_=ln;try{if(as.transition=null,ln=16>p?16:p,Al===null)var T=!1;else{if(p=Al,Al=null,Ux=0,(Wt&6)!==0)throw Error(o(331));var M=Wt;for(Wt|=4,et=p.current;et!==null;){var R=et,K=R.child;if((et.flags&16)!==0){var re=R.deletions;if(re!==null){for(var Ce=0;Ce<re.length;Ce++){var He=re[Ce];for(et=He;et!==null;){var ct=et;switch(ct.tag){case 0:case 11:case 15:Yc(8,ct,R)}var At=ct.child;if(At!==null)At.return=ct,et=At;else for(;et!==null;){ct=et;var _t=ct.sibling,wn=ct.return;if(XN(ct),ct===He){et=null;break}if(_t!==null){_t.return=wn,et=_t;break}et=wn}}}var xt=R.alternate;if(xt!==null){var di=xt.child;if(di!==null){xt.child=null;do{var qr=di.sibling;di.sibling=null,di=qr}while(di!==null)}}et=R}}if((R.subtreeFlags&2064)!==0&&K!==null)K.return=R,et=K;else e:for(;et!==null;){if(R=et,(R.flags&2048)!==0)switch(R.tag){case 0:case 11:case 15:Yc(9,R,R.return)}var me=R.sibling;if(me!==null){me.return=R.return,et=me;break e}et=R.return}}var le=p.current;for(et=le;et!==null;){K=et;var be=K.child;if((K.subtreeFlags&2064)!==0&&be!==null)be.return=K,et=be;else e:for(K=le;et!==null;){if(re=et,(re.flags&2048)!==0)try{switch(re.tag){case 0:case 11:case 15:dp(9,re)}}catch(pt){Ji(re,re.return,pt)}if(re===K){et=null;break e}var st=re.sibling;if(st!==null){st.return=re.return,et=st;break e}et=re.return}}if(Wt=M,ta(),Qo&&typeof Qo.onPostCommitFiberRoot=="function")try{Qo.onPostCommitFiberRoot(rx,p)}catch{}T=!0}return T}finally{ln=_,as.transition=g}}return!1}function cR(p,g,_){g=LS(_,g),g=_N(p,g,1),Ml(p,g),g=Ni(),p=Gx(p,1),p!==null&&(Qf(p,1,g),Zi(p,g))}function Ji(p,g,_){if(p.tag===3)cR(p,p,_);else for(;g!==null;){if(g.tag===3){cR(g,p,_);break}else if(g.tag===1){var T=g.stateNode;if(typeof g.type.getDerivedStateFromError=="function"||typeof T.componentDidCatch=="function"&&(kl===null||!kl.has(T))){p=LS(_,p),p=CN(g,p,1),Ml(g,p),p=Ni(),g=Gx(g,1),g!==null&&(Qf(g,1,p),Zi(g,p));break}}g=g.return}}function jH(p,g,_){var T=p.pingCache;T!==null&&T.delete(g),g=Ni(),p.pingedLanes|=p.suspendedLanes&_,xs===p&&(Qs&_)===_&&(Es===4||Es===3&&(Qs&130023424)===Qs&&500>Us()-ZS?Zc(p,0):YS|=_),Zi(p,g)}function uR(p,g){g===0&&((p.mode&1)===0?g=1:(g=sx,sx<<=1,(sx&130023424)===0&&(sx=4194304)));var _=Ni();p=Gx(p,g),p!==null&&(Qf(p,g,_),Zi(p,_))}function qH(p){var g=p.memoizedState,_=0;g!==null&&(_=g.retryLane),uR(p,_)}function KH(p,g){var _=0;switch(p.tag){case 13:var T=p.stateNode,M=p.memoizedState;M!==null&&(_=M.retryLane);break;case 19:T=p.stateNode;break;default:throw Error(o(314))}T!==null&&T.delete(g),uR(p,_)}var hR;hR=function(p,g,_){if(p!==null)if(p.memoizedProps!==g.pendingProps||Bs.current)mr=!0;else{if((p.lanes&_)===0&&(g.flags&128)===0)return mr=!1,$H(p,g,_);mr=(p.flags&131072)!==0}else mr=!1,zn&&(g.flags&1048576)!==0&&ZA(g,px,g.index);switch(g.lanes=0,g.tag){case 2:var T=g.type;p!==null&&(p.alternate=null,g.alternate=null,g.flags|=2),p=g.pendingProps;var M=Fa(g,mn.current);Oh(g,_),M=kS(null,g,T,p,M,_);var R=AS();return g.flags|=1,typeof M=="object"&&M!==null&&typeof M.render=="function"&&M.$$typeof===void 0?(g.tag=1,g.memoizedState=null,g.updateQueue=null,Ki(T)?(R=!0,tx(g)):R=!1,g.memoizedState=M.state!==null&&M.state!==void 0?M.state:null,gS(g),M.updater=dx,g.stateNode=M,M._reactInternals=g,yS(g,T,p,_),g=FS(null,g,T,!0,R,_)):(g.tag=0,zn&&R&&vS(g),Ai(null,g,M,_),g=g.child),g;case 16:T=g.elementType;e:{switch(p!==null&&(p.alternate=null,g.alternate=null,g.flags|=2),p=g.pendingProps,M=T._init,T=M(T._payload),g.type=T,M=g.tag=ZH(T),p=bo(T,p),M){case 0:g=$S(null,g,T,p,_);break e;case 1:g=PN(null,g,T,p,_);break e;case 11:g=AN(null,g,T,p,_);break e;case 14:g=NN(null,g,T,bo(T.type,p),_);break e}throw Error(o(306,T,""))}return g;case 0:return T=g.type,M=g.pendingProps,M=g.elementType===T?M:bo(T,M),$S(p,g,T,M,_);case 1:return T=g.type,M=g.pendingProps,M=g.elementType===T?M:bo(T,M),PN(p,g,T,M,_);case 3:e:{if($N(g),p===null)throw Error(o(387));T=g.pendingProps,R=g.memoizedState,M=R.element,GA(p,g),hx(g,T,null,_);var K=g.memoizedState;if(T=K.element,fe&&R.isDehydrated)if(R={element:T,isDehydrated:!1,cache:K.cache,transitions:K.transitions},g.updateQueue.baseState=R,g.memoizedState=R,g.flags&256){M=Error(o(423)),g=FN(p,g,T,_,M);break e}else if(T!==M){M=Error(o(424)),g=FN(p,g,T,_,M);break e}else for(fe&&(pr=he(g.stateNode.containerInfo),fr=g,zn=!0,So=null,ep=!1),_=sN(g,null,T,_),g.child=_;_;)_.flags=_.flags&-3|4096,_=_.sibling;else{if(Uh(),T===M){g=Wa(p,g,_);break e}Ai(p,g,T,_)}g=g.child}return g;case 5:return iN(g),p===null&&SS(g),T=g.type,M=g.pendingProps,R=p!==null?p.memoizedProps:null,K=M.children,ue(T,M)?K=null:R!==null&&ue(T,R)&&(g.flags|=32),LN(p,g),Ai(p,g,K,_),g.child;case 6:return p===null&&SS(g),null;case 13:return ON(p,g,_);case 4:return CS(g,g.stateNode.containerInfo),T=g.pendingProps,p===null?g.child=Vh(g,null,T,_):Ai(p,g,T,_),g.child;case 11:return T=g.type,M=g.pendingProps,M=g.elementType===T?M:bo(T,M),AN(p,g,T,M,_);case 7:return Ai(p,g,g.pendingProps,_),g.child;case 8:return Ai(p,g,g.pendingProps.children,_),g.child;case 12:return Ai(p,g,g.pendingProps.children,_),g.child;case 10:e:{if(T=g.type._context,M=g.pendingProps,R=g.memoizedProps,K=M.value,WA(g,T,K),R!==null)if(ea(R.value,K)){if(R.children===M.children&&!Bs.current){g=Wa(p,g,_);break e}}else for(R=g.child,R!==null&&(R.return=g);R!==null;){var re=R.dependencies;if(re!==null){K=R.child;for(var Ce=re.firstContext;Ce!==null;){if(Ce.context===T){if(R.tag===1){Ce=za(-1,_&-_),Ce.tag=2;var He=R.updateQueue;if(He!==null){He=He.shared;var ct=He.pending;ct===null?Ce.next=Ce:(Ce.next=ct.next,ct.next=Ce),He.pending=Ce}}R.lanes|=_,Ce=R.alternate,Ce!==null&&(Ce.lanes|=_),mS(R.return,_,g),re.lanes|=_;break}Ce=Ce.next}}else if(R.tag===10)K=R.type===g.type?null:R.child;else if(R.tag===18){if(K=R.return,K===null)throw Error(o(341));K.lanes|=_,re=K.alternate,re!==null&&(re.lanes|=_),mS(K,_,g),K=R.sibling}else K=R.child;if(K!==null)K.return=R;else for(K=R;K!==null;){if(K===g){K=null;break}if(R=K.sibling,R!==null){R.return=K.return,K=R;break}K=K.return}R=K}Ai(p,g,M.children,_),g=g.child}return g;case 9:return M=g.type,T=g.pendingProps.children,Oh(g,_),M=Ur(M),T=T(M),g.flags|=1,Ai(p,g,T,_),g.child;case 14:return T=g.type,M=bo(T,g.pendingProps),M=bo(T.type,M),NN(p,g,T,M,_);case 15:return RN(p,g,g.type,g.pendingProps,_);case 17:return T=g.type,M=g.pendingProps,M=g.elementType===T?M:bo(T,M),p!==null&&(p.alternate=null,g.alternate=null,g.flags|=2),g.tag=1,Ki(T)?(p=!0,tx(g)):p=!1,Oh(g,_),KA(g,T,M),yS(g,T,M,_),FS(null,g,T,!0,p,_);case 19:return VN(p,g,_);case 22:return DN(p,g,_)}throw Error(o(156,g.tag))};function dR(p,g){return lS(p,g)}function YH(p,g,_,T){this.tag=p,this.key=_,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=g,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=T,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function jr(p,g,_,T){return new YH(p,g,_,T)}function r_(p){return p=p.prototype,!(!p||!p.isReactComponent)}function ZH(p){if(typeof p=="function")return r_(p)?1:0;if(p!=null){if(p=p.$$typeof,p===x)return 11;if(p===w)return 14}return 2}function Dl(p,g){var _=p.alternate;return _===null?(_=jr(p.tag,g,p.key,p.mode),_.elementType=p.elementType,_.type=p.type,_.stateNode=p.stateNode,_.alternate=p,p.alternate=_):(_.pendingProps=g,_.type=p.type,_.flags=0,_.subtreeFlags=0,_.deletions=null),_.flags=p.flags&14680064,_.childLanes=p.childLanes,_.lanes=p.lanes,_.child=p.child,_.memoizedProps=p.memoizedProps,_.memoizedState=p.memoizedState,_.updateQueue=p.updateQueue,g=p.dependencies,_.dependencies=g===null?null:{lanes:g.lanes,firstContext:g.firstContext},_.sibling=p.sibling,_.index=p.index,_.ref=p.ref,_}function Xx(p,g,_,T,M,R){var K=2;if(T=p,typeof p=="function")r_(p)&&(K=1);else if(typeof p=="string")K=5;else e:switch(p){case u:return eu(_.children,M,R,g);case h:K=8,M|=8;break;case d:return p=jr(12,_,g,M|2),p.elementType=d,p.lanes=R,p;case y:return p=jr(13,_,g,M),p.elementType=y,p.lanes=R,p;case v:return p=jr(19,_,g,M),p.elementType=v,p.lanes=R,p;case S:return jx(_,M,R,g);default:if(typeof p=="object"&&p!==null)switch(p.$$typeof){case f:K=10;break e;case m:K=9;break e;case x:K=11;break e;case w:K=14;break e;case b:K=16,T=null;break e}throw Error(o(130,p==null?p:typeof p,""))}return g=jr(K,_,g,M),g.elementType=p,g.type=T,g.lanes=R,g}function eu(p,g,_,T){return p=jr(7,p,T,g),p.lanes=_,p}function jx(p,g,_,T){return p=jr(22,p,T,g),p.elementType=S,p.lanes=_,p.stateNode={},p}function o_(p,g,_){return p=jr(6,p,null,g),p.lanes=_,p}function a_(p,g,_){return g=jr(4,p.children!==null?p.children:[],p.key,g),g.lanes=_,g.stateNode={containerInfo:p.containerInfo,pendingChildren:null,implementation:p.implementation},g}function JH(p,g,_,T,M){this.tag=g,this.containerInfo=p,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=De,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=oS(0),this.expirationTimes=oS(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=oS(0),this.identifierPrefix=T,this.onRecoverableError=M,fe&&(this.mutableSourceEagerHydrationData=null)}function fR(p,g,_,T,M,R,K,re,Ce){return p=new JH(p,g,_,re,Ce),g===1?(g=1,R===!0&&(g|=8)):g=0,R=jr(3,null,null,g),p.current=R,R.stateNode=p,R.memoizedState={element:T,isDehydrated:_,cache:null,transitions:null},gS(R),p}function pR(p){if(!p)return Br;p=p._reactInternals;e:{if(A(p)!==p||p.tag!==1)throw Error(o(170));var g=p;do{switch(g.tag){case 3:g=g.stateNode.context;break e;case 1:if(Ki(g.type)){g=g.stateNode.__reactInternalMemoizedMergedChildContext;break e}}g=g.return}while(g!==null);throw Error(o(171))}if(p.tag===1){var _=p.type;if(Ki(_))return OA(p,_,g)}return g}function mR(p){var g=p._reactInternals;if(g===void 0)throw typeof p.render=="function"?Error(o(188)):(p=Object.keys(p).join(","),Error(o(268,p)));return p=V(g),p===null?null:p.stateNode}function gR(p,g){if(p=p.memoizedState,p!==null&&p.dehydrated!==null){var _=p.retryLane;p.retryLane=_!==0&&_<g?_:g}}function l_(p,g){gR(p,g),(p=p.alternate)&&gR(p,g)}function QH(p){return p=V(p),p===null?null:p.stateNode}function e6(){return null}return t.attemptContinuousHydration=function(p){if(p.tag===13){var g=Ni();Xr(p,134217728,g),l_(p,134217728)}},t.attemptHydrationAtCurrentPriority=function(p){if(p.tag===13){var g=Ni(),_=Nl(p);Xr(p,_,g),l_(p,_)}},t.attemptSynchronousHydration=function(p){switch(p.tag){case 3:var g=p.stateNode;if(g.current.memoizedState.isDehydrated){var _=Jf(g.pendingLanes);_!==0&&(aS(g,_|1),Zi(g,Us()),(Wt&6)===0&&(qh(),ta()))}break;case 13:var T=Ni();iR(function(){return Xr(p,1,T)}),l_(p,1)}},t.batchedUpdates=function(p,g){var _=Wt;Wt|=1;try{return p(g)}finally{Wt=_,Wt===0&&(qh(),ox&&ta())}},t.createComponentSelector=function(p){return{$$typeof:Rx,value:p}},t.createContainer=function(p,g,_,T,M,R,K){return fR(p,g,!1,null,_,T,M,R,K)},t.createHasPseudoClassSelector=function(p){return{$$typeof:Dx,value:p}},t.createHydrationContainer=function(p,g,_,T,M,R,K,re,Ce){return p=fR(_,T,!0,p,M,R,K,re,Ce),p.context=pR(null),_=p.current,T=Ni(),M=Nl(_),R=za(T,M),R.callback=g!=null?g:null,Ml(_,R),p.current.lanes=M,Qf(p,M,T),Zi(p,T),p},t.createPortal=function(p,g,_){var T=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:c,key:T==null?null:""+T,children:p,containerInfo:g,implementation:_}},t.createRoleSelector=function(p){return{$$typeof:Lx,value:p}},t.createTestNameSelector=function(p){return{$$typeof:Px,value:p}},t.createTextSelector=function(p){return{$$typeof:$x,value:p}},t.deferredUpdates=function(p){var g=ln,_=as.transition;try{return as.transition=null,ln=16,p()}finally{ln=g,as.transition=_}},t.discreteUpdates=function(p,g,_,T,M){var R=ln,K=as.transition;try{return as.transition=null,ln=1,p(g,_,T,M)}finally{ln=R,as.transition=K,Wt===0&&qh()}},t.findAllNodes=qS,t.findBoundingRects=function(p,g){if(!vt)throw Error(o(363));g=qS(p,g),p=[];for(var _=0;_<g.length;_++)p.push(q(g[_]));for(g=p.length-1;0<g;g--){_=p[g];for(var T=_.x,M=T+_.width,R=_.y,K=R+_.height,re=g-1;0<=re;re--)if(g!==re){var Ce=p[re],He=Ce.x,ct=He+Ce.width,At=Ce.y,_t=At+Ce.height;if(T>=He&&R>=At&&M<=ct&&K<=_t){p.splice(g,1);break}else if(T!==He||_.width!==Ce.width||_t<R||At>K){if(!(R!==At||_.height!==Ce.height||ct<T||He>M)){He>T&&(Ce.width+=He-T,Ce.x=T),ct<M&&(Ce.width=M-He),p.splice(g,1);break}}else{At>R&&(Ce.height+=At-R,Ce.y=R),_t<K&&(Ce.height=K-At),p.splice(g,1);break}}}return p},t.findHostInstance=mR,t.findHostInstanceWithNoPortals=function(p){return p=L(p),p=p!==null?P(p):null,p===null?null:p.stateNode},t.findHostInstanceWithWarning=function(p){return mR(p)},t.flushControlled=function(p){var g=Wt;Wt|=1;var _=as.transition,T=ln;try{as.transition=null,ln=1,p()}finally{ln=T,as.transition=_,Wt=g,Wt===0&&(qh(),ta())}},t.flushPassiveEffects=Qc,t.flushSync=iR,t.focusWithin=function(p,g){if(!vt)throw Error(o(363));for(p=HS(p),g=tR(p,g),g=Array.from(g),p=0;p<g.length;){var _=g[p++];if(!ge(_)){if(_.tag===5&&ze(_.stateNode))return!0;for(_=_.child;_!==null;)g.push(_),_=_.sibling}}return!1},t.getCurrentUpdatePriority=function(){return ln},t.getFindAllNodesFailureDescription=function(p,g){if(!vt)throw Error(o(363));var _=0,T=[];p=[HS(p),0];for(var M=0;M<p.length;){var R=p[M++],K=p[M++],re=g[K];if((R.tag!==5||!ge(R))&&(XS(R,re)&&(T.push(jS(re)),K++,K>_&&(_=K)),K<g.length))for(R=R.child;R!==null;)p.push(R,K),R=R.sibling}if(_<g.length){for(p=[];_<g.length;_++)p.push(jS(g[_]));return`findAllNodes was able to match part of the selector:
  `+(T.join(" > ")+`

No matching component was found for:
  `)+p.join(" > ")}return null},t.getPublicRootInstance=function(p){if(p=p.current,!p.child)return null;switch(p.child.tag){case 5:return H(p.child.stateNode);default:return p.child.stateNode}},t.injectIntoDevTools=function(p){if(p={bundleType:p.bundleType,version:p.version,rendererPackageName:p.rendererPackageName,rendererConfig:p.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:a.ReactCurrentDispatcher,findHostInstanceByFiber:QH,findFiberByHostInstance:p.findFiberByHostInstance||e6,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")p=!1;else{var g=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(g.isDisabled||!g.supportsFiber)p=!0;else{try{rx=g.inject(p),Qo=g}catch{}p=!!g.checkDCE}}return p},t.isAlreadyRendering=function(){return!1},t.observeVisibleRects=function(p,g,_,T){if(!vt)throw Error(o(363));p=qS(p,g);var M=Xe(p,_,T).disconnect;return{disconnect:function(){M()}}},t.registerMutableSourceForHydration=function(p,g){var _=g._getVersion;_=_(g._source),p.mutableSourceEagerHydrationData==null?p.mutableSourceEagerHydrationData=[g,_]:p.mutableSourceEagerHydrationData.push(g,_)},t.runWithPriority=function(p,g){var _=ln;try{return ln=p,g()}finally{ln=_}},t.shouldError=function(){return null},t.shouldSuspend=function(){return!1},t.updateContainer=function(p,g,_,T){var M=g.current,R=Ni(),K=Nl(M);return _=pR(_),g.context===null?g.context=_:g.pendingContext=_,g=za(R,K),g.payload={element:p},T=T===void 0?null:T,T!==null&&(g.callback=T),Ml(M,g),p=Xr(M,K,R),p!==null&&ux(p,M,K),K},t};(function(n){n.exports=h2e})(B5);const d2e=mI(B5.exports);var tS={exports:{}},nS={};/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f2e=qe.exports,p2e=Symbol.for("react.element"),m2e=Symbol.for("react.fragment"),g2e=Object.prototype.hasOwnProperty,x2e=f2e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,y2e={key:!0,ref:!0,__self:!0,__source:!0};function V5(n,e,t){var s,i={},r=null,o=null;t!==void 0&&(r=""+t),e.key!==void 0&&(r=""+e.key),e.ref!==void 0&&(o=e.ref);for(s in e)g2e.call(e,s)&&!y2e.hasOwnProperty(s)&&(i[s]=e[s]);if(n&&n.defaultProps)for(s in e=n.defaultProps,e)i[s]===void 0&&(i[s]=e[s]);return{$$typeof:p2e,type:n,key:r,ref:o,props:i,_owner:x2e.current}}nS.Fragment=m2e;nS.jsx=V5;nS.jsxs=V5;(function(n){n.exports=nS})(tS);const cI=tS.exports.Fragment,Kt=tS.exports.jsx,ga=tS.exports.jsxs;var RP,DP;const W5=n=>n&&n.isOrthographicCamera,v2e=n=>n&&n.hasOwnProperty("current"),Z0=typeof window<"u"&&((RP=window.document)!=null&&RP.createElement||((DP=window.navigator)==null?void 0:DP.product)==="ReactNative")?qe.exports.useLayoutEffect:qe.exports.useEffect;function G5(n){const e=qe.exports.useRef(n);return Z0(()=>void(e.current=n),[n]),e}function w2e({set:n}){return Z0(()=>(n(new Promise(()=>null)),()=>n(!1)),[n]),null}class H5 extends qe.exports.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}H5.getDerivedStateFromError=()=>({error:!0});const X5="__default",b2e=n=>n&&!!n.memoized&&!!n.changes;function j5(n){const e=typeof window<"u"?window.devicePixelRatio:1;return Array.isArray(n)?Math.min(Math.max(n[0],e),n[1]):n}const Fp=n=>{var e;return(e=n.__r3f)==null?void 0:e.root.getState()},es={obj:n=>n===Object(n)&&!es.arr(n)&&typeof n!="function",fun:n=>typeof n=="function",str:n=>typeof n=="string",num:n=>typeof n=="number",boo:n=>typeof n=="boolean",und:n=>n===void 0,arr:n=>Array.isArray(n),equ(n,e,{arrays:t="shallow",objects:s="reference",strict:i=!0}={}){if(typeof n!=typeof e||!!n!=!!e)return!1;if(es.str(n)||es.num(n))return n===e;const r=es.obj(n);if(r&&s==="reference")return n===e;const o=es.arr(n);if(o&&t==="reference")return n===e;if((o||r)&&n===e)return!0;let a;for(a in n)if(!(a in e))return!1;for(a in i?e:n)if(n[a]!==e[a])return!1;if(es.und(a)){if(o&&n.length===0&&e.length===0||r&&Object.keys(n).length===0&&Object.keys(e).length===0)return!0;if(n!==e)return!1}return!0}};function S2e(n){n.dispose&&n.type!=="Scene"&&n.dispose();for(const e in n)e.dispose==null||e.dispose(),delete n[e]}function yd(n,e){const t=n;return(e!=null&&e.primitive||!t.__r3f)&&(t.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e}),n}function uI(n,e){let t=n;if(e.includes("-")){const s=e.split("-"),i=s.pop();return t=s.reduce((r,o)=>r[o],n),{target:t,key:i}}else return{target:t,key:e}}const LP=/-\d+$/;function PC(n,e,t){if(es.str(t)){if(LP.test(t)){const r=t.replace(LP,""),{target:o,key:a}=uI(n,r);Array.isArray(o[a])||(o[a]=[])}const{target:s,key:i}=uI(n,t);e.__r3f.previousAttach=s[i],s[i]=e}else e.__r3f.previousAttach=t(n,e)}function PP(n,e,t){var s,i;if(es.str(t)){const{target:r,key:o}=uI(n,t),a=e.__r3f.previousAttach;a===void 0?delete r[o]:r[o]=a}else(s=e.__r3f)==null||s.previousAttach==null||s.previousAttach(n,e);(i=e.__r3f)==null||delete i.previousAttach}function q5(n,{children:e,key:t,ref:s,...i},{children:r,key:o,ref:a,...l}={},c=!1){var u;const h=(u=n==null?void 0:n.__r3f)!=null?u:{},d=Object.entries(i),f=[];if(c){const x=Object.keys(l);for(let y=0;y<x.length;y++)i.hasOwnProperty(x[y])||d.unshift([x[y],X5+"remove"])}d.forEach(([x,y])=>{var v;if((v=n.__r3f)!=null&&v.primitive&&x==="object"||es.equ(y,l[x]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(x))return f.push([x,y,!0,[]]);let w=[];x.includes("-")&&(w=x.split("-")),f.push([x,y,!1,w]);for(const b in i){const S=i[b];b.startsWith(`${x}-`)&&f.push([b,S,!1,b.split("-")])}});const m={...i};return h.memoizedProps&&h.memoizedProps.args&&(m.args=h.memoizedProps.args),h.memoizedProps&&h.memoizedProps.attach&&(m.attach=h.memoizedProps.attach),{memoized:m,changes:f}}function $C(n,e){var t,s,i;const r=(t=n.__r3f)!=null?t:{},o=r.root,a=(s=o==null||o.getState==null?void 0:o.getState())!=null?s:{},{memoized:l,changes:c}=b2e(e)?e:q5(n,e),u=r.eventCount;n.__r3f&&(n.__r3f.memoizedProps=l);for(let f=0;f<c.length;f++){let[m,x,y,v]=c[f],w=n,b=w[m];if(v.length&&(b=v.reduce((S,C)=>S[C],n),!(b&&b.set))){const[S,...C]=v.reverse();w=C.reverse().reduce((E,k)=>E[k],n),m=S}if(x===X5+"remove")if(w.constructor){var h;const S=new w.constructor(...(h=w.__r3f.memoizedProps.args)!=null?h:[]);x=S[m],S.dispose&&S.dispose()}else x=0;if(y)x?r.handlers[m]=x:delete r.handlers[m],r.eventCount=Object.keys(r.handlers).length;else if(b&&b.set&&(b.copy||b instanceof Hu)){if(Array.isArray(x))b.fromArray?b.fromArray(x):b.set(...x);else if(b.copy&&x&&x.constructor&&b.constructor.name===x.constructor.name)b.copy(x);else if(x!==void 0){const S=b instanceof Je;!S&&b.setScalar?b.setScalar(x):b instanceof Hu&&x instanceof Hu?b.mask=x.mask:b.set(x),!("ColorManagement"in W1)&&!a.linear&&S&&b.convertSRGBToLinear()}}else w[m]=x,!a.linear&&w[m]instanceof ns&&(w[m].encoding=En);vd(n)}if(r.parent&&a.internal&&n.raycast&&u!==r.eventCount){const f=a.internal.interaction.indexOf(n);f>-1&&a.internal.interaction.splice(f,1),r.eventCount&&a.internal.interaction.push(n)}return!(c.length===1&&c[0][0]==="onUpdate")&&c.length&&(i=n.__r3f)!=null&&i.parent&&hI(n),n}function vd(n){var e,t;const s=(e=n.__r3f)==null||(t=e.root)==null||t.getState==null?void 0:t.getState();s&&s.internal.frames===0&&s.invalidate()}function hI(n){n.onUpdate==null||n.onUpdate(n)}function _2e(n,e){n.manual||(W5(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix(),n.updateMatrixWorld())}function C2e(n,e,t){const s=t.pop(),i=t.reduce((r,o)=>r[o],n);return i[s]=e}function hv(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function T2e(){var n;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return Pu.exports.DefaultEventPriority;switch((n=e.event)==null?void 0:n.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return Pu.exports.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return Pu.exports.ContinuousEventPriority;default:return Pu.exports.DefaultEventPriority}}function K5(n,e,t,s){const i=t.get(e);i&&(t.delete(e),t.size===0&&(n.delete(s),i.target.releasePointerCapture(s)))}function I2e(n,e){const{internal:t}=n.getState();t.interaction=t.interaction.filter(s=>s!==e),t.initialHits=t.initialHits.filter(s=>s!==e),t.hovered.forEach((s,i)=>{(s.eventObject===e||s.object===e)&&t.hovered.delete(i)}),t.capturedMap.forEach((s,i)=>{K5(t.capturedMap,e,s,i)})}function E2e(n){function e(l){const{internal:c}=n.getState(),u=l.offsetX-c.initialClick[0],h=l.offsetY-c.initialClick[1];return Math.round(Math.sqrt(u*u+h*h))}function t(l){return l.filter(c=>["Move","Over","Enter","Out","Leave"].some(u=>{var h;return(h=c.__r3f)==null?void 0:h.handlers["onPointer"+u]}))}function s(l,c){const u=n.getState(),h=new Set,d=[],f=c?c(u.internal.interaction):u.internal.interaction;for(let v=0;v<f.length;v++){const w=Fp(f[v]);w&&(w.raycaster.camera=void 0)}u.previousRoot||u.events.compute==null||u.events.compute(l,u);function m(v){const w=Fp(v);if(!w||!w.events.enabled||w.raycaster.camera===null)return[];if(w.raycaster.camera===void 0){var b;w.events.compute==null||w.events.compute(l,w,(b=w.previousRoot)==null?void 0:b.getState()),w.raycaster.camera===void 0&&(w.raycaster.camera=null)}return w.raycaster.camera?w.raycaster.intersectObject(v,!0):[]}let x=f.flatMap(m).sort((v,w)=>{const b=Fp(v.object),S=Fp(w.object);return!b||!S?v.distance-w.distance:S.events.priority-b.events.priority||v.distance-w.distance}).filter(v=>{const w=hv(v);return h.has(w)?!1:(h.add(w),!0)});u.events.filter&&(x=u.events.filter(x,u));for(const v of x){let w=v.object;for(;w;){var y;(y=w.__r3f)!=null&&y.eventCount&&d.push({...v,eventObject:w}),w=w.parent}}if("pointerId"in l&&u.internal.capturedMap.has(l.pointerId))for(let v of u.internal.capturedMap.get(l.pointerId).values())h.has(hv(v.intersection))||d.push(v.intersection);return d}function i(l,c,u,h){const d=n.getState();if(l.length){const f={stopped:!1};for(const m of l){const x=Fp(m.object)||d,{raycaster:y,pointer:v,camera:w,internal:b}=x,S=new G(v.x,v.y,0).unproject(w),C=N=>{var L,V;return(L=(V=b.capturedMap.get(N))==null?void 0:V.has(m.eventObject))!=null?L:!1},E=N=>{const L={intersection:m,target:c.target};b.capturedMap.has(N)?b.capturedMap.get(N).set(m.eventObject,L):b.capturedMap.set(N,new Map([[m.eventObject,L]])),c.target.setPointerCapture(N)},k=N=>{const L=b.capturedMap.get(N);L&&K5(b.capturedMap,m.eventObject,L,N)};let I={};for(let N in c){let L=c[N];typeof L!="function"&&(I[N]=L)}let A={...m,...I,pointer:v,intersections:l,stopped:f.stopped,delta:u,unprojectedPoint:S,ray:y.ray,camera:w,stopPropagation(){const N="pointerId"in c&&b.capturedMap.get(c.pointerId);if((!N||N.has(m.eventObject))&&(A.stopped=f.stopped=!0,b.hovered.size&&Array.from(b.hovered.values()).find(L=>L.eventObject===m.eventObject))){const L=l.slice(0,l.indexOf(m));r([...L,m])}},target:{hasPointerCapture:C,setPointerCapture:E,releasePointerCapture:k},currentTarget:{hasPointerCapture:C,setPointerCapture:E,releasePointerCapture:k},nativeEvent:c};if(h(A),f.stopped===!0)break}}return l}function r(l){const{internal:c}=n.getState();for(const u of c.hovered.values())if(!l.length||!l.find(h=>h.object===u.object&&h.index===u.index&&h.instanceId===u.instanceId)){const d=u.eventObject.__r3f,f=d==null?void 0:d.handlers;if(c.hovered.delete(hv(u)),d!=null&&d.eventCount){const m={...u,intersections:l};f.onPointerOut==null||f.onPointerOut(m),f.onPointerLeave==null||f.onPointerLeave(m)}}}function o(l,c){for(let u=0;u<c.length;u++){const h=c[u].__r3f;h==null||h.handlers.onPointerMissed==null||h.handlers.onPointerMissed(l)}}function a(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>r([]);case"onLostPointerCapture":return c=>{const{internal:u}=n.getState();"pointerId"in c&&u.capturedMap.has(c.pointerId)&&(u.capturedMap.delete(c.pointerId),r([]))}}return function(u){const{onPointerMissed:h,internal:d}=n.getState();d.lastEvent.current=u;const f=l==="onPointerMove",m=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",y=s(u,f?t:void 0),v=m?e(u):0;l==="onPointerDown"&&(d.initialClick=[u.offsetX,u.offsetY],d.initialHits=y.map(b=>b.eventObject)),m&&!y.length&&v<=2&&(o(u,d.interaction),h&&h(u)),f&&r(y);function w(b){const S=b.eventObject,C=S.__r3f,E=C==null?void 0:C.handlers;if(!!(C!=null&&C.eventCount))if(f){if(E.onPointerOver||E.onPointerEnter||E.onPointerOut||E.onPointerLeave){const k=hv(b),I=d.hovered.get(k);I?I.stopped&&b.stopPropagation():(d.hovered.set(k,b),E.onPointerOver==null||E.onPointerOver(b),E.onPointerEnter==null||E.onPointerEnter(b))}E.onPointerMove==null||E.onPointerMove(b)}else{const k=E[l];k?(!m||d.initialHits.includes(S))&&(o(u,d.interaction.filter(I=>!d.initialHits.includes(I))),k(b)):m&&d.initialHits.includes(S)&&o(u,d.interaction.filter(I=>!d.initialHits.includes(I)))}}i(y,u,v,w)}}return{handlePointer:a}}let dI={},M2e=n=>void(dI={...dI,...n});function k2e(n,e){function t(u,{args:h=[],attach:d,...f},m){let x=`${u[0].toUpperCase()}${u.slice(1)}`,y;if(u==="primitive"){if(f.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const v=f.object;y=yd(v,{type:u,root:m,attach:d,primitive:!0})}else{const v=dI[x];if(!v)throw new Error(`R3F: ${x} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(h))throw new Error("R3F: The args prop must be an array!");y=yd(new v(...h),{type:u,root:m,attach:d,memoizedProps:{args:h}})}return y.__r3f.attach===void 0&&(y instanceof Bt?y.__r3f.attach="geometry":y instanceof li&&(y.__r3f.attach="material")),x!=="inject"&&$C(y,f),y}function s(u,h){let d=!1;if(h){var f,m;(f=h.__r3f)!=null&&f.attach?PC(u,h,h.__r3f.attach):h.isObject3D&&u.isObject3D&&(u.add(h),d=!0),d||(m=u.__r3f)==null||m.objects.push(h),h.__r3f||yd(h,{}),h.__r3f.parent=u,hI(h),vd(h)}}function i(u,h,d){let f=!1;if(h){var m,x;if((m=h.__r3f)!=null&&m.attach)PC(u,h,h.__r3f.attach);else if(h.isObject3D&&u.isObject3D){h.parent=u,h.dispatchEvent({type:"added"});const y=u.children.filter(w=>w!==h),v=y.indexOf(d);u.children=[...y.slice(0,v),h,...y.slice(v)],f=!0}f||(x=u.__r3f)==null||x.objects.push(h),h.__r3f||yd(h,{}),h.__r3f.parent=u,hI(h),vd(h)}}function r(u,h,d=!1){u&&[...u].forEach(f=>o(h,f,d))}function o(u,h,d){if(h){var f,m,x;if(h.__r3f&&(h.__r3f.parent=null),(f=u.__r3f)!=null&&f.objects&&(u.__r3f.objects=u.__r3f.objects.filter(S=>S!==h)),(m=h.__r3f)!=null&&m.attach)PP(u,h,h.__r3f.attach);else if(h.isObject3D&&u.isObject3D){var y;u.remove(h),(y=h.__r3f)!=null&&y.root&&I2e(h.__r3f.root,h)}const w=(x=h.__r3f)==null?void 0:x.primitive,b=d===void 0?h.dispose!==null&&!w:d;if(!w){var v;r((v=h.__r3f)==null?void 0:v.objects,h,b),r(h.children,h,b)}h.__r3f&&(delete h.__r3f.root,delete h.__r3f.objects,delete h.__r3f.handlers,delete h.__r3f.memoizedProps,w||delete h.__r3f),b&&h.dispose&&h.type!=="Scene"&&G1.exports.unstable_scheduleCallback(G1.exports.unstable_IdlePriority,()=>{try{h.dispose()}catch{}}),vd(u)}}function a(u,h,d,f){var m;const x=(m=u.__r3f)==null?void 0:m.parent;if(!x)return;const y=t(h,d,u.__r3f.root);if(u.children){for(const v of u.children)v.__r3f&&s(y,v);u.children=u.children.filter(v=>!v.__r3f)}u.__r3f.objects.forEach(v=>s(y,v)),u.__r3f.objects=[],u.__r3f.autoRemovedBeforeAppend||o(x,u),y.parent&&(y.__r3f.autoRemovedBeforeAppend=!0),s(x,y),y.raycast&&y.__r3f.eventCount&&y.__r3f.root.getState().internal.interaction.push(y),[f,f.alternate].forEach(v=>{v!==null&&(v.stateNode=y,v.ref&&(typeof v.ref=="function"?v.ref(y):v.ref.current=y))})}const l=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:d2e({createInstance:t,removeChild:o,appendChild:s,appendInitialChild:s,insertBefore:i,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(u,h)=>{if(!h)return;const d=u.getState().scene;!d.__r3f||(d.__r3f.root=u,s(d,h))},removeChildFromContainer:(u,h)=>{!h||o(u.getState().scene,h)},insertInContainerBefore:(u,h,d)=>{if(!h||!d)return;const f=u.getState().scene;!f.__r3f||i(f,h,d)},getRootHostContext:()=>null,getChildHostContext:u=>u,finalizeInitialChildren(u){var h;const d=(h=u==null?void 0:u.__r3f)!=null?h:{};return Boolean(d.handlers)},prepareUpdate(u,h,d,f){if(u.__r3f.primitive&&f.object&&f.object!==u)return[!0];{const{args:m=[],children:x,...y}=f,{args:v=[],children:w,...b}=d;if(!Array.isArray(m))throw new Error("R3F: the args prop must be an array!");if(m.some((C,E)=>C!==v[E]))return[!0];const S=q5(u,y,b,!0);return S.changes.length?[!1,S]:null}},commitUpdate(u,[h,d],f,m,x,y){h?a(u,f,x,y):$C(u,d)},commitMount(u,h,d,f){var m;const x=(m=u.__r3f)!=null?m:{};u.raycast&&x.handlers&&x.eventCount&&u.__r3f.root.getState().internal.interaction.push(u)},getPublicInstance:u=>u,prepareForCommit:()=>null,preparePortalMount:u=>yd(u.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(u){var h;const{attach:d,parent:f}=(h=u.__r3f)!=null?h:{};d&&f&&PP(f,u,d),u.isObject3D&&(u.visible=!1),vd(u)},unhideInstance(u,h){var d;const{attach:f,parent:m}=(d=u.__r3f)!=null?d:{};f&&m&&PC(m,u,f),(u.isObject3D&&h.visible==null||h.visible)&&(u.visible=!0),vd(u)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:()=>e?e():Pu.exports.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&es.fun(performance.now)?performance.now:es.fun(Date.now)?Date.now:()=>0,scheduleTimeout:es.fun(setTimeout)?setTimeout:void 0,cancelTimeout:es.fun(clearTimeout)?clearTimeout:void 0}),applyProps:$C}}const Y5=n=>!!(n!=null&&n.render),Z5=qe.exports.createContext(null),A2e=(n,e)=>{const t=u2e((a,l)=>{const c=new G,u=new G,h=new G;function d(v=l().camera,w=u,b=l().size){const{width:S,height:C,top:E,left:k}=b,I=S/C;w instanceof G?h.copy(w):h.set(...w);const A=v.getWorldPosition(c).distanceTo(h);if(W5(v))return{width:S/v.zoom,height:C/v.zoom,top:E,left:k,factor:1,distance:A,aspect:I};{const N=v.fov*Math.PI/180,L=2*Math.tan(N/2)*A,V=L*(S/C);return{width:V,height:L,top:E,left:k,factor:S/V,distance:A,aspect:I}}}let f;const m=v=>a(w=>({performance:{...w.performance,current:v}})),x=new Ae;return{set:a,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,invalidate:(v=1)=>n(l(),v),advance:(v,w)=>e(v,w,l()),legacy:!1,linear:!1,flat:!1,scene:yd(new cA),controls:null,clock:new AA,pointer:x,mouse:x,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const v=l();f&&clearTimeout(f),v.performance.current!==v.performance.min&&m(v.performance.min),f=setTimeout(()=>m(l().performance.max),v.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:d},setEvents:v=>a(w=>({...w,events:{...w.events,...v}})),setSize:(v,w,b,S,C)=>{const E=l().camera,k={width:v,height:w,top:S||0,left:C||0,updateStyle:b};a(I=>({size:k,viewport:{...I.viewport,...d(E,u,k)}}))},setDpr:v=>a(w=>{const b=j5(v);return{viewport:{...w.viewport,dpr:b,initialDpr:w.viewport.initialDpr||b}}}),setFrameloop:(v="always")=>{const w=l().clock;w.stop(),w.elapsedTime=0,v!=="never"&&(w.start(),w.elapsedTime=0),a(()=>({frameloop:v}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:qe.exports.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(v,w,b)=>{const S=l().internal;return S.priority=S.priority+(w>0?1:0),S.subscribers.push({ref:v,priority:w,store:b}),S.subscribers=S.subscribers.sort((C,E)=>C.priority-E.priority),()=>{const C=l().internal;C!=null&&C.subscribers&&(C.priority=C.priority-(w>0?1:0),C.subscribers=C.subscribers.filter(E=>E.ref!==v))}}}}}),s=t.getState();let i=s.size,r=s.viewport.dpr,o=s.camera;return t.subscribe(()=>{const{camera:a,size:l,viewport:c,gl:u,set:h}=t.getState();(l!==i||c.dpr!==r)&&(i=l,r=c.dpr,_2e(a,l),u.setPixelRatio(c.dpr),u.setSize(l.width,l.height,l.updateStyle)),a!==o&&(o=a,h(d=>({viewport:{...d.viewport,...d.viewport.getCurrentViewport(a)}})))}),t.subscribe(a=>n(a)),t};let dv,N2e=new Set,R2e=new Set,D2e=new Set;function FC(n,e){if(!!n.size)for(const{callback:t}of n.values())t(e)}function Op(n,e){switch(n){case"before":return FC(N2e,e);case"after":return FC(R2e,e);case"tail":return FC(D2e,e)}}let OC,zC;function BC(n,e,t){let s=e.clock.getDelta();for(e.frameloop==="never"&&typeof n=="number"&&(s=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),OC=e.internal.subscribers,dv=0;dv<OC.length;dv++)zC=OC[dv],zC.ref.current(zC.store.getState(),s,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function L2e(n){let e=!1,t,s,i;function r(l){s=requestAnimationFrame(r),e=!0,t=0,Op("before",l);for(const u of n.values()){var c;i=u.store.getState(),i.internal.active&&(i.frameloop==="always"||i.internal.frames>0)&&!((c=i.gl.xr)!=null&&c.isPresenting)&&(t+=BC(l,i))}if(Op("after",l),t===0)return Op("tail",l),e=!1,cancelAnimationFrame(s)}function o(l,c=1){var u;if(!l)return n.forEach(h=>o(h.store.getState()),c);(u=l.gl.xr)!=null&&u.isPresenting||!l.internal.active||l.frameloop==="never"||(l.internal.frames=Math.min(60,l.internal.frames+c),e||(e=!0,requestAnimationFrame(r)))}function a(l,c=!0,u,h){if(c&&Op("before",l),u)BC(l,u,h);else for(const d of n.values())BC(l,d.store.getState());c&&Op("after",l)}return{loop:r,invalidate:o,advance:a}}function J5(){const n=qe.exports.useContext(Z5);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function Gl(n=t=>t,e){return J5()(n,e)}function Q5(n,e=0){const t=J5(),s=t.getState().internal.subscribe,i=G5(n);return Z0(()=>s(i,e,t),[e,s,t]),null}const _f=new Map,{invalidate:$P,advance:FP}=L2e(_f),{reconciler:H1,applyProps:fv}=k2e(_f,T2e),zp={objects:"shallow",strict:!1},P2e=(n,e)=>{const t=typeof n=="function"?n(e):n;return Y5(t)?t:new lA({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...n})};function $2e(n){return n instanceof HTMLCanvasElement}function F2e(n,e){if(e)return e;if($2e(n)&&n.parentElement){const{width:t,height:s,top:i,left:r}=n.parentElement.getBoundingClientRect();return{width:t,height:s,top:i,left:r}}return{width:0,height:0,top:0,left:0}}function O2e(n){const e=_f.get(n),t=e==null?void 0:e.fiber,s=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,r=s||A2e($P,FP),o=t||H1.createContainer(r,Pu.exports.ConcurrentRoot,null,!1,null,"",i,null);e||_f.set(n,{fiber:o,store:r});let a,l=!1;return{configure(c={}){let{gl:u,size:h,events:d,onCreated:f,shadows:m=!1,linear:x=!1,flat:y=!1,legacy:v=!1,orthographic:w=!1,frameloop:b="always",dpr:S=[1,2],performance:C,raycaster:E,camera:k,onPointerMissed:I}=c,A=r.getState(),N=A.gl;A.gl||A.set({gl:N=P2e(u,n)});let L=A.raycaster;L||A.set({raycaster:L=new F5});const{params:V,...O}=E||{};if(es.equ(O,L,zp)||fv(L,{...O}),es.equ(V,L.params,zp)||fv(L,{params:{...L.params,...V}}),!A.camera){const D=k instanceof $0,$=D?k:w?new xc(0,0,0,0,.1,1e3):new Un(75,0,.1,1e3);D||($.position.z=5,k&&fv($,k),k!=null&&k.rotation||$.lookAt(0,0,0)),A.set({camera:$})}if(!A.xr){const D=(B,X)=>{const te=r.getState();te.frameloop!=="never"&&FP(B,!0,te,X)},$=()=>{const B=r.getState();B.gl.xr.enabled=B.gl.xr.isPresenting,B.gl.xr.setAnimationLoop(B.gl.xr.isPresenting?D:null),B.gl.xr.isPresenting||$P(B)},U={connect(){const B=r.getState().gl;B.xr.addEventListener("sessionstart",$),B.xr.addEventListener("sessionend",$)},disconnect(){const B=r.getState().gl;B.xr.removeEventListener("sessionstart",$),B.xr.removeEventListener("sessionend",$)}};N.xr&&U.connect(),A.set({xr:U})}if(N.shadowMap){const D=N.shadowMap.enabled,$=N.shadowMap.type;if(N.shadowMap.enabled=!!m,es.boo(m))N.shadowMap.type=um;else if(es.str(m)){var P;const U={basic:VW,percentage:zb,soft:um,variance:Au};N.shadowMap.type=(P=U[m])!=null?P:um}else es.obj(m)&&Object.assign(N.shadowMap,m);(D!==N.shadowMap.enabled||$!==N.shadowMap.type)&&(N.shadowMap.needsUpdate=!0)}"ColorManagement"in W1&&C2e(W1,v,["ColorManagement","legacyMode"]);const W=x?gl:En,H=y?Uo:Yk;N.outputEncoding!==W&&(N.outputEncoding=W),N.toneMapping!==H&&(N.toneMapping=H),A.legacy!==v&&A.set(()=>({legacy:v})),A.linear!==x&&A.set(()=>({linear:x})),A.flat!==y&&A.set(()=>({flat:y})),u&&!es.fun(u)&&!Y5(u)&&!es.equ(u,N,zp)&&fv(N,u),d&&!A.events.handlers&&A.set({events:d(r)}),S&&A.viewport.dpr!==j5(S)&&A.setDpr(S);const Y=F2e(n,h);return es.equ(Y,A.size,zp)||A.setSize(Y.width,Y.height,Y.updateStyle,Y.top,Y.left),A.frameloop!==b&&A.setFrameloop(b),A.onPointerMissed||A.set({onPointerMissed:I}),C&&!es.equ(C,A.performance,zp)&&A.set(D=>({performance:{...D.performance,...C}})),a=f,l=!0,this},render(c){return l||this.configure(),H1.updateContainer(Kt(z2e,{store:r,children:c,onCreated:a,rootElement:n}),o,null,()=>{}),r},unmount(){eH(n)}}}function z2e({store:n,children:e,onCreated:t,rootElement:s}){return Z0(()=>{const i=n.getState();i.set(r=>({internal:{...r.internal,active:!0}})),t&&t(i),n.getState().events.connected||i.events.connect==null||i.events.connect(s)},[]),qe.exports.createElement(Z5.Provider,{value:n},e)}function eH(n,e){const t=_f.get(n),s=t==null?void 0:t.fiber;if(s){const i=t==null?void 0:t.store.getState();i&&(i.internal.active=!1),H1.updateContainer(null,s,null,()=>{i&&setTimeout(()=>{try{var r,o,a,l;i.events.disconnect==null||i.events.disconnect(),(r=i.gl)==null||(o=r.renderLists)==null||o.dispose==null||o.dispose(),(a=i.gl)==null||a.forceContextLoss==null||a.forceContextLoss(),(l=i.gl)!=null&&l.xr&&i.xr.disconnect(),S2e(i),_f.delete(n),e&&e(n)}catch{}},500)})}}H1.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:qe.exports.version});function fI(n,e,t){var s,i,r,o,a;e==null&&(e=100);function l(){var u=Date.now()-o;u<e&&u>=0?s=setTimeout(l,e-u):(s=null,t||(a=n.apply(r,i),r=i=null))}var c=function(){r=this,i=arguments,o=Date.now();var u=t&&!s;return s||(s=setTimeout(l,e)),u&&(a=n.apply(r,i),r=i=null),a};return c.clear=function(){s&&(clearTimeout(s),s=null)},c.flush=function(){s&&(a=n.apply(r,i),r=i=null,clearTimeout(s),s=null)},c}fI.debounce=fI;var OP=fI;function B2e(n){let{debounce:e,scroll:t,polyfill:s,offsetSize:i}=n===void 0?{debounce:0,scroll:!1,offsetSize:!1}:n;const r=s||(typeof window>"u"?class{}:window.ResizeObserver);if(!r)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[o,a]=qe.exports.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),l=qe.exports.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:o}),c=e?typeof e=="number"?e:e.scroll:null,u=e?typeof e=="number"?e:e.resize:null,h=qe.exports.useRef(!1);qe.exports.useEffect(()=>(h.current=!0,()=>void(h.current=!1)));const[d,f,m]=qe.exports.useMemo(()=>{const w=()=>{if(!l.current.element)return;const{left:b,top:S,width:C,height:E,bottom:k,right:I,x:A,y:N}=l.current.element.getBoundingClientRect(),L={left:b,top:S,width:C,height:E,bottom:k,right:I,x:A,y:N};l.current.element instanceof HTMLElement&&i&&(L.height=l.current.element.offsetHeight,L.width=l.current.element.offsetWidth),Object.freeze(L),h.current&&!G2e(l.current.lastBounds,L)&&a(l.current.lastBounds=L)};return[w,u?OP(w,u):w,c?OP(w,c):w]},[a,i,c,u]);function x(){l.current.scrollContainers&&(l.current.scrollContainers.forEach(w=>w.removeEventListener("scroll",m,!0)),l.current.scrollContainers=null),l.current.resizeObserver&&(l.current.resizeObserver.disconnect(),l.current.resizeObserver=null)}function y(){!l.current.element||(l.current.resizeObserver=new r(m),l.current.resizeObserver.observe(l.current.element),t&&l.current.scrollContainers&&l.current.scrollContainers.forEach(w=>w.addEventListener("scroll",m,{capture:!0,passive:!0})))}const v=w=>{!w||w===l.current.element||(x(),l.current.element=w,l.current.scrollContainers=tH(w),y())};return V2e(m,Boolean(t)),U2e(f),qe.exports.useEffect(()=>{x(),y()},[t,m,f]),qe.exports.useEffect(()=>x,[]),[v,o,d]}function U2e(n){qe.exports.useEffect(()=>{const e=n;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[n])}function V2e(n,e){qe.exports.useEffect(()=>{if(e){const t=n;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[n,e])}function tH(n){const e=[];if(!n||n===document.body)return e;const{overflow:t,overflowX:s,overflowY:i}=window.getComputedStyle(n);return[t,s,i].some(r=>r==="auto"||r==="scroll")&&e.push(n),[...e,...tH(n.parentElement)]}const W2e=["x","y","top","bottom","left","right","width","height"],G2e=(n,e)=>W2e.every(t=>n[t]===e[t]);var H2e=Object.defineProperty,X2e=Object.defineProperties,j2e=Object.getOwnPropertyDescriptors,zP=Object.getOwnPropertySymbols,q2e=Object.prototype.hasOwnProperty,K2e=Object.prototype.propertyIsEnumerable,BP=(n,e,t)=>e in n?H2e(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,UP=(n,e)=>{for(var t in e||(e={}))q2e.call(e,t)&&BP(n,t,e[t]);if(zP)for(var t of zP(e))K2e.call(e,t)&&BP(n,t,e[t]);return n},Y2e=(n,e)=>X2e(n,j2e(e));function nH(n,e,t){if(!n)return;if(t(n)===!0)return n;let s=e?n.return:n.child;for(;s;){const i=nH(s,e,t);if(i)return i;s=e?null:s.sibling}}function sH(n){try{return Object.defineProperties(n,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return n}}const LA=sH(qe.exports.createContext(null));class iH extends qe.exports.Component{render(){return Kt(LA.Provider,{value:this._reactInternals,children:this.props.children})}}const{ReactCurrentOwner:Z2e,ReactCurrentDispatcher:J2e}=qe.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function Q2e(){const n=qe.exports.useContext(LA);if(!n)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=qe.exports.useId();return qe.exports.useMemo(()=>{var s;return(s=Z2e.current)!=null?s:nH(n,!1,i=>{let r=i.memoizedState;for(;r;){if(r.memoizedState===e)return!0;r=r.next}})},[n,e])}function eTe(){var n,e;const t=Q2e(),[s]=qe.exports.useState(()=>new Map);s.clear();let i=t;for(;i;){const r=(n=i.type)==null?void 0:n._context;r&&r!==LA&&!s.has(r)&&s.set(r,(e=J2e.current)==null?void 0:e.readContext(sH(r))),i=i.return}return qe.exports.useMemo(()=>Array.from(s.keys()).reduce((r,o)=>a=>qe.exports.createElement(r,null,qe.exports.createElement(o.Provider,Y2e(UP({},a),{value:s.get(o)}))),r=>Kt(iH,{...UP({},r)})),[s])}const UC={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function tTe(n){const{handlePointer:e}=E2e(n);return{priority:1,enabled:!0,compute(t,s,i){s.pointer.set(t.offsetX/s.size.width*2-1,-(t.offsetY/s.size.height)*2+1),s.raycaster.setFromCamera(s.pointer,s.camera)},connected:void 0,handlers:Object.keys(UC).reduce((t,s)=>({...t,[s]:e(s)}),{}),update:()=>{var t;const{events:s,internal:i}=n.getState();(t=i.lastEvent)!=null&&t.current&&s.handlers&&s.handlers.onPointerMove(i.lastEvent.current)},connect:t=>{var s;const{set:i,events:r}=n.getState();r.disconnect==null||r.disconnect(),i(o=>({events:{...o.events,connected:t}})),Object.entries((s=r.handlers)!=null?s:[]).forEach(([o,a])=>{const[l,c]=UC[o];t.addEventListener(l,a,{passive:c})})},disconnect:()=>{const{set:t,events:s}=n.getState();if(s.connected){var i;Object.entries((i=s.handlers)!=null?i:[]).forEach(([r,o])=>{if(s&&s.connected instanceof HTMLElement){const[a]=UC[r];s.connected.removeEventListener(a,o)}}),t(r=>({events:{...r.events,connected:void 0}}))}}}}const nTe=qe.exports.forwardRef(function({children:e,fallback:t,resize:s,style:i,gl:r,events:o=tTe,eventSource:a,eventPrefix:l,shadows:c,linear:u,flat:h,legacy:d,orthographic:f,frameloop:m,dpr:x,performance:y,raycaster:v,camera:w,onPointerMissed:b,onCreated:S,...C},E){qe.exports.useMemo(()=>M2e(W1),[]);const k=eTe(),[I,A]=B2e({scroll:!0,debounce:{scroll:50,resize:0},...s}),N=qe.exports.useRef(null),L=qe.exports.useRef(null),[V,O]=qe.exports.useState(null);qe.exports.useImperativeHandle(E,()=>N.current);const P=G5(b),[W,H]=qe.exports.useState(!1),[Y,D]=qe.exports.useState(!1);if(W)throw W;if(Y)throw Y;const $=qe.exports.useRef(null);return A.width>0&&A.height>0&&V&&($.current||($.current=O2e(V)),$.current.configure({gl:r,events:o,shadows:c,linear:u,flat:h,legacy:d,orthographic:f,frameloop:m,dpr:x,performance:y,raycaster:v,camera:w,size:A,onPointerMissed:(...B)=>P.current==null?void 0:P.current(...B),onCreated:B=>{B.events.connect==null||B.events.connect(a?v2e(a)?a.current:a:L.current),l&&B.setEvents({compute:(X,te)=>{const oe=X[l+"X"],ue=X[l+"Y"];te.pointer.set(oe/te.size.width*2-1,-(ue/te.size.height)*2+1),te.raycaster.setFromCamera(te.pointer,te.camera)}}),S==null||S(B)}}),$.current.render(Kt(k,{children:Kt(H5,{set:D,children:Kt(qe.exports.Suspense,{fallback:Kt(w2e,{set:H}),children:e})})}))),Z0(()=>{O(N.current)},[]),qe.exports.useEffect(()=>{if(V)return()=>eH(V)},[V]),Kt("div",{ref:L,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:a?"none":"auto",...i},...C,children:Kt("div",{ref:I,style:{width:"100%",height:"100%"},children:Kt("canvas",{ref:N,style:{display:"block"},children:t})})})}),sTe=qe.exports.forwardRef(function(e,t){return Kt(iH,{children:Kt(nTe,{...e,ref:t})})});function og(n){return og=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},og(n)}function iTe(n,e){if(og(n)!=="object"||n===null)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e||"default");if(og(s)!=="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function rTe(n){var e=iTe(n,"string");return og(e)==="symbol"?e:String(e)}function Rt(n,e,t){return e=rTe(e),e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}const VP=(n,e)=>(n%e+e)%e;class oTe extends Na{constructor(e,t){super(),Rt(this,"object",void 0),Rt(this,"domElement",void 0),Rt(this,"enabled",!0),Rt(this,"target",new G),Rt(this,"minDistance",0),Rt(this,"maxDistance",1/0),Rt(this,"minZoom",0),Rt(this,"maxZoom",1/0),Rt(this,"minPolarAngle",0),Rt(this,"maxPolarAngle",Math.PI),Rt(this,"minAzimuthAngle",-1/0),Rt(this,"maxAzimuthAngle",1/0),Rt(this,"enableDamping",!1),Rt(this,"dampingFactor",.05),Rt(this,"enableZoom",!0),Rt(this,"zoomSpeed",1),Rt(this,"enableRotate",!0),Rt(this,"rotateSpeed",1),Rt(this,"enablePan",!0),Rt(this,"panSpeed",1),Rt(this,"screenSpacePanning",!0),Rt(this,"keyPanSpeed",7),Rt(this,"autoRotate",!1),Rt(this,"autoRotateSpeed",2),Rt(this,"reverseOrbit",!1),Rt(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),Rt(this,"mouseButtons",{LEFT:gu.ROTATE,MIDDLE:gu.DOLLY,RIGHT:gu.PAN}),Rt(this,"touches",{ONE:xu.ROTATE,TWO:xu.DOLLY_PAN}),Rt(this,"target0",void 0),Rt(this,"position0",void 0),Rt(this,"zoom0",void 0),Rt(this,"_domElementKeyEvents",null),Rt(this,"getPolarAngle",void 0),Rt(this,"getAzimuthalAngle",void 0),Rt(this,"setPolarAngle",void 0),Rt(this,"setAzimuthalAngle",void 0),Rt(this,"getDistance",void 0),Rt(this,"listenToKeyEvents",void 0),Rt(this,"saveState",void 0),Rt(this,"reset",void 0),Rt(this,"update",void 0),Rt(this,"connect",void 0),Rt(this,"dispose",void 0),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object instanceof Un?this.object.zoom:1,this.getPolarAngle=()=>u.phi,this.getAzimuthalAngle=()=>u.theta,this.setPolarAngle=J=>{let ve=VP(J,2*Math.PI),Oe=u.phi;Oe<0&&(Oe+=2*Math.PI),ve<0&&(ve+=2*Math.PI);let Ge=Math.abs(ve-Oe);2*Math.PI-Ge<Ge&&(ve<Oe?ve+=2*Math.PI:Oe+=2*Math.PI),h.phi=ve-Oe,s.update()},this.setAzimuthalAngle=J=>{let ve=VP(J,2*Math.PI),Oe=u.theta;Oe<0&&(Oe+=2*Math.PI),ve<0&&(ve+=2*Math.PI);let Ge=Math.abs(ve-Oe);2*Math.PI-Ge<Ge&&(ve<Oe?ve+=2*Math.PI:Oe+=2*Math.PI),h.theta=ve-Oe,s.update()},this.getDistance=()=>s.object.position.distanceTo(s.target),this.listenToKeyEvents=J=>{J.addEventListener("keydown",ge),this._domElementKeyEvents=J},this.saveState=()=>{s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object instanceof Un?s.object.zoom:1},this.reset=()=>{s.target.copy(s.target0),s.object.position.copy(s.position0),s.object instanceof Un&&(s.object.zoom=s.zoom0,s.object.updateProjectionMatrix()),s.dispatchEvent(i),s.update(),l=a.NONE},this.update=(()=>{const J=new G,ve=new _i().setFromUnitVectors(e.up,new G(0,1,0)),Oe=ve.clone().invert(),Ge=new G,St=new _i,Xt=2*Math.PI;return function(){const ie=s.object.position;J.copy(ie).sub(s.target),J.applyQuaternion(ve),u.setFromVector3(J),s.autoRotate&&l===a.NONE&&V(N()),s.enableDamping?(u.theta+=h.theta*s.dampingFactor,u.phi+=h.phi*s.dampingFactor):(u.theta+=h.theta,u.phi+=h.phi);let _e=s.minAzimuthAngle,Fe=s.maxAzimuthAngle;return isFinite(_e)&&isFinite(Fe)&&(_e<-Math.PI?_e+=Xt:_e>Math.PI&&(_e-=Xt),Fe<-Math.PI?Fe+=Xt:Fe>Math.PI&&(Fe-=Xt),_e<=Fe?u.theta=Math.max(_e,Math.min(Fe,u.theta)):u.theta=u.theta>(_e+Fe)/2?Math.max(_e,u.theta):Math.min(Fe,u.theta)),u.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,u.phi)),u.makeSafe(),u.radius*=d,u.radius=Math.max(s.minDistance,Math.min(s.maxDistance,u.radius)),s.enableDamping===!0?s.target.addScaledVector(f,s.dampingFactor):s.target.add(f),J.setFromSpherical(u),J.applyQuaternion(Oe),ie.copy(s.target).add(J),s.object.lookAt(s.target),s.enableDamping===!0?(h.theta*=1-s.dampingFactor,h.phi*=1-s.dampingFactor,f.multiplyScalar(1-s.dampingFactor)):(h.set(0,0,0),f.set(0,0,0)),d=1,m||Ge.distanceToSquared(s.object.position)>c||8*(1-St.dot(s.object.quaternion))>c?(s.dispatchEvent(i),Ge.copy(s.object.position),St.copy(s.object.quaternion),m=!1,!0):!1}})(),this.connect=J=>{J===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),s.domElement=J,s.domElement.style.touchAction="none",s.domElement.addEventListener("contextmenu",Xe),s.domElement.addEventListener("pointerdown",nt),s.domElement.addEventListener("pointercancel",vt),s.domElement.addEventListener("wheel",z)},this.dispose=()=>{var J,ve,Oe,Ge,St,Xt;(J=s.domElement)===null||J===void 0||J.removeEventListener("contextmenu",Xe),(ve=s.domElement)===null||ve===void 0||ve.removeEventListener("pointerdown",nt),(Oe=s.domElement)===null||Oe===void 0||Oe.removeEventListener("pointercancel",vt),(Ge=s.domElement)===null||Ge===void 0||Ge.removeEventListener("wheel",z),(St=s.domElement)===null||St===void 0||St.ownerDocument.removeEventListener("pointermove",Ke),(Xt=s.domElement)===null||Xt===void 0||Xt.ownerDocument.removeEventListener("pointerup",ot),s._domElementKeyEvents!==null&&s._domElementKeyEvents.removeEventListener("keydown",ge)};const s=this,i={type:"change"},r={type:"start"},o={type:"end"},a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=a.NONE;const c=1e-6,u=new lI,h=new lI;let d=1;const f=new G;let m=!1;const x=new Ae,y=new Ae,v=new Ae,w=new Ae,b=new Ae,S=new Ae,C=new Ae,E=new Ae,k=new Ae,I=[],A={};function N(){return 2*Math.PI/60/60*s.autoRotateSpeed}function L(){return Math.pow(.95,s.zoomSpeed)}function V(J){s.reverseOrbit?h.theta+=J:h.theta-=J}function O(J){s.reverseOrbit?h.phi+=J:h.phi-=J}const P=(()=>{const J=new G;return function(Oe,Ge){J.setFromMatrixColumn(Ge,0),J.multiplyScalar(-Oe),f.add(J)}})(),W=(()=>{const J=new G;return function(Oe,Ge){s.screenSpacePanning===!0?J.setFromMatrixColumn(Ge,1):(J.setFromMatrixColumn(Ge,0),J.crossVectors(s.object.up,J)),J.multiplyScalar(Oe),f.add(J)}})(),H=(()=>{const J=new G;return function(Oe,Ge){const St=s.domElement;if(St&&s.object instanceof Un&&s.object.isPerspectiveCamera){const Xt=s.object.position;J.copy(Xt).sub(s.target);let Dn=J.length();Dn*=Math.tan(s.object.fov/2*Math.PI/180),P(2*Oe*Dn/St.clientHeight,s.object.matrix),W(2*Ge*Dn/St.clientHeight,s.object.matrix)}else St&&s.object instanceof xc&&s.object.isOrthographicCamera?(P(Oe*(s.object.right-s.object.left)/s.object.zoom/St.clientWidth,s.object.matrix),W(Ge*(s.object.top-s.object.bottom)/s.object.zoom/St.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}})();function Y(J){s.object instanceof Un&&s.object.isPerspectiveCamera?d/=J:s.object instanceof xc&&s.object.isOrthographicCamera?(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom*J)),s.object.updateProjectionMatrix(),m=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function D(J){s.object instanceof Un&&s.object.isPerspectiveCamera?d*=J:s.object instanceof xc&&s.object.isOrthographicCamera?(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/J)),s.object.updateProjectionMatrix(),m=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function $(J){x.set(J.clientX,J.clientY)}function U(J){C.set(J.clientX,J.clientY)}function B(J){w.set(J.clientX,J.clientY)}function X(J){y.set(J.clientX,J.clientY),v.subVectors(y,x).multiplyScalar(s.rotateSpeed);const ve=s.domElement;ve&&(V(2*Math.PI*v.x/ve.clientHeight),O(2*Math.PI*v.y/ve.clientHeight)),x.copy(y),s.update()}function te(J){E.set(J.clientX,J.clientY),k.subVectors(E,C),k.y>0?Y(L()):k.y<0&&D(L()),C.copy(E),s.update()}function oe(J){b.set(J.clientX,J.clientY),S.subVectors(b,w).multiplyScalar(s.panSpeed),H(S.x,S.y),w.copy(b),s.update()}function ue(J){J.deltaY<0?D(L()):J.deltaY>0&&Y(L()),s.update()}function Q(J){let ve=!1;switch(J.code){case s.keys.UP:H(0,s.keyPanSpeed),ve=!0;break;case s.keys.BOTTOM:H(0,-s.keyPanSpeed),ve=!0;break;case s.keys.LEFT:H(s.keyPanSpeed,0),ve=!0;break;case s.keys.RIGHT:H(-s.keyPanSpeed,0),ve=!0;break}ve&&(J.preventDefault(),s.update())}function ke(){if(I.length==1)x.set(I[0].pageX,I[0].pageY);else{const J=.5*(I[0].pageX+I[1].pageX),ve=.5*(I[0].pageY+I[1].pageY);x.set(J,ve)}}function Me(){if(I.length==1)w.set(I[0].pageX,I[0].pageY);else{const J=.5*(I[0].pageX+I[1].pageX),ve=.5*(I[0].pageY+I[1].pageY);w.set(J,ve)}}function De(){const J=I[0].pageX-I[1].pageX,ve=I[0].pageY-I[1].pageY,Oe=Math.sqrt(J*J+ve*ve);C.set(0,Oe)}function Ee(){s.enableZoom&&De(),s.enablePan&&Me()}function Be(){s.enableZoom&&De(),s.enableRotate&&ke()}function ye(J){if(I.length==1)y.set(J.pageX,J.pageY);else{const Oe=ht(J),Ge=.5*(J.pageX+Oe.x),St=.5*(J.pageY+Oe.y);y.set(Ge,St)}v.subVectors(y,x).multiplyScalar(s.rotateSpeed);const ve=s.domElement;ve&&(V(2*Math.PI*v.x/ve.clientHeight),O(2*Math.PI*v.y/ve.clientHeight)),x.copy(y)}function fe(J){if(I.length==1)b.set(J.pageX,J.pageY);else{const ve=ht(J),Oe=.5*(J.pageX+ve.x),Ge=.5*(J.pageY+ve.y);b.set(Oe,Ge)}S.subVectors(b,w).multiplyScalar(s.panSpeed),H(S.x,S.y),w.copy(b)}function Re(J){const ve=ht(J),Oe=J.pageX-ve.x,Ge=J.pageY-ve.y,St=Math.sqrt(Oe*Oe+Ge*Ge);E.set(0,St),k.set(0,Math.pow(E.y/C.y,s.zoomSpeed)),Y(k.y),C.copy(E)}function We(J){s.enableZoom&&Re(J),s.enablePan&&fe(J)}function Le(J){s.enableZoom&&Re(J),s.enableRotate&&ye(J)}function nt(J){if(s.enabled!==!1){if(I.length===0){var ve,Oe;(ve=s.domElement)===null||ve===void 0||ve.ownerDocument.addEventListener("pointermove",Ke),(Oe=s.domElement)===null||Oe===void 0||Oe.ownerDocument.addEventListener("pointerup",ot)}ft(J),J.pointerType==="touch"?Pe(J):Dt(J)}}function Ke(J){s.enabled!==!1&&(J.pointerType==="touch"?ze(J):q(J))}function ot(J){if(Ye(J),I.length===0){var ve,Oe,Ge;(ve=s.domElement)===null||ve===void 0||ve.releasePointerCapture(J.pointerId),(Oe=s.domElement)===null||Oe===void 0||Oe.ownerDocument.removeEventListener("pointermove",Ke),(Ge=s.domElement)===null||Ge===void 0||Ge.ownerDocument.removeEventListener("pointerup",ot)}s.dispatchEvent(o),l=a.NONE}function vt(J){Ye(J)}function Dt(J){let ve;switch(J.button){case 0:ve=s.mouseButtons.LEFT;break;case 1:ve=s.mouseButtons.MIDDLE;break;case 2:ve=s.mouseButtons.RIGHT;break;default:ve=-1}switch(ve){case gu.DOLLY:if(s.enableZoom===!1)return;U(J),l=a.DOLLY;break;case gu.ROTATE:if(J.ctrlKey||J.metaKey||J.shiftKey){if(s.enablePan===!1)return;B(J),l=a.PAN}else{if(s.enableRotate===!1)return;$(J),l=a.ROTATE}break;case gu.PAN:if(J.ctrlKey||J.metaKey||J.shiftKey){if(s.enableRotate===!1)return;$(J),l=a.ROTATE}else{if(s.enablePan===!1)return;B(J),l=a.PAN}break;default:l=a.NONE}l!==a.NONE&&s.dispatchEvent(r)}function q(J){if(s.enabled!==!1)switch(l){case a.ROTATE:if(s.enableRotate===!1)return;X(J);break;case a.DOLLY:if(s.enableZoom===!1)return;te(J);break;case a.PAN:if(s.enablePan===!1)return;oe(J);break}}function z(J){s.enabled===!1||s.enableZoom===!1||l!==a.NONE&&l!==a.ROTATE||(J.preventDefault(),s.dispatchEvent(r),ue(J),s.dispatchEvent(o))}function ge(J){s.enabled===!1||s.enablePan===!1||Q(J)}function Pe(J){switch(Te(J),I.length){case 1:switch(s.touches.ONE){case xu.ROTATE:if(s.enableRotate===!1)return;ke(),l=a.TOUCH_ROTATE;break;case xu.PAN:if(s.enablePan===!1)return;Me(),l=a.TOUCH_PAN;break;default:l=a.NONE}break;case 2:switch(s.touches.TWO){case xu.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;Ee(),l=a.TOUCH_DOLLY_PAN;break;case xu.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Be(),l=a.TOUCH_DOLLY_ROTATE;break;default:l=a.NONE}break;default:l=a.NONE}l!==a.NONE&&s.dispatchEvent(r)}function ze(J){switch(Te(J),l){case a.TOUCH_ROTATE:if(s.enableRotate===!1)return;ye(J),s.update();break;case a.TOUCH_PAN:if(s.enablePan===!1)return;fe(J),s.update();break;case a.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;We(J),s.update();break;case a.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Le(J),s.update();break;default:l=a.NONE}}function Xe(J){s.enabled!==!1&&J.preventDefault()}function ft(J){I.push(J)}function Ye(J){delete A[J.pointerId];for(let ve=0;ve<I.length;ve++)if(I[ve].pointerId==J.pointerId){I.splice(ve,1);return}}function Te(J){let ve=A[J.pointerId];ve===void 0&&(ve=new Ae,A[J.pointerId]=ve),ve.set(J.pageX,J.pageY)}function ht(J){const ve=J.pointerId===I[0].pointerId?I[1]:I[0];return A[ve.pointerId]}t!==void 0&&this.connect(t),this.update()}}const WP=new Ra,pv=new G;class PA extends MA{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],s=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(s),this.setAttribute("position",new ut(e,3)),this.setAttribute("uv",new ut(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,s=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),s.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const s=new V1(t,6,1);return this.setAttribute("instanceStart",new Cr(s,3,0)),this.setAttribute("instanceEnd",new Cr(s,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const s=new V1(t,6,1);return this.setAttribute("instanceColorStart",new Cr(s,3,0)),this.setAttribute("instanceColorEnd",new Cr(s,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new wA(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ra);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),WP.setFromBufferAttribute(t),this.boundingBox.union(WP))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new _l),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const s=this.boundingSphere.center;this.boundingBox.getCenter(s);let i=0;for(let r=0,o=e.count;r<o;r++)pv.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(pv)),pv.fromBufferAttribute(t,r),i=Math.max(i,s.distanceToSquared(pv));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}class aTe extends PA{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(e){const t=e.length-3,s=new Float32Array(2*t);for(let i=0;i<t;i+=3)s[2*i]=e[i],s[2*i+1]=e[i+1],s[2*i+2]=e[i+2],s[2*i+3]=e[i+3],s[2*i+4]=e[i+4],s[2*i+5]=e[i+5];return super.setPositions(s),this}setColors(e){const t=e.length-3,s=new Float32Array(2*t);for(let i=0;i<t;i+=3)s[2*i]=e[i],s[2*i+1]=e[i+1],s[2*i+2]=e[i+2],s[2*i+3]=e[i+3],s[2*i+4]=e[i+4],s[2*i+5]=e[i+5];return super.setColors(s),this}fromLine(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}}je.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new Ae(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};Fi.line={uniforms:Wb.merge([je.common,je.fog,je.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class $A extends jo{constructor(e){super({type:"LineMaterial",uniforms:Wb.clone(Fi.line.uniforms),vertexShader:Fi.line.vertexShader,fragmentShader:Fi.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return Boolean("USE_DASH"in this.defines)},set(t){Boolean(t)!==Boolean("USE_DASH"in this.defines)&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)},set:function(t){Boolean(t)!==Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)&&(this.needsUpdate=!0),t===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}}const GP=new G,HP=new G,ei=new rn,ti=new rn,aa=new rn,VC=new G,WC=new kt,xi=new O5,XP=new G,mv=new Ra,gv=new _l,la=new rn;let xa,pI,rH,ju;function jP(n,e,t){return la.set(0,0,-e,1).applyMatrix4(n.projectionMatrix),la.multiplyScalar(1/la.w),la.x=ju/t.width,la.y=ju/t.height,la.applyMatrix4(n.projectionMatrixInverse),la.multiplyScalar(1/la.w),Math.abs(Math.max(la.x,la.y))}function lTe(n,e){for(let t=0,s=pI.count;t<s;t++){xi.start.fromBufferAttribute(pI,t),xi.end.fromBufferAttribute(rH,t);const i=new G,r=new G;xa.distanceSqToSegment(xi.start,xi.end,r,i),r.distanceTo(i)<ju*.5&&e.push({point:r,pointOnLine:i,distance:xa.origin.distanceTo(r),object:n,face:null,faceIndex:t,uv:null,uv2:null})}}function cTe(n,e,t){const s=e.projectionMatrix,r=n.material.resolution,o=n.matrixWorld,a=n.geometry,l=a.attributes.instanceStart,c=a.attributes.instanceEnd,u=-e.near;xa.at(1,aa),aa.w=1,aa.applyMatrix4(e.matrixWorldInverse),aa.applyMatrix4(s),aa.multiplyScalar(1/aa.w),aa.x*=r.x/2,aa.y*=r.y/2,aa.z=0,VC.copy(aa),WC.multiplyMatrices(e.matrixWorldInverse,o);for(let h=0,d=l.count;h<d;h++){if(ei.fromBufferAttribute(l,h),ti.fromBufferAttribute(c,h),ei.w=1,ti.w=1,ei.applyMatrix4(WC),ti.applyMatrix4(WC),ei.z>u&&ti.z>u)continue;if(ei.z>u){const w=ei.z-ti.z,b=(ei.z-u)/w;ei.lerp(ti,b)}else if(ti.z>u){const w=ti.z-ei.z,b=(ti.z-u)/w;ti.lerp(ei,b)}ei.applyMatrix4(s),ti.applyMatrix4(s),ei.multiplyScalar(1/ei.w),ti.multiplyScalar(1/ti.w),ei.x*=r.x/2,ei.y*=r.y/2,ti.x*=r.x/2,ti.y*=r.y/2,xi.start.copy(ei),xi.start.z=0,xi.end.copy(ti),xi.end.z=0;const m=xi.closestPointToPointParameter(VC,!0);xi.at(m,XP);const x=tA.lerp(ei.z,ti.z,m),y=x>=-1&&x<=1,v=VC.distanceTo(XP)<ju*.5;if(y&&v){xi.start.fromBufferAttribute(l,h),xi.end.fromBufferAttribute(c,h),xi.start.applyMatrix4(o),xi.end.applyMatrix4(o);const w=new G,b=new G;xa.distanceSqToSegment(xi.start,xi.end,b,w),t.push({point:b,pointOnLine:w,distance:xa.origin.distanceTo(b),object:n,face:null,faceIndex:h,uv:null,uv2:null})}}}class uTe extends js{constructor(e=new PA,t=new $A({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,s=e.attributes.instanceEnd,i=new Float32Array(2*t.count);for(let o=0,a=0,l=t.count;o<l;o++,a+=2)GP.fromBufferAttribute(t,o),HP.fromBufferAttribute(s,o),i[a]=a===0?0:i[a-1],i[a+1]=i[a]+GP.distanceTo(HP);const r=new V1(i,2,1);return e.setAttribute("instanceDistanceStart",new Cr(r,1,0)),e.setAttribute("instanceDistanceEnd",new Cr(r,1,1)),this}raycast(e,t){const s=this.material.worldUnits,i=e.camera;i===null&&!s&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=e.params.Line2!==void 0&&e.params.Line2.threshold||0;xa=e.ray;const o=this.matrixWorld,a=this.geometry,l=this.material;ju=l.linewidth+r,pI=a.attributes.instanceStart,rH=a.attributes.instanceEnd,a.boundingSphere===null&&a.computeBoundingSphere(),gv.copy(a.boundingSphere).applyMatrix4(o);let c;if(s)c=ju*.5;else{const h=Math.max(i.near,gv.distanceToPoint(xa.origin));c=jP(i,h,l.resolution)}if(gv.radius+=c,xa.intersectsSphere(gv)===!1)return;a.boundingBox===null&&a.computeBoundingBox(),mv.copy(a.boundingBox).applyMatrix4(o);let u;if(s)u=ju*.5;else{const h=Math.max(i.near,mv.distanceToPoint(xa.origin));u=jP(i,h,l.resolution)}mv.expandByScalar(u),xa.intersectsBox(mv)!==!1&&(s?lTe(this,t):cTe(this,i,t))}}class hTe extends uTe{constructor(e=new aTe,t=new $A({color:Math.random()*16777215})){super(e,t),this.isLine2=!0,this.type="Line2"}}const dTe=qe.exports.forwardRef(({makeDefault:n,camera:e,regress:t,domElement:s,enableDamping:i=!0,onChange:r,onStart:o,onEnd:a,...l},c)=>{const u=Gl(C=>C.invalidate),h=Gl(C=>C.camera),d=Gl(C=>C.gl),f=Gl(C=>C.events),m=Gl(C=>C.setEvents),x=Gl(C=>C.set),y=Gl(C=>C.get),v=Gl(C=>C.performance),w=e||h,b=s||f.connected||d.domElement,S=qe.exports.useMemo(()=>new oTe(w),[w]);return Q5(()=>{S.enabled&&S.update()},-1),qe.exports.useEffect(()=>(S.connect(b),()=>void S.dispose()),[b,t,S,u]),qe.exports.useEffect(()=>{const C=I=>{u(),t&&v.regress(),r&&r(I)},E=I=>{o&&o(I)},k=I=>{a&&a(I)};return S.addEventListener("change",C),S.addEventListener("start",E),S.addEventListener("end",k),()=>{S.removeEventListener("start",E),S.removeEventListener("end",k),S.removeEventListener("change",C)}},[r,o,a,S,u,m]),qe.exports.useEffect(()=>{if(n){const C=y().controls;return x({controls:S}),()=>x({controls:C})}},[n,S]),Kt("primitive",{ref:c,object:S,enableDamping:i,...l})});class fTe{constructor(e,t=32){this.isLut=!0,this.lut=[],this.map=[],this.n=0,this.minV=0,this.maxV=1,this.setColorMap(e,t)}set(e){return e.isLut===!0&&this.copy(e),this}setMin(e){return this.minV=e,this}setMax(e){return this.maxV=e,this}setColorMap(e,t=32){this.map=GC[e]||GC.rainbow,this.n=t;const s=1/this.n,i=new Je,r=new Je;this.lut.length=0,this.lut.push(new Je(this.map[0][1]));for(let o=1;o<t;o++){const a=o*s;for(let l=0;l<this.map.length-1;l++)if(a>this.map[l][0]&&a<=this.map[l+1][0]){const c=this.map[l][0],u=this.map[l+1][0];i.set(this.map[l][1]),r.set(this.map[l+1][1]);const h=new Je().lerpColors(i,r,(a-c)/(u-c));this.lut.push(h)}}return this.lut.push(new Je(this.map[this.map.length-1][1])),this}copy(e){return this.lut=e.lut,this.map=e.map,this.n=e.n,this.minV=e.minV,this.maxV=e.maxV,this}getColor(e){e=tA.clamp(e,this.minV,this.maxV),e=(e-this.minV)/(this.maxV-this.minV);const t=Math.round(e*this.n);return this.lut[t]}addColorMap(e,t){return GC[e]=t,this}createCanvas(){const e=document.createElement("canvas");return e.width=1,e.height=this.n,this.updateCanvas(e),e}updateCanvas(e){const t=e.getContext("2d",{alpha:!1}),s=t.getImageData(0,0,1,this.n),i=s.data;let r=0;const o=1/this.n,a=new Je,l=new Je,c=new Je;for(let u=1;u>=0;u-=o)for(let h=this.map.length-1;h>=0;h--)if(u<this.map[h][0]&&u>=this.map[h-1][0]){const d=this.map[h-1][0],f=this.map[h][0];a.set(this.map[h-1][1]),l.set(this.map[h][1]),c.lerpColors(a,l,(u-d)/(f-d)),i[r*4]=Math.round(c.r*255),i[r*4+1]=Math.round(c.g*255),i[r*4+2]=Math.round(c.b*255),i[r*4+3]=255,r+=1}return t.putImageData(s,0,0),e}}const GC={rainbow:[[0,255],[.2,65535],[.5,65280],[.8,16776960],[1,16711680]],cooltowarm:[[0,3952322],[.2,10206463],[.5,14474460],[.8,16163717],[1,11797542]],blackbody:[[0,0],[.2,7864320],[.5,15086080],[.8,16776960],[1,16777215]],grayscale:[[0,0],[.2,4210752],[.5,8355712],[.8,12566463],[1,16777215]]},qP=n=>{let e;const t=new Set,s=(l,c)=>{const u=typeof l=="function"?l(e):l;if(!Object.is(u,e)){const h=e;e=(c!=null?c:typeof u!="object")?u:Object.assign({},e,u),t.forEach(d=>d(e,h))}},i=()=>e,a={setState:s,getState:i,subscribe:l=>(t.add(l),()=>t.delete(l)),destroy:()=>{var l;((l={BASE_URL:"/r3f-nn-visualizer/",MODE:"production",DEV:!1,PROD:!0})==null?void 0:l.MODE)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),t.clear()}};return e=n(s,i,a),a},pTe=n=>n?qP(n):qP;var oH={exports:{}},aH={},lH={exports:{}},cH={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Cf=qe.exports;function mTe(n,e){return n===e&&(n!==0||1/n===1/e)||n!==n&&e!==e}var gTe=typeof Object.is=="function"?Object.is:mTe,xTe=Cf.useState,yTe=Cf.useEffect,vTe=Cf.useLayoutEffect,wTe=Cf.useDebugValue;function bTe(n,e){var t=e(),s=xTe({inst:{value:t,getSnapshot:e}}),i=s[0].inst,r=s[1];return vTe(function(){i.value=t,i.getSnapshot=e,HC(i)&&r({inst:i})},[n,t,e]),yTe(function(){return HC(i)&&r({inst:i}),n(function(){HC(i)&&r({inst:i})})},[n]),wTe(t),t}function HC(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!gTe(n,t)}catch{return!0}}function STe(n,e){return e()}var _Te=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?STe:bTe;cH.useSyncExternalStore=Cf.useSyncExternalStore!==void 0?Cf.useSyncExternalStore:_Te;(function(n){n.exports=cH})(lH);/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var sS=qe.exports,CTe=lH.exports;function TTe(n,e){return n===e&&(n!==0||1/n===1/e)||n!==n&&e!==e}var ITe=typeof Object.is=="function"?Object.is:TTe,ETe=CTe.useSyncExternalStore,MTe=sS.useRef,kTe=sS.useEffect,ATe=sS.useMemo,NTe=sS.useDebugValue;aH.useSyncExternalStoreWithSelector=function(n,e,t,s,i){var r=MTe(null);if(r.current===null){var o={hasValue:!1,value:null};r.current=o}else o=r.current;r=ATe(function(){function l(f){if(!c){if(c=!0,u=f,f=s(f),i!==void 0&&o.hasValue){var m=o.value;if(i(m,f))return h=m}return h=f}if(m=h,ITe(u,f))return m;var x=s(f);return i!==void 0&&i(m,x)?m:(u=f,h=x)}var c=!1,u,h,d=t===void 0?null:t;return[function(){return l(e())},d===null?void 0:function(){return l(d())}]},[e,t,s,i]);var a=ETe(n,r[0],r[1]);return kTe(function(){o.hasValue=!0,o.value=a},[a]),NTe(a),a};(function(n){n.exports=aH})(oH);const RTe=mI(oH.exports),{useSyncExternalStoreWithSelector:DTe}=RTe;function LTe(n,e=n.getState,t){const s=DTe(n.subscribe,n.getState,n.getServerState||n.getState,e,t);return qe.exports.useDebugValue(s),s}const KP=n=>{var e;((e={BASE_URL:"/r3f-nn-visualizer/",MODE:"production",DEV:!1,PROD:!0})==null?void 0:e.MODE)!=="production"&&typeof n!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const t=typeof n=="function"?pTe(n):n,s=(i,r)=>LTe(t,i,r);return Object.assign(s,t),s},PTe=n=>n?KP(n):KP;var $Te=n=>{var e;return((e={BASE_URL:"/r3f-nn-visualizer/",MODE:"production",DEV:!1,PROD:!0})==null?void 0:e.MODE)!=="production"&&console.warn("[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."),PTe(n)};const uH=$Te((n,e)=>({activationData:null,actions:{updateActivationData:t=>n(s=>({activationData:t}))}})),FTe=()=>uH(n=>n.activationData),OTe=()=>uH(n=>n.actions),zTe=n=>n.inputSize+n.hiddenLayerSizes.reduce((e,t)=>e+t)+n.nClasses,BTe=n=>{let e=0;const t=[...n.hiddenLayerSizes,n.nClasses];return t.forEach((s,i)=>{const r=i==0?n.inputSize:t[i-1];e+=s*r}),e};class UTe{constructor(e,t){tu(this,"modelInput");tu(this,"modelActivations");this.modelInput=e,this.modelActivations=t}}class VTe{constructor(e){tu(this,"modelConfig");this.modelConfig=e}get layerSizes(){return[this.modelConfig.inputSize,...this.modelConfig.hiddenLayerSizes,this.modelConfig.nClasses]}get nLayers(){return this.layerSizes.length}get layerStartIdxs(){const e=[0];for(let t=0;t<this.layerSizes.length-1;t++)e.push(e[t]+this.layerSizes[t]);return e}get nNeurons(){return zTe(this.modelConfig)}get nSynapses(){return BTe(this.modelConfig)}get2DSideLength(e){return Math.ceil(Math.sqrt(this.layerSizes[e]))}getNeuronCountXYZForLayer(e){if(this.getIsLayerSquare(e)){const t=this.get2DSideLength(e);return[t,1,t]}return[this.layerSizes[e],1,1]}get maxNeuronsX(){return Math.max(this.get2DSideLength(0),...this.layerSizes.slice(1))}get maxNeuronsY(){return this.nLayers}getNeuronsByLayer(e){const t=e+1,s=this.layerStartIdxs[e],i=t<this.nLayers?s+this.layerSizes[e]:this.nNeurons;return Array.from({length:i-s},(r,o)=>s+o)}getLayerIdx(e){return WTe(this.layerStartIdxs,t=>t<=e)}getIsLayerSquare(e){return this.get2DSideLength(e)**2==this.layerSizes[e]}getActivation(e,t){const s=this.getLayerIdx(t);if(s==0)return e.modelInput[t];const i=t-this.layerStartIdxs[s];return e.modelActivations[s-1][i]}getNeuronXYZNorm(e){const t=this.getLayerIdx(e),s=e-this.layerStartIdxs[t];if(this.getIsLayerSquare(t)){const i=this.get2DSideLength(t),r=Math.floor(s/i);return[2*(s%i)/(i-1)-1,2*t/(this.nLayers-1)-1,1-2*r/(i-1)]}return[2*s/this.layerSizes[t]-1,2*t/(this.nLayers-1)-1,0]}getNSynapsesForNeuron(e){const s=this.getLayerIdx(e)+1;return s>=this.nLayers?0:this.layerSizes[s]}getNSynapsesForLayer(e){return this.layerSizes[e]*this.getNSynapsesForNeuron(this.layerStartIdxs[e])}getDstNeuronIdxs(e){const s=this.getLayerIdx(e)+1;return s>=this.nLayers?[]:this.getNeuronsByLayer(s)}getSynapseMap(){return Array.from({length:this.nNeurons}).map((e,t)=>this.getDstNeuronIdxs(t))}getFlattenedSynapseMap(){return this.getSynapseMap().map((e,t)=>e.map(s=>({srcIdx:t,dstIdx:s}))).reduce((e,t)=>e.concat(t),[])}}function WTe(n,e){let t=n.length;for(;t--;)if(e(n[t],t,n))return t;return-1}const GTe=({modelConfig:n,...e})=>{const t=new VTe(n),s=!1,i=.35,r=1,o=r*i,a=40*r*i,l=r*i,c=qe.exports.useMemo(()=>new Tl(i,i,i,1),[]),u=qe.exports.useMemo(()=>new Cl({color:"white",toneMapped:!1}),[]),[h]=qe.exports.useState(()=>new $A({linewidth:.15,vertexColors:!0,opacity:.8,resolution:new Ae(512,512)})),[d]=qe.exports.useState(()=>new PA),[f]=qe.exports.useState(()=>new hTe),[m]=qe.exports.useState(()=>Array(t.nSynapses*6).fill(0)),[x]=qe.exports.useState(()=>new Float32Array(Array(t.nSynapses*8).fill(0))),y=FTe(),v=new fTe("cooltowarm").setMin(0).setMax(1),w=qe.exports.useRef(null),b=qe.exports.useMemo(()=>new kt,[]),S=(E=0,k=!0)=>{let I=0,[A,N,L]=[0,0,0],[V,O,P]=[0,0,0],W=new Je,H=new Je("black"),Y=-1,D=-1,$=-1;const U=1/(t.nLayers-1),B=t.getFlattenedSynapseMap();for(let X=0;X<B.length;X++)I=B[X].srcIdx,I!==Y&&(Y=I,D=t.getLayerIdx(I)/(t.nLayers-1),$=E-D,$>=0?([A,N,L]=v.getColor(y?t.getActivation(y,I):0).toArray(),k&&$>=2*U?([V,O,P]=W.setRGB(A,N,L).lerp(H,$%U/U),[A,N,L]=H.toArray()):$>=U?[V,O,P]=[A,N,L]:[V,O,P]=W.setRGB(A,N,L).lerp(H,$/U)):([A,N,L]=H.toArray(),[V,O,P]=H.toArray())),x[X*6+0]=A,x[X*6+1]=N,x[X*6+2]=L,x[X*6+3]=V,x[X*6+4]=O,x[X*6+5]=P,d.attributes.color.setX(X+0,A),d.attributes.color.setX(X+1,N),d.attributes.color.setX(X+2,L),d.attributes.color.setX(X+3,V),d.attributes.color.setX(X+4,O),d.attributes.color.setX(X+5,P);d.setColors(x),d.attributes.color.needsUpdate=!0},C=()=>{let E=0,k=0;const I=t.getFlattenedSynapseMap();for(let A=0;A<I.length;A++){E=I[A].srcIdx,k=I[A].dstIdx;const[N,L,V]=t.getNeuronXYZNorm(E),[O,P,W]=t.getNeuronXYZNorm(k),[H,Y,D]=t.getNeuronCountXYZForLayer(t.getLayerIdx(E)),[$,U,B]=t.getNeuronCountXYZForLayer(t.getLayerIdx(k));m[A*6+0]=N*H*o,m[A*6+1]=L*Y*a,m[A*6+2]=V*D*l,m[A*6+3]=O*$*o,m[A*6+4]=P*U*a,m[A*6+5]=W*B*l}d.setPositions(m),f.computeLineDistances()};return Q5(({clock:E})=>{S(1,s)}),qe.exports.useEffect(()=>{for(let E=0;E<t.nNeurons;E++){let[k,I,A]=t.getNeuronXYZNorm(E);const[N,L,V]=t.getNeuronCountXYZForLayer(t.getLayerIdx(E));b.setPosition(k*N*o,I*L*a,A*V*l),w.current.setMatrixAt(E,b);const O=y?t.getActivation(y,E):0;w.current.setColorAt(E,v.getColor(O))}w.current.instanceMatrix.needsUpdate=!0,w.current.instanceColor.needsUpdate=!0,C(),S()},[t,w,f]),qe.exports.useEffect(()=>{if(!!y){for(let E=0;E<t.nNeurons;E++){const k=y?t.getActivation(y,E):0;w.current.setColorAt(E,v.getColor(k))}w.current.instanceColor.needsUpdate=!0}},[t,y]),ga(cI,{children:[Kt("instancedMesh",{ref:w,castShadow:!0,receiveShadow:!0,args:[c,u,t.nNeurons]}),ga("primitive",{object:f,children:[Kt("primitive",{object:d,attach:"geometry",children:Kt("bufferAttribute",{attach:"attributes-color",count:t.nSynapses,array:x,itemSize:x.length/t.nSynapses})}),Kt("primitive",{object:h,attach:"material",vertexColors:!0})]})]})},HTe=async(n,e)=>{const t=[n];return e.layers.forEach((s,i)=>{const r=s.apply(t[i]);t.push(r)}),new UTe(await t[0].data(),await Promise.all(t.slice(1).map(async s=>await s.data())))},XTe=({model:n,disabled:e=!1,...t})=>{const s=qe.exports.useRef(null),{updateActivationData:i}=OTe(),r=async()=>{const[o,a]=sye();if(s.current){const c=o.reshape([28,28,1]);await ZY(c,s.current)}const l=await HTe(o,n);i(l)};return qe.exports.useEffect(()=>{r()},[]),ga("div",{style:{height:"100%",display:"flex",flexDirection:"row",justifyContent:"left",gap:"20px",alignItems:"center"},children:[Kt("button",{disabled:e,style:{height:"75%"},onClick:r,children:"New Activations"}),Kt("canvas",{ref:s,width:28,height:28})]})},jTe=({completed:n,bgColor:e="#1e88e5",title:t="Progress"})=>{const s={width:"100%",backgroundColor:"#e0e0de",borderRadius:50},i={height:"100%",width:`${n}%`,backgroundColor:`${e}`,borderRadius:"inherit",textAlign:"right"};return Kt("div",{style:s,children:Kt("div",{style:i,children:Kt("span",{style:{padding:5,color:"white",fontWeight:"bold"},children:`${t}:${n}%`})})})};class qTe{constructor(e,t,s){tu(this,"epoch");tu(this,"nEpochs");tu(this,"logs");this.epoch=e,this.nEpochs=t,this.logs=s}toString(){return"Data for epoch "+this.epoch+", "+JSON.stringify(this.logs,function(e,t){return t.toFixed?Number(t.toFixed(3)):t})}}const KTe=({model:n,...e})=>{const[t,s]=qe.exports.useState([]),[i,r]=qe.exports.useState("NA"),o=50,[a,l]=qe.exports.useState(!1),[c,u]=qe.exports.useState(!1),h=(f,m)=>{r(m?`${Math.floor(100*m.val_acc)}%`:"NA"),s(x=>[new qTe(f,o,m),...x])},d=f=>{console.log(f),l(!0),u(!1);const m=f.history.val_acc.slice(-1)[0];r(`${Math.floor(100*m)}%`)};return ga("div",{style:{width:"100%",height:"10%",display:"flex",flexDirection:"row",justifyContent:"left",gap:"20px",alignItems:"center"},children:[Kt(XTe,{model:n,disabled:c}),a?ga("p",{children:["Using trained model w/ final accuracy ",i]}):c?ga(cI,{children:[Kt(jTe,{title:"Training",completed:100*t.length/o}),ga("p",{children:["Val Acc: ",i]})]}):ga(cI,{children:[Kt("button",{style:{height:"75%"},disabled:a,onClick:async()=>{u(!0);const f=await iye(n,o,h);d(f)},children:"Train Model"}),Kt("div",{className:"hideScroll",children:Kt("p",{children:"Activations will be random. Try training the model."})})]})]})},YTe=()=>{const n=zW,e=qe.exports.useMemo(()=>nye(n),[n]),t="#282828";return ga(qe.exports.Suspense,{fallback:Kt("span",{children:"loading..."}),children:[Kt(KTe,{model:e}),Kt("div",{style:{width:"100%",height:"90vh"},children:ga(sTe,{camera:{fov:45,near:1,far:1e3,position:[-40,-45,8],up:[0,0,1]},children:[Kt("color",{attach:"background",args:[t]}),Kt("ambientLight",{}),Kt(GTe,{modelConfig:n}),Kt(dTe,{makeDefault:!0})]})})]})};XC.createRoot(document.getElementById("root")).render(Kt(b6.StrictMode,{children:Kt(YTe,{})}));
